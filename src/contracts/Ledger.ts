/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate, AddressResolverFunction } from '@dappql/async'
import {
  encodeEventTopics,
  parseEventLogs,
  ParseEventLogsReturnType,
  Log,
  RpcLog,
  PublicClient,
  WalletClient,
} from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    name: 'DepartmentPauseModified',
    inputs: [
      {
        name: 'isPaused',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'DepartmentFundsRecovered',
    inputs: [
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'recipient',
        type: 'address',
        indexed: true,
      },
      {
        name: 'balance',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddys',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'hq',
            type: 'address',
          },
          {
            name: 'undyToken',
            type: 'address',
          },
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'switchboard',
            type: 'address',
          },
          {
            name: 'hatchery',
            type: 'address',
          },
          {
            name: 'lootDistributor',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'walletBackpack',
            type: 'address',
          },
          {
            name: 'billing',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUndyHq',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canMintUndy',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'pause',
    inputs: [
      {
        name: '_shouldPause',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFunds',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFundsMany',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_assets',
        type: 'address[]',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isPaused',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'createUserWallet',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_ambassador',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getNumUserWallets',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isUserWallet',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setUserPoints',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_data',
        type: 'tuple',
        components: [
          {
            name: 'usdValue',
            type: 'uint256',
          },
          {
            name: 'depositPoints',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setGlobalPoints',
    inputs: [
      {
        name: '_data',
        type: 'tuple',
        components: [
          {
            name: 'usdValue',
            type: 'uint256',
          },
          {
            name: 'depositPoints',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setUserAndGlobalPoints',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_userData',
        type: 'tuple',
        components: [
          {
            name: 'usdValue',
            type: 'uint256',
          },
          {
            name: 'depositPoints',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_globalData',
        type: 'tuple',
        components: [
          {
            name: 'usdValue',
            type: 'uint256',
          },
          {
            name: 'depositPoints',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLastTotalUsdValue',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUserAndGlobalPoints',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'usdValue',
            type: 'uint256',
          },
          {
            name: 'depositPoints',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'usdValue',
            type: 'uint256',
          },
          {
            name: 'depositPoints',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isRegisteredVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_underlyingAsset',
        type: 'address',
      },
      {
        name: '_decimals',
        type: 'uint256',
      },
      {
        name: '_isRebasing',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'registerBackpackItem',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'createAgent',
    inputs: [
      {
        name: '_agent',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getNumAgents',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isAgent',
    inputs: [
      {
        name: '_agent',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'userPoints',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'usdValue',
            type: 'uint256',
          },
          {
            name: 'depositPoints',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'globalPoints',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'usdValue',
            type: 'uint256',
          },
          {
            name: 'depositPoints',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'userWallets',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'indexOfUserWallet',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numUserWallets',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'ambassadors',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'agents',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'indexOfAgent',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numAgents',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'vaultTokens',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'underlyingAsset',
            type: 'address',
          },
          {
            name: 'decimals',
            type: 'uint256',
          },
          {
            name: 'isRebasing',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isRegisteredBackpackItem',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'constructor',
    inputs: [
      {
        name: '_undyHq',
        type: 'address',
      },
    ],
    outputs: [],
  },
] as const

export const deployAddress: Address | undefined = '0x9e97A2e527890E690c7FA978696A88EFA868c5D0'

export type Contract = {
  calls: {
    getAddys: () => Promise<{
      hq: `0x${string}`
      undyToken: `0x${string}`
      ledger: `0x${string}`
      missionControl: `0x${string}`
      legoBook: `0x${string}`
      switchboard: `0x${string}`
      hatchery: `0x${string}`
      lootDistributor: `0x${string}`
      appraiser: `0x${string}`
      walletBackpack: `0x${string}`
      billing: `0x${string}`
    }>
    getUndyHq: () => Promise<`0x${string}`>
    canMintUndy: () => Promise<boolean>
    isPaused: () => Promise<boolean>
    getNumUserWallets: () => Promise<bigint>
    isUserWallet: (user: `0x${string}`) => Promise<boolean>
    getLastTotalUsdValue: (user: `0x${string}`) => Promise<bigint>
    getUserAndGlobalPoints: (
      user: `0x${string}`,
    ) => Promise<
      [
        { usdValue: bigint; depositPoints: bigint; lastUpdate: bigint },
        { usdValue: bigint; depositPoints: bigint; lastUpdate: bigint },
      ]
    >
    isRegisteredVaultToken: (vaultToken: `0x${string}`) => Promise<boolean>
    getNumAgents: () => Promise<bigint>
    isAgent: (agent: `0x${string}`) => Promise<boolean>
    userPoints: (arg0: `0x${string}`) => Promise<{ usdValue: bigint; depositPoints: bigint; lastUpdate: bigint }>
    globalPoints: () => Promise<{ usdValue: bigint; depositPoints: bigint; lastUpdate: bigint }>
    userWallets: (arg0: bigint) => Promise<`0x${string}`>
    indexOfUserWallet: (arg0: `0x${string}`) => Promise<bigint>
    numUserWallets: () => Promise<bigint>
    ambassadors: (arg0: `0x${string}`) => Promise<`0x${string}`>
    agents: (arg0: bigint) => Promise<`0x${string}`>
    indexOfAgent: (arg0: `0x${string}`) => Promise<bigint>
    numAgents: () => Promise<bigint>
    vaultTokens: (
      arg0: `0x${string}`,
    ) => Promise<{ legoId: bigint; underlyingAsset: `0x${string}`; decimals: bigint; isRebasing: boolean }>
    isRegisteredBackpackItem: (arg0: `0x${string}`) => Promise<boolean>
  }
  mutations: {
    pause: (shouldPause: boolean) => Promise<void>
    recoverFunds: (recipient: `0x${string}`, asset: `0x${string}`) => Promise<void>
    recoverFundsMany: (recipient: `0x${string}`, assets: `0x${string}`[]) => Promise<void>
    createUserWallet: (user: `0x${string}`, ambassador: `0x${string}`) => Promise<void>
    setUserPoints: (
      user: `0x${string}`,
      data: { usdValue: bigint; depositPoints: bigint; lastUpdate: bigint },
    ) => Promise<void>
    setGlobalPoints: (data: { usdValue: bigint; depositPoints: bigint; lastUpdate: bigint }) => Promise<void>
    setUserAndGlobalPoints: (
      user: `0x${string}`,
      userData: { usdValue: bigint; depositPoints: bigint; lastUpdate: bigint },
      globalData: { usdValue: bigint; depositPoints: bigint; lastUpdate: bigint },
    ) => Promise<void>
    setVaultToken: (
      vaultToken: `0x${string}`,
      legoId: bigint,
      underlyingAsset: `0x${string}`,
      decimals: bigint,
      isRebasing: boolean,
    ) => Promise<void>
    registerBackpackItem: (addr: `0x${string}`) => Promise<void>
    createAgent: (agent: `0x${string}`) => Promise<void>
  }
  events: {
    DepartmentPauseModified: (isPaused: boolean) => Promise<void>
    DepartmentFundsRecovered: (asset: `0x${string}`, recipient: `0x${string}`, balance: bigint) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'Ledger'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'Ledger' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => getRequest('getAddys', args),
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => getRequest('getUndyHq', args),
  canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) => getRequest('canMintUndy', args),
  isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) => getRequest('isPaused', args),
  getNumUserWallets: (...args: ExtractArgs<Contract['calls']['getNumUserWallets']>) =>
    getRequest('getNumUserWallets', args),
  isUserWallet: (...args: ExtractArgs<Contract['calls']['isUserWallet']>) => getRequest('isUserWallet', args),
  getLastTotalUsdValue: (...args: ExtractArgs<Contract['calls']['getLastTotalUsdValue']>) =>
    getRequest('getLastTotalUsdValue', args),
  getUserAndGlobalPoints: (...args: ExtractArgs<Contract['calls']['getUserAndGlobalPoints']>) =>
    getRequest('getUserAndGlobalPoints', args),
  isRegisteredVaultToken: (...args: ExtractArgs<Contract['calls']['isRegisteredVaultToken']>) =>
    getRequest('isRegisteredVaultToken', args),
  getNumAgents: (...args: ExtractArgs<Contract['calls']['getNumAgents']>) => getRequest('getNumAgents', args),
  isAgent: (...args: ExtractArgs<Contract['calls']['isAgent']>) => getRequest('isAgent', args),
  userPoints: (...args: ExtractArgs<Contract['calls']['userPoints']>) => getRequest('userPoints', args),
  globalPoints: (...args: ExtractArgs<Contract['calls']['globalPoints']>) => getRequest('globalPoints', args),
  userWallets: (...args: ExtractArgs<Contract['calls']['userWallets']>) => getRequest('userWallets', args),
  indexOfUserWallet: (...args: ExtractArgs<Contract['calls']['indexOfUserWallet']>) =>
    getRequest('indexOfUserWallet', args),
  numUserWallets: (...args: ExtractArgs<Contract['calls']['numUserWallets']>) => getRequest('numUserWallets', args),
  ambassadors: (...args: ExtractArgs<Contract['calls']['ambassadors']>) => getRequest('ambassadors', args),
  agents: (...args: ExtractArgs<Contract['calls']['agents']>) => getRequest('agents', args),
  indexOfAgent: (...args: ExtractArgs<Contract['calls']['indexOfAgent']>) => getRequest('indexOfAgent', args),
  numAgents: (...args: ExtractArgs<Contract['calls']['numAgents']>) => getRequest('numAgents', args),
  vaultTokens: (...args: ExtractArgs<Contract['calls']['vaultTokens']>) => getRequest('vaultTokens', args),
  isRegisteredBackpackItem: (...args: ExtractArgs<Contract['calls']['isRegisteredBackpackItem']>) =>
    getRequest('isRegisteredBackpackItem', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'Ledger' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'Ledger'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  pause: getMutation('pause'),
  recoverFunds: getMutation('recoverFunds'),
  recoverFundsMany: getMutation('recoverFundsMany'),
  createUserWallet: getMutation('createUserWallet'),
  setUserPoints: getMutation('setUserPoints'),
  setGlobalPoints: getMutation('setGlobalPoints'),
  setUserAndGlobalPoints: getMutation('setUserAndGlobalPoints'),
  setVaultToken: getMutation('setVaultToken'),
  registerBackpackItem: getMutation('registerBackpackItem'),
  createAgent: getMutation('createAgent'),
}

export type ParsedEvent<T extends keyof Contract['events']> = {
  event: RpcLog | Log
  parsed: ParseEventLogsReturnType<typeof abi, T>
}

export function parseEvents<T extends keyof Contract['events']>(
  eventName: T,
  events: (RpcLog | Log)[],
): ParsedEvent<T>[] {
  return events.map((event) => {
    return {
      event,
      parsed: parseEventLogs({
        abi,
        eventName,
        logs: [event],
      }),
    }
  })
}

export function getEventTopic<T extends keyof Contract['events']>(eventName: T): Address {
  return encodeEventTopics({ abi, eventName })[0] as Address
}

export type SDK = {
  deployAddress: Address | undefined
  abi: typeof abi
  events: {
    DepartmentPauseModified: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'DepartmentPauseModified'>[]
    }
    DepartmentFundsRecovered: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'DepartmentFundsRecovered'>[]
    }
  }
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => Promise<CallReturn<'getAddys'>>
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => Promise<CallReturn<'getUndyHq'>>
  canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) => Promise<CallReturn<'canMintUndy'>>
  isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) => Promise<CallReturn<'isPaused'>>
  getNumUserWallets: (
    ...args: ExtractArgs<Contract['calls']['getNumUserWallets']>
  ) => Promise<CallReturn<'getNumUserWallets'>>
  isUserWallet: (...args: ExtractArgs<Contract['calls']['isUserWallet']>) => Promise<CallReturn<'isUserWallet'>>
  getLastTotalUsdValue: (
    ...args: ExtractArgs<Contract['calls']['getLastTotalUsdValue']>
  ) => Promise<CallReturn<'getLastTotalUsdValue'>>
  getUserAndGlobalPoints: (
    ...args: ExtractArgs<Contract['calls']['getUserAndGlobalPoints']>
  ) => Promise<CallReturn<'getUserAndGlobalPoints'>>
  isRegisteredVaultToken: (
    ...args: ExtractArgs<Contract['calls']['isRegisteredVaultToken']>
  ) => Promise<CallReturn<'isRegisteredVaultToken'>>
  getNumAgents: (...args: ExtractArgs<Contract['calls']['getNumAgents']>) => Promise<CallReturn<'getNumAgents'>>
  isAgent: (...args: ExtractArgs<Contract['calls']['isAgent']>) => Promise<CallReturn<'isAgent'>>
  userPoints: (...args: ExtractArgs<Contract['calls']['userPoints']>) => Promise<CallReturn<'userPoints'>>
  globalPoints: (...args: ExtractArgs<Contract['calls']['globalPoints']>) => Promise<CallReturn<'globalPoints'>>
  userWallets: (...args: ExtractArgs<Contract['calls']['userWallets']>) => Promise<CallReturn<'userWallets'>>
  indexOfUserWallet: (
    ...args: ExtractArgs<Contract['calls']['indexOfUserWallet']>
  ) => Promise<CallReturn<'indexOfUserWallet'>>
  numUserWallets: (...args: ExtractArgs<Contract['calls']['numUserWallets']>) => Promise<CallReturn<'numUserWallets'>>
  ambassadors: (...args: ExtractArgs<Contract['calls']['ambassadors']>) => Promise<CallReturn<'ambassadors'>>
  agents: (...args: ExtractArgs<Contract['calls']['agents']>) => Promise<CallReturn<'agents'>>
  indexOfAgent: (...args: ExtractArgs<Contract['calls']['indexOfAgent']>) => Promise<CallReturn<'indexOfAgent'>>
  numAgents: (...args: ExtractArgs<Contract['calls']['numAgents']>) => Promise<CallReturn<'numAgents'>>
  vaultTokens: (...args: ExtractArgs<Contract['calls']['vaultTokens']>) => Promise<CallReturn<'vaultTokens'>>
  isRegisteredBackpackItem: (
    ...args: ExtractArgs<Contract['calls']['isRegisteredBackpackItem']>
  ) => Promise<CallReturn<'isRegisteredBackpackItem'>>
  pause: (...args: ExtractArgs<Contract['mutations']['pause']>) => Promise<Address>
  recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) => Promise<Address>
  recoverFundsMany: (...args: ExtractArgs<Contract['mutations']['recoverFundsMany']>) => Promise<Address>
  createUserWallet: (...args: ExtractArgs<Contract['mutations']['createUserWallet']>) => Promise<Address>
  setUserPoints: (...args: ExtractArgs<Contract['mutations']['setUserPoints']>) => Promise<Address>
  setGlobalPoints: (...args: ExtractArgs<Contract['mutations']['setGlobalPoints']>) => Promise<Address>
  setUserAndGlobalPoints: (...args: ExtractArgs<Contract['mutations']['setUserAndGlobalPoints']>) => Promise<Address>
  setVaultToken: (...args: ExtractArgs<Contract['mutations']['setVaultToken']>) => Promise<Address>
  registerBackpackItem: (...args: ExtractArgs<Contract['mutations']['registerBackpackItem']>) => Promise<Address>
  createAgent: (...args: ExtractArgs<Contract['mutations']['createAgent']>) => Promise<Address>
}

export function toSdk(
  publicClient?: PublicClient,
  walletClient?: WalletClient,
  addressResolver?: AddressResolverFunction,
): SDK {
  return {
    deployAddress,
    abi,

    events: {
      DepartmentPauseModified: {
        topic: getEventTopic('DepartmentPauseModified'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('DepartmentPauseModified', events),
      },
      DepartmentFundsRecovered: {
        topic: getEventTopic('DepartmentFundsRecovered'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('DepartmentFundsRecovered', events),
      },
    },
    // Queries
    getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) =>
      singleQuery(publicClient!, call.getAddys(...args), {}, addressResolver) as Promise<CallReturn<'getAddys'>>,
    getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) =>
      singleQuery(publicClient!, call.getUndyHq(...args), {}, addressResolver) as Promise<CallReturn<'getUndyHq'>>,
    canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) =>
      singleQuery(publicClient!, call.canMintUndy(...args), {}, addressResolver) as Promise<CallReturn<'canMintUndy'>>,
    isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) =>
      singleQuery(publicClient!, call.isPaused(...args), {}, addressResolver) as Promise<CallReturn<'isPaused'>>,
    getNumUserWallets: (...args: ExtractArgs<Contract['calls']['getNumUserWallets']>) =>
      singleQuery(publicClient!, call.getNumUserWallets(...args), {}, addressResolver) as Promise<
        CallReturn<'getNumUserWallets'>
      >,
    isUserWallet: (...args: ExtractArgs<Contract['calls']['isUserWallet']>) =>
      singleQuery(publicClient!, call.isUserWallet(...args), {}, addressResolver) as Promise<
        CallReturn<'isUserWallet'>
      >,
    getLastTotalUsdValue: (...args: ExtractArgs<Contract['calls']['getLastTotalUsdValue']>) =>
      singleQuery(publicClient!, call.getLastTotalUsdValue(...args), {}, addressResolver) as Promise<
        CallReturn<'getLastTotalUsdValue'>
      >,
    getUserAndGlobalPoints: (...args: ExtractArgs<Contract['calls']['getUserAndGlobalPoints']>) =>
      singleQuery(publicClient!, call.getUserAndGlobalPoints(...args), {}, addressResolver) as Promise<
        CallReturn<'getUserAndGlobalPoints'>
      >,
    isRegisteredVaultToken: (...args: ExtractArgs<Contract['calls']['isRegisteredVaultToken']>) =>
      singleQuery(publicClient!, call.isRegisteredVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'isRegisteredVaultToken'>
      >,
    getNumAgents: (...args: ExtractArgs<Contract['calls']['getNumAgents']>) =>
      singleQuery(publicClient!, call.getNumAgents(...args), {}, addressResolver) as Promise<
        CallReturn<'getNumAgents'>
      >,
    isAgent: (...args: ExtractArgs<Contract['calls']['isAgent']>) =>
      singleQuery(publicClient!, call.isAgent(...args), {}, addressResolver) as Promise<CallReturn<'isAgent'>>,
    userPoints: (...args: ExtractArgs<Contract['calls']['userPoints']>) =>
      singleQuery(publicClient!, call.userPoints(...args), {}, addressResolver) as Promise<CallReturn<'userPoints'>>,
    globalPoints: (...args: ExtractArgs<Contract['calls']['globalPoints']>) =>
      singleQuery(publicClient!, call.globalPoints(...args), {}, addressResolver) as Promise<
        CallReturn<'globalPoints'>
      >,
    userWallets: (...args: ExtractArgs<Contract['calls']['userWallets']>) =>
      singleQuery(publicClient!, call.userWallets(...args), {}, addressResolver) as Promise<CallReturn<'userWallets'>>,
    indexOfUserWallet: (...args: ExtractArgs<Contract['calls']['indexOfUserWallet']>) =>
      singleQuery(publicClient!, call.indexOfUserWallet(...args), {}, addressResolver) as Promise<
        CallReturn<'indexOfUserWallet'>
      >,
    numUserWallets: (...args: ExtractArgs<Contract['calls']['numUserWallets']>) =>
      singleQuery(publicClient!, call.numUserWallets(...args), {}, addressResolver) as Promise<
        CallReturn<'numUserWallets'>
      >,
    ambassadors: (...args: ExtractArgs<Contract['calls']['ambassadors']>) =>
      singleQuery(publicClient!, call.ambassadors(...args), {}, addressResolver) as Promise<CallReturn<'ambassadors'>>,
    agents: (...args: ExtractArgs<Contract['calls']['agents']>) =>
      singleQuery(publicClient!, call.agents(...args), {}, addressResolver) as Promise<CallReturn<'agents'>>,
    indexOfAgent: (...args: ExtractArgs<Contract['calls']['indexOfAgent']>) =>
      singleQuery(publicClient!, call.indexOfAgent(...args), {}, addressResolver) as Promise<
        CallReturn<'indexOfAgent'>
      >,
    numAgents: (...args: ExtractArgs<Contract['calls']['numAgents']>) =>
      singleQuery(publicClient!, call.numAgents(...args), {}, addressResolver) as Promise<CallReturn<'numAgents'>>,
    vaultTokens: (...args: ExtractArgs<Contract['calls']['vaultTokens']>) =>
      singleQuery(publicClient!, call.vaultTokens(...args), {}, addressResolver) as Promise<CallReturn<'vaultTokens'>>,
    isRegisteredBackpackItem: (...args: ExtractArgs<Contract['calls']['isRegisteredBackpackItem']>) =>
      singleQuery(publicClient!, call.isRegisteredBackpackItem(...args), {}, addressResolver) as Promise<
        CallReturn<'isRegisteredBackpackItem'>
      >,

    // Mutations
    pause: (...args: ExtractArgs<Contract['mutations']['pause']>) =>
      mutate(walletClient!, mutation.pause, { addressResolver })(...args),
    recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) =>
      mutate(walletClient!, mutation.recoverFunds, { addressResolver })(...args),
    recoverFundsMany: (...args: ExtractArgs<Contract['mutations']['recoverFundsMany']>) =>
      mutate(walletClient!, mutation.recoverFundsMany, { addressResolver })(...args),
    createUserWallet: (...args: ExtractArgs<Contract['mutations']['createUserWallet']>) =>
      mutate(walletClient!, mutation.createUserWallet, { addressResolver })(...args),
    setUserPoints: (...args: ExtractArgs<Contract['mutations']['setUserPoints']>) =>
      mutate(walletClient!, mutation.setUserPoints, { addressResolver })(...args),
    setGlobalPoints: (...args: ExtractArgs<Contract['mutations']['setGlobalPoints']>) =>
      mutate(walletClient!, mutation.setGlobalPoints, { addressResolver })(...args),
    setUserAndGlobalPoints: (...args: ExtractArgs<Contract['mutations']['setUserAndGlobalPoints']>) =>
      mutate(walletClient!, mutation.setUserAndGlobalPoints, { addressResolver })(...args),
    setVaultToken: (...args: ExtractArgs<Contract['mutations']['setVaultToken']>) =>
      mutate(walletClient!, mutation.setVaultToken, { addressResolver })(...args),
    registerBackpackItem: (...args: ExtractArgs<Contract['mutations']['registerBackpackItem']>) =>
      mutate(walletClient!, mutation.registerBackpackItem, { addressResolver })(...args),
    createAgent: (...args: ExtractArgs<Contract['mutations']['createAgent']>) =>
      mutate(walletClient!, mutation.createAgent, { addressResolver })(...args),
  }
}
