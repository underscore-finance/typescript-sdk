/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate, AddressResolverFunction } from '@dappql/async'
import {
  encodeEventTopics,
  parseEventLogs,
  ParseEventLogsReturnType,
  Log,
  RpcLog,
  PublicClient,
  WalletClient,
} from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    name: 'CanDepositSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'canDeposit',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'CanWithdrawSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'canWithdraw',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'MaxDepositAmountSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'maxDepositAmount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'VaultOpsFrozenSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isFrozen',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'RedemptionBufferSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'buffer',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'MinYieldWithdrawAmountSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PerformanceFeeSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'performanceFee',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'DefaultTargetVaultTokenSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'targetVaultToken',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ShouldAutoDepositSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'shouldAutoDeposit',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'IsLeveragedVaultSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isLeveragedVault',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ApprovedVaultTokenSet',
    inputs: [
      {
        name: 'undyVaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'underlyingAsset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isApproved',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'shouldMaxWithdraw',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'VaultTokenAdded',
    inputs: [
      {
        name: 'undyVaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'underlyingAsset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'VaultTokenRemoved',
    inputs: [
      {
        name: 'undyVaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'underlyingAsset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AssetVaultTokenAdded',
    inputs: [
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AssetVaultTokenRemoved',
    inputs: [
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ShouldEnforceAllowlistSet',
    inputs: [
      {
        name: 'undyVault',
        type: 'address',
        indexed: true,
      },
      {
        name: 'shouldEnforce',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AllowlistSet',
    inputs: [
      {
        name: 'undyVault',
        type: 'address',
        indexed: true,
      },
      {
        name: 'user',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isAllowed',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeTimeLockModified',
    inputs: [
      {
        name: 'prevTimeLock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'newTimeLock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'RegistryTimeLockModified',
    inputs: [
      {
        name: 'newTimeLock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'prevTimeLock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeStarted',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeConfirmed',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeCancelled',
    inputs: [
      {
        name: 'cancelledGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovRelinquished',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'UndyHqSetupFinished',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'timeLock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'DepartmentPauseModified',
    inputs: [
      {
        name: 'isPaused',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'DepartmentFundsRecovered',
    inputs: [
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'recipient',
        type: 'address',
        indexed: true,
      },
      {
        name: 'balance',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'NewAddressPending',
    inputs: [
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'NewAddressConfirmed',
    inputs: [
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'regId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'NewAddressCancelled',
    inputs: [
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AddressDisablePending',
    inputs: [
      {
        name: 'regId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'version',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AddressDisableConfirmed',
    inputs: [
      {
        name: 'regId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'version',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AddressDisableCancelled',
    inputs: [
      {
        name: 'regId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUndyHqFromGov',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canGovern',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getGovernors',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasPendingGovChange',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'startGovernanceChange',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmGovernanceChange',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cancelGovernanceChange',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'relinquishGov',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setGovTimeLock',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidGovTimeLock',
    inputs: [
      {
        name: '_newTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'minGovChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'maxGovChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'finishUndyHqSetup',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'finishUndyHqSetup',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
      {
        name: '_timeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'governance',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingGov',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'newGov',
            type: 'address',
          },
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numGovChanges',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'govChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getRegistryDescription',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'string',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidNewAddress',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidAddressUpdate',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
      {
        name: '_newAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidAddressDisable',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRegistryTimeLock',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidRegistryTimeLock',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRegistryTimeLockAfterSetup',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRegistryTimeLockAfterSetup',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'minRegistryTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'maxRegistryTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidAddr',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidRegId',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getRegId',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddr',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddrInfo',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'addr',
            type: 'address',
          },
          {
            name: 'version',
            type: 'uint256',
          },
          {
            name: 'lastModified',
            type: 'uint256',
          },
          {
            name: 'description',
            type: 'string',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddrDescription',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'string',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getNumAddrs',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLastAddr',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLastRegId',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'registryChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'addrInfo',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'addr',
            type: 'address',
          },
          {
            name: 'version',
            type: 'uint256',
          },
          {
            name: 'lastModified',
            type: 'uint256',
          },
          {
            name: 'description',
            type: 'string',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'addrToRegId',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numAddrs',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingNewAddr',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'description',
            type: 'string',
          },
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingAddrUpdate',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'newAddr',
            type: 'address',
          },
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingAddrDisable',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddys',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'hq',
            type: 'address',
          },
          {
            name: 'undyToken',
            type: 'address',
          },
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'switchboard',
            type: 'address',
          },
          {
            name: 'hatchery',
            type: 'address',
          },
          {
            name: 'lootDistributor',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'walletBackpack',
            type: 'address',
          },
          {
            name: 'billing',
            type: 'address',
          },
          {
            name: 'vaultRegistry',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUndyHq',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canMintUndy',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'pause',
    inputs: [
      {
        name: '_shouldPause',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFunds',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFundsMany',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_assets',
        type: 'address[]',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isPaused',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isEarnVault',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isLeveragedVault',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isBasicEarnVault',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasConfig',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'startAddNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_description',
        type: 'string',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
      {
        name: '_isVaultOpsFrozen',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
      {
        name: '_shouldEnforceAllowlist',
        type: 'bool',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
      {
        name: '_isVaultOpsFrozen',
        type: 'bool',
      },
      {
        name: '_redemptionBuffer',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cancelNewAddressToRegistry',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'startAddressDisableInRegistry',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmAddressDisableInRegistry',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cancelAddressDisableInRegistry',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setCanDeposit',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setCanWithdraw',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setMaxDepositAmount',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setVaultOpsFrozen',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isFrozen',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setShouldAutoDeposit',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setMinYieldWithdrawAmount',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setIsLeveragedVault',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setShouldEnforceAllowlist',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_shouldEnforce',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setAllowed',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_isAllowed',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setAllowedBatch',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_users',
        type: 'address[]',
      },
      {
        name: '_isAllowed',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setDefaultTargetVaultToken',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_targetVaultToken',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidDefaultTargetVaultToken',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_targetVaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setPerformanceFee',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidPerformanceFee',
    inputs: [
      {
        name: '_performanceFee',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRedemptionBuffer',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_buffer',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidRedemptionBuffer',
    inputs: [
      {
        name: '_buffer',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setApprovedVaultToken',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_isApproved',
        type: 'bool',
      },
      {
        name: '_shouldMaxWithdraw',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setApprovedVaultTokens',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_vaultTokens',
        type: 'address[]',
      },
      {
        name: '_isApproved',
        type: 'bool',
      },
      {
        name: '_shouldMaxWithdraw',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getApprovedVaultTokens',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAssetVaultTokens',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getNumApprovedVaultTokens',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getNumAssetVaultTokens',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isApprovedVaultTokenForAsset',
    inputs: [
      {
        name: '_underlyingAsset',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canDeposit',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canWithdraw',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'maxDepositAmount',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isVaultOpsFrozen',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'redemptionBuffer',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'minYieldWithdrawAmount',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'redemptionConfig',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getPerformanceFee',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getDefaultTargetVaultToken',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'shouldAutoDeposit',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'shouldEnforceAllowlist',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isUserAllowed',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_userAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isApprovedVaultTokenByAddr',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'checkVaultApprovals',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultConfig',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'canDeposit',
            type: 'bool',
          },
          {
            name: 'canWithdraw',
            type: 'bool',
          },
          {
            name: 'maxDepositAmount',
            type: 'uint256',
          },
          {
            name: 'isVaultOpsFrozen',
            type: 'bool',
          },
          {
            name: 'redemptionBuffer',
            type: 'uint256',
          },
          {
            name: 'minYieldWithdrawAmount',
            type: 'uint256',
          },
          {
            name: 'performanceFee',
            type: 'uint256',
          },
          {
            name: 'shouldAutoDeposit',
            type: 'bool',
          },
          {
            name: 'defaultTargetVaultToken',
            type: 'address',
          },
          {
            name: 'isLeveragedVault',
            type: 'bool',
          },
          {
            name: 'shouldEnforceAllowlist',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultConfigByAddr',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'canDeposit',
            type: 'bool',
          },
          {
            name: 'canWithdraw',
            type: 'bool',
          },
          {
            name: 'maxDepositAmount',
            type: 'uint256',
          },
          {
            name: 'isVaultOpsFrozen',
            type: 'bool',
          },
          {
            name: 'redemptionBuffer',
            type: 'uint256',
          },
          {
            name: 'minYieldWithdrawAmount',
            type: 'uint256',
          },
          {
            name: 'performanceFee',
            type: 'uint256',
          },
          {
            name: 'shouldAutoDeposit',
            type: 'bool',
          },
          {
            name: 'defaultTargetVaultToken',
            type: 'address',
          },
          {
            name: 'isLeveragedVault',
            type: 'bool',
          },
          {
            name: 'shouldEnforceAllowlist',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultActionDataBundle',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_signer',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'vaultRegistry',
            type: 'address',
          },
          {
            name: 'vaultAsset',
            type: 'address',
          },
          {
            name: 'signer',
            type: 'address',
          },
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'legoAddr',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultActionDataWithFrozenStatus',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_signer',
        type: 'address',
      },
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'vaultRegistry',
            type: 'address',
          },
          {
            name: 'vaultAsset',
            type: 'address',
          },
          {
            name: 'signer',
            type: 'address',
          },
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'legoAddr',
            type: 'address',
          },
        ],
      },
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLegoDataFromVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLegoAddrFromVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getDepositConfig',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getDepositConfig',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_user',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canUserDeposit',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canUserDeposit',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_user',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'vaultConfigs',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'canDeposit',
            type: 'bool',
          },
          {
            name: 'canWithdraw',
            type: 'bool',
          },
          {
            name: 'maxDepositAmount',
            type: 'uint256',
          },
          {
            name: 'isVaultOpsFrozen',
            type: 'bool',
          },
          {
            name: 'redemptionBuffer',
            type: 'uint256',
          },
          {
            name: 'minYieldWithdrawAmount',
            type: 'uint256',
          },
          {
            name: 'performanceFee',
            type: 'uint256',
          },
          {
            name: 'shouldAutoDeposit',
            type: 'bool',
          },
          {
            name: 'defaultTargetVaultToken',
            type: 'address',
          },
          {
            name: 'isLeveragedVault',
            type: 'bool',
          },
          {
            name: 'shouldEnforceAllowlist',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isApprovedVaultToken',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'approvedVaultTokens',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'indexOfApprovedVaultToken',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numApprovedVaultTokens',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'assetVaultTokens',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'indexOfAssetVaultToken',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numAssetVaultTokens',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'assetVaultTokenRefCount',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isAllowed',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'constructor',
    inputs: [
      {
        name: '_undyHq',
        type: 'address',
      },
      {
        name: '_tempGov',
        type: 'address',
      },
      {
        name: '_minRegistryTimeLock',
        type: 'uint256',
      },
      {
        name: '_maxRegistryTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
] as const

export const deployAddress: Address | undefined = '0x1C17ef5Ef2AefcEE958E7e3dC345e96aBfF4e3Cf'

export type Contract = {
  calls: {
    getUndyHqFromGov: () => Promise<`0x${string}`>
    canGovern: (addr: `0x${string}`) => Promise<boolean>
    getGovernors: () => Promise<`0x${string}`[]>
    hasPendingGovChange: () => Promise<boolean>
    isValidGovTimeLock: (newTimeLock: bigint) => Promise<boolean>
    minGovChangeTimeLock: () => Promise<bigint>
    maxGovChangeTimeLock: () => Promise<bigint>
    governance: () => Promise<`0x${string}`>
    pendingGov: () => Promise<{ newGov: `0x${string}`; initiatedBlock: bigint; confirmBlock: bigint }>
    numGovChanges: () => Promise<bigint>
    govChangeTimeLock: () => Promise<bigint>
    getRegistryDescription: () => Promise<string>
    isValidNewAddress: (addr: `0x${string}`) => Promise<boolean>
    isValidAddressUpdate: (regId: bigint, newAddr: `0x${string}`) => Promise<boolean>
    isValidAddressDisable: (regId: bigint) => Promise<boolean>
    isValidRegistryTimeLock: (numBlocks: bigint) => Promise<boolean>
    minRegistryTimeLock: () => Promise<bigint>
    maxRegistryTimeLock: () => Promise<bigint>
    isValidAddr: (addr: `0x${string}`) => Promise<boolean>
    isValidRegId: (regId: bigint) => Promise<boolean>
    getRegId: (addr: `0x${string}`) => Promise<bigint>
    getAddr: (regId: bigint) => Promise<`0x${string}`>
    getAddrInfo: (
      regId: bigint,
    ) => Promise<{ addr: `0x${string}`; version: bigint; lastModified: bigint; description: string }>
    getAddrDescription: (regId: bigint) => Promise<string>
    getNumAddrs: () => Promise<bigint>
    getLastAddr: () => Promise<`0x${string}`>
    getLastRegId: () => Promise<bigint>
    registryChangeTimeLock: () => Promise<bigint>
    addrInfo: (
      arg0: bigint,
    ) => Promise<{ addr: `0x${string}`; version: bigint; lastModified: bigint; description: string }>
    addrToRegId: (arg0: `0x${string}`) => Promise<bigint>
    numAddrs: () => Promise<bigint>
    pendingNewAddr: (
      arg0: `0x${string}`,
    ) => Promise<{ description: string; initiatedBlock: bigint; confirmBlock: bigint }>
    pendingAddrUpdate: (
      arg0: bigint,
    ) => Promise<{ newAddr: `0x${string}`; initiatedBlock: bigint; confirmBlock: bigint }>
    pendingAddrDisable: (arg0: bigint) => Promise<{ initiatedBlock: bigint; confirmBlock: bigint }>
    getAddys: () => Promise<{
      hq: `0x${string}`
      undyToken: `0x${string}`
      ledger: `0x${string}`
      missionControl: `0x${string}`
      legoBook: `0x${string}`
      switchboard: `0x${string}`
      hatchery: `0x${string}`
      lootDistributor: `0x${string}`
      appraiser: `0x${string}`
      walletBackpack: `0x${string}`
      billing: `0x${string}`
      vaultRegistry: `0x${string}`
    }>
    getUndyHq: () => Promise<`0x${string}`>
    canMintUndy: () => Promise<boolean>
    isPaused: () => Promise<boolean>
    isEarnVault: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    isLeveragedVault: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    isBasicEarnVault: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    hasConfig: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    isValidDefaultTargetVaultToken: (undyVaultAddr: `0x${string}`, targetVaultToken: `0x${string}`) => Promise<boolean>
    isValidPerformanceFee: (performanceFee: bigint) => Promise<boolean>
    isValidRedemptionBuffer: (buffer: bigint) => Promise<boolean>
    getApprovedVaultTokens: (undyVaultAddr: `0x${string}`) => Promise<`0x${string}`[]>
    getAssetVaultTokens: (asset: `0x${string}`) => Promise<`0x${string}`[]>
    getNumApprovedVaultTokens: (undyVaultAddr: `0x${string}`) => Promise<bigint>
    getNumAssetVaultTokens: (asset: `0x${string}`) => Promise<bigint>
    isApprovedVaultTokenForAsset: (underlyingAsset: `0x${string}`, vaultToken: `0x${string}`) => Promise<boolean>
    canDeposit: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    canWithdraw: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    maxDepositAmount: (undyVaultAddr: `0x${string}`) => Promise<bigint>
    isVaultOpsFrozen: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    redemptionBuffer: (undyVaultAddr: `0x${string}`) => Promise<bigint>
    minYieldWithdrawAmount: (undyVaultAddr: `0x${string}`) => Promise<bigint>
    redemptionConfig: (undyVaultAddr: `0x${string}`) => Promise<[bigint, bigint]>
    getPerformanceFee: (undyVaultAddr: `0x${string}`) => Promise<bigint>
    getDefaultTargetVaultToken: (undyVaultAddr: `0x${string}`) => Promise<`0x${string}`>
    shouldAutoDeposit: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    shouldEnforceAllowlist: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    isUserAllowed: (undyVaultAddr: `0x${string}`, userAddr: `0x${string}`) => Promise<boolean>
    isApprovedVaultTokenByAddr: (undyVaultAddr: `0x${string}`, vaultToken: `0x${string}`) => Promise<boolean>
    checkVaultApprovals: (undyVaultAddr: `0x${string}`, vaultToken: `0x${string}`) => Promise<boolean>
    getVaultConfig: (
      regId: bigint,
    ) => Promise<{
      canDeposit: boolean
      canWithdraw: boolean
      maxDepositAmount: bigint
      isVaultOpsFrozen: boolean
      redemptionBuffer: bigint
      minYieldWithdrawAmount: bigint
      performanceFee: bigint
      shouldAutoDeposit: boolean
      defaultTargetVaultToken: `0x${string}`
      isLeveragedVault: boolean
      shouldEnforceAllowlist: boolean
    }>
    getVaultConfigByAddr: (
      undyVaultAddr: `0x${string}`,
    ) => Promise<{
      canDeposit: boolean
      canWithdraw: boolean
      maxDepositAmount: bigint
      isVaultOpsFrozen: boolean
      redemptionBuffer: bigint
      minYieldWithdrawAmount: bigint
      performanceFee: bigint
      shouldAutoDeposit: boolean
      defaultTargetVaultToken: `0x${string}`
      isLeveragedVault: boolean
      shouldEnforceAllowlist: boolean
    }>
    getVaultActionDataBundle: (
      legoId: bigint,
      signer: `0x${string}`,
    ) => Promise<{
      ledger: `0x${string}`
      missionControl: `0x${string}`
      legoBook: `0x${string}`
      appraiser: `0x${string}`
      vaultRegistry: `0x${string}`
      vaultAsset: `0x${string}`
      signer: `0x${string}`
      legoId: bigint
      legoAddr: `0x${string}`
    }>
    getVaultActionDataWithFrozenStatus: (
      legoId: bigint,
      signer: `0x${string}`,
      undyVaultAddr: `0x${string}`,
    ) => Promise<
      [
        {
          ledger: `0x${string}`
          missionControl: `0x${string}`
          legoBook: `0x${string}`
          appraiser: `0x${string}`
          vaultRegistry: `0x${string}`
          vaultAsset: `0x${string}`
          signer: `0x${string}`
          legoId: bigint
          legoAddr: `0x${string}`
        },
        boolean,
      ]
    >
    getLegoDataFromVaultToken: (vaultToken: `0x${string}`) => Promise<[bigint, `0x${string}`]>
    getLegoAddrFromVaultToken: (vaultToken: `0x${string}`) => Promise<`0x${string}`>
    getDepositConfig: (
      undyVaultAddr: `0x${string}`,
      user?: `0x${string}`,
    ) => Promise<[boolean, bigint, boolean, `0x${string}`]>
    canUserDeposit: (undyVaultAddr: `0x${string}`, user?: `0x${string}`) => Promise<boolean>
    vaultConfigs: (
      arg0: `0x${string}`,
    ) => Promise<{
      canDeposit: boolean
      canWithdraw: boolean
      maxDepositAmount: bigint
      isVaultOpsFrozen: boolean
      redemptionBuffer: bigint
      minYieldWithdrawAmount: bigint
      performanceFee: bigint
      shouldAutoDeposit: boolean
      defaultTargetVaultToken: `0x${string}`
      isLeveragedVault: boolean
      shouldEnforceAllowlist: boolean
    }>
    isApprovedVaultToken: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<boolean>
    approvedVaultTokens: (arg0: `0x${string}`, arg1: bigint) => Promise<`0x${string}`>
    indexOfApprovedVaultToken: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<bigint>
    numApprovedVaultTokens: (arg0: `0x${string}`) => Promise<bigint>
    assetVaultTokens: (arg0: `0x${string}`, arg1: bigint) => Promise<`0x${string}`>
    indexOfAssetVaultToken: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<bigint>
    numAssetVaultTokens: (arg0: `0x${string}`) => Promise<bigint>
    assetVaultTokenRefCount: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<bigint>
    isAllowed: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<boolean>
  }
  mutations: {
    startGovernanceChange: (newGov: `0x${string}`) => Promise<void>
    confirmGovernanceChange: () => Promise<void>
    cancelGovernanceChange: () => Promise<void>
    relinquishGov: () => Promise<void>
    setGovTimeLock: (numBlocks: bigint) => Promise<boolean>
    finishUndyHqSetup: (newGov: `0x${string}`, timeLock?: bigint) => Promise<boolean>
    setRegistryTimeLock: (numBlocks: bigint) => Promise<boolean>
    setRegistryTimeLockAfterSetup: (numBlocks?: bigint) => Promise<boolean>
    pause: (shouldPause: boolean) => Promise<void>
    recoverFunds: (recipient: `0x${string}`, asset: `0x${string}`) => Promise<void>
    recoverFundsMany: (recipient: `0x${string}`, assets: `0x${string}`[]) => Promise<void>
    startAddNewAddressToRegistry: (undyVaultAddr: `0x${string}`, description: string) => Promise<boolean>
    confirmNewAddressToRegistry: (
      undyVaultAddr: `0x${string}`,
      isLeveragedVault?: boolean,
      shouldEnforceAllowlist?: boolean,
      approvedVaultTokens?: `0x${string}`[],
      maxDepositAmount?: bigint,
      minYieldWithdrawAmount?: bigint,
      performanceFee?: bigint,
      defaultTargetVaultToken?: `0x${string}`,
      shouldAutoDeposit?: boolean,
      canDeposit?: boolean,
      canWithdraw?: boolean,
      isVaultOpsFrozen?: boolean,
      redemptionBuffer?: bigint,
    ) => Promise<bigint>
    cancelNewAddressToRegistry: (undyVaultAddr: `0x${string}`) => Promise<boolean>
    startAddressDisableInRegistry: (regId: bigint) => Promise<boolean>
    confirmAddressDisableInRegistry: (regId: bigint) => Promise<boolean>
    cancelAddressDisableInRegistry: (regId: bigint) => Promise<boolean>
    setCanDeposit: (undyVaultAddr: `0x${string}`, canDeposit: boolean) => Promise<void>
    setCanWithdraw: (undyVaultAddr: `0x${string}`, canWithdraw: boolean) => Promise<void>
    setMaxDepositAmount: (undyVaultAddr: `0x${string}`, maxDepositAmount: bigint) => Promise<void>
    setVaultOpsFrozen: (undyVaultAddr: `0x${string}`, isFrozen: boolean) => Promise<void>
    setShouldAutoDeposit: (undyVaultAddr: `0x${string}`, shouldAutoDeposit: boolean) => Promise<void>
    setMinYieldWithdrawAmount: (undyVaultAddr: `0x${string}`, amount: bigint) => Promise<void>
    setIsLeveragedVault: (undyVaultAddr: `0x${string}`, isLeveragedVault: boolean) => Promise<void>
    setShouldEnforceAllowlist: (undyVaultAddr: `0x${string}`, shouldEnforce: boolean) => Promise<void>
    setAllowed: (undyVaultAddr: `0x${string}`, user: `0x${string}`, isAllowed: boolean) => Promise<void>
    setAllowedBatch: (undyVaultAddr: `0x${string}`, users: `0x${string}`[], isAllowed: boolean) => Promise<void>
    setDefaultTargetVaultToken: (undyVaultAddr: `0x${string}`, targetVaultToken: `0x${string}`) => Promise<void>
    setPerformanceFee: (undyVaultAddr: `0x${string}`, performanceFee: bigint) => Promise<void>
    setRedemptionBuffer: (undyVaultAddr: `0x${string}`, buffer: bigint) => Promise<void>
    setApprovedVaultToken: (
      undyVaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      isApproved: boolean,
      shouldMaxWithdraw: boolean,
    ) => Promise<void>
    setApprovedVaultTokens: (
      undyVaultAddr: `0x${string}`,
      vaultTokens: `0x${string}`[],
      isApproved: boolean,
      shouldMaxWithdraw: boolean,
    ) => Promise<void>
  }
  events: {
    CanDepositSet: (vaultAddr: `0x${string}`, canDeposit: boolean) => Promise<void>
    CanWithdrawSet: (vaultAddr: `0x${string}`, canWithdraw: boolean) => Promise<void>
    MaxDepositAmountSet: (vaultAddr: `0x${string}`, maxDepositAmount: bigint) => Promise<void>
    VaultOpsFrozenSet: (vaultAddr: `0x${string}`, isFrozen: boolean) => Promise<void>
    RedemptionBufferSet: (vaultAddr: `0x${string}`, buffer: bigint) => Promise<void>
    MinYieldWithdrawAmountSet: (vaultAddr: `0x${string}`, amount: bigint) => Promise<void>
    PerformanceFeeSet: (vaultAddr: `0x${string}`, performanceFee: bigint) => Promise<void>
    DefaultTargetVaultTokenSet: (vaultAddr: `0x${string}`, targetVaultToken: `0x${string}`) => Promise<void>
    ShouldAutoDepositSet: (vaultAddr: `0x${string}`, shouldAutoDeposit: boolean) => Promise<void>
    IsLeveragedVaultSet: (vaultAddr: `0x${string}`, isLeveragedVault: boolean) => Promise<void>
    ApprovedVaultTokenSet: (
      undyVaultAddr: `0x${string}`,
      underlyingAsset: `0x${string}`,
      vaultToken: `0x${string}`,
      isApproved: boolean,
      shouldMaxWithdraw: boolean,
    ) => Promise<void>
    VaultTokenAdded: (
      undyVaultAddr: `0x${string}`,
      underlyingAsset: `0x${string}`,
      vaultToken: `0x${string}`,
    ) => Promise<void>
    VaultTokenRemoved: (
      undyVaultAddr: `0x${string}`,
      underlyingAsset: `0x${string}`,
      vaultToken: `0x${string}`,
    ) => Promise<void>
    AssetVaultTokenAdded: (asset: `0x${string}`, vaultToken: `0x${string}`) => Promise<void>
    AssetVaultTokenRemoved: (asset: `0x${string}`, vaultToken: `0x${string}`) => Promise<void>
    ShouldEnforceAllowlistSet: (undyVault: `0x${string}`, shouldEnforce: boolean) => Promise<void>
    AllowlistSet: (undyVault: `0x${string}`, user: `0x${string}`, isAllowed: boolean) => Promise<void>
    GovChangeTimeLockModified: (prevTimeLock: bigint, newTimeLock: bigint) => Promise<void>
    RegistryTimeLockModified: (newTimeLock: bigint, prevTimeLock: bigint, registry: string) => Promise<void>
    GovChangeStarted: (prevGov: `0x${string}`, newGov: `0x${string}`, confirmBlock: bigint) => Promise<void>
    GovChangeConfirmed: (
      prevGov: `0x${string}`,
      newGov: `0x${string}`,
      initiatedBlock: bigint,
      confirmBlock: bigint,
    ) => Promise<void>
    GovChangeCancelled: (cancelledGov: `0x${string}`, initiatedBlock: bigint, confirmBlock: bigint) => Promise<void>
    GovRelinquished: (prevGov: `0x${string}`) => Promise<void>
    UndyHqSetupFinished: (prevGov: `0x${string}`, newGov: `0x${string}`, timeLock: bigint) => Promise<void>
    DepartmentPauseModified: (isPaused: boolean) => Promise<void>
    DepartmentFundsRecovered: (asset: `0x${string}`, recipient: `0x${string}`, balance: bigint) => Promise<void>
    NewAddressPending: (
      addr: `0x${string}`,
      description: string,
      confirmBlock: bigint,
      registry: string,
    ) => Promise<void>
    NewAddressConfirmed: (addr: `0x${string}`, regId: bigint, description: string, registry: string) => Promise<void>
    NewAddressCancelled: (
      description: string,
      addr: `0x${string}`,
      initiatedBlock: bigint,
      confirmBlock: bigint,
      registry: string,
    ) => Promise<void>
    AddressDisablePending: (
      regId: bigint,
      description: string,
      addr: `0x${string}`,
      version: bigint,
      confirmBlock: bigint,
      registry: string,
    ) => Promise<void>
    AddressDisableConfirmed: (
      regId: bigint,
      description: string,
      addr: `0x${string}`,
      version: bigint,
      registry: string,
    ) => Promise<void>
    AddressDisableCancelled: (
      regId: bigint,
      description: string,
      addr: `0x${string}`,
      initiatedBlock: bigint,
      confirmBlock: bigint,
      registry: string,
    ) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'VaultRegistry'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'VaultRegistry' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  getUndyHqFromGov: (...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>) =>
    getRequest('getUndyHqFromGov', args),
  canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) => getRequest('canGovern', args),
  getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) => getRequest('getGovernors', args),
  hasPendingGovChange: (...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>) =>
    getRequest('hasPendingGovChange', args),
  isValidGovTimeLock: (...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>) =>
    getRequest('isValidGovTimeLock', args),
  minGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>) =>
    getRequest('minGovChangeTimeLock', args),
  maxGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>) =>
    getRequest('maxGovChangeTimeLock', args),
  governance: (...args: ExtractArgs<Contract['calls']['governance']>) => getRequest('governance', args),
  pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) => getRequest('pendingGov', args),
  numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) => getRequest('numGovChanges', args),
  govChangeTimeLock: (...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>) =>
    getRequest('govChangeTimeLock', args),
  getRegistryDescription: (...args: ExtractArgs<Contract['calls']['getRegistryDescription']>) =>
    getRequest('getRegistryDescription', args),
  isValidNewAddress: (...args: ExtractArgs<Contract['calls']['isValidNewAddress']>) =>
    getRequest('isValidNewAddress', args),
  isValidAddressUpdate: (...args: ExtractArgs<Contract['calls']['isValidAddressUpdate']>) =>
    getRequest('isValidAddressUpdate', args),
  isValidAddressDisable: (...args: ExtractArgs<Contract['calls']['isValidAddressDisable']>) =>
    getRequest('isValidAddressDisable', args),
  isValidRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['isValidRegistryTimeLock']>) =>
    getRequest('isValidRegistryTimeLock', args),
  minRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['minRegistryTimeLock']>) =>
    getRequest('minRegistryTimeLock', args),
  maxRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['maxRegistryTimeLock']>) =>
    getRequest('maxRegistryTimeLock', args),
  isValidAddr: (...args: ExtractArgs<Contract['calls']['isValidAddr']>) => getRequest('isValidAddr', args),
  isValidRegId: (...args: ExtractArgs<Contract['calls']['isValidRegId']>) => getRequest('isValidRegId', args),
  getRegId: (...args: ExtractArgs<Contract['calls']['getRegId']>) => getRequest('getRegId', args),
  getAddr: (...args: ExtractArgs<Contract['calls']['getAddr']>) => getRequest('getAddr', args),
  getAddrInfo: (...args: ExtractArgs<Contract['calls']['getAddrInfo']>) => getRequest('getAddrInfo', args),
  getAddrDescription: (...args: ExtractArgs<Contract['calls']['getAddrDescription']>) =>
    getRequest('getAddrDescription', args),
  getNumAddrs: (...args: ExtractArgs<Contract['calls']['getNumAddrs']>) => getRequest('getNumAddrs', args),
  getLastAddr: (...args: ExtractArgs<Contract['calls']['getLastAddr']>) => getRequest('getLastAddr', args),
  getLastRegId: (...args: ExtractArgs<Contract['calls']['getLastRegId']>) => getRequest('getLastRegId', args),
  registryChangeTimeLock: (...args: ExtractArgs<Contract['calls']['registryChangeTimeLock']>) =>
    getRequest('registryChangeTimeLock', args),
  addrInfo: (...args: ExtractArgs<Contract['calls']['addrInfo']>) => getRequest('addrInfo', args),
  addrToRegId: (...args: ExtractArgs<Contract['calls']['addrToRegId']>) => getRequest('addrToRegId', args),
  numAddrs: (...args: ExtractArgs<Contract['calls']['numAddrs']>) => getRequest('numAddrs', args),
  pendingNewAddr: (...args: ExtractArgs<Contract['calls']['pendingNewAddr']>) => getRequest('pendingNewAddr', args),
  pendingAddrUpdate: (...args: ExtractArgs<Contract['calls']['pendingAddrUpdate']>) =>
    getRequest('pendingAddrUpdate', args),
  pendingAddrDisable: (...args: ExtractArgs<Contract['calls']['pendingAddrDisable']>) =>
    getRequest('pendingAddrDisable', args),
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => getRequest('getAddys', args),
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => getRequest('getUndyHq', args),
  canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) => getRequest('canMintUndy', args),
  isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) => getRequest('isPaused', args),
  isEarnVault: (...args: ExtractArgs<Contract['calls']['isEarnVault']>) => getRequest('isEarnVault', args),
  isLeveragedVault: (...args: ExtractArgs<Contract['calls']['isLeveragedVault']>) =>
    getRequest('isLeveragedVault', args),
  isBasicEarnVault: (...args: ExtractArgs<Contract['calls']['isBasicEarnVault']>) =>
    getRequest('isBasicEarnVault', args),
  hasConfig: (...args: ExtractArgs<Contract['calls']['hasConfig']>) => getRequest('hasConfig', args),
  isValidDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['isValidDefaultTargetVaultToken']>) =>
    getRequest('isValidDefaultTargetVaultToken', args),
  isValidPerformanceFee: (...args: ExtractArgs<Contract['calls']['isValidPerformanceFee']>) =>
    getRequest('isValidPerformanceFee', args),
  isValidRedemptionBuffer: (...args: ExtractArgs<Contract['calls']['isValidRedemptionBuffer']>) =>
    getRequest('isValidRedemptionBuffer', args),
  getApprovedVaultTokens: (...args: ExtractArgs<Contract['calls']['getApprovedVaultTokens']>) =>
    getRequest('getApprovedVaultTokens', args),
  getAssetVaultTokens: (...args: ExtractArgs<Contract['calls']['getAssetVaultTokens']>) =>
    getRequest('getAssetVaultTokens', args),
  getNumApprovedVaultTokens: (...args: ExtractArgs<Contract['calls']['getNumApprovedVaultTokens']>) =>
    getRequest('getNumApprovedVaultTokens', args),
  getNumAssetVaultTokens: (...args: ExtractArgs<Contract['calls']['getNumAssetVaultTokens']>) =>
    getRequest('getNumAssetVaultTokens', args),
  isApprovedVaultTokenForAsset: (...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenForAsset']>) =>
    getRequest('isApprovedVaultTokenForAsset', args),
  canDeposit: (...args: ExtractArgs<Contract['calls']['canDeposit']>) => getRequest('canDeposit', args),
  canWithdraw: (...args: ExtractArgs<Contract['calls']['canWithdraw']>) => getRequest('canWithdraw', args),
  maxDepositAmount: (...args: ExtractArgs<Contract['calls']['maxDepositAmount']>) =>
    getRequest('maxDepositAmount', args),
  isVaultOpsFrozen: (...args: ExtractArgs<Contract['calls']['isVaultOpsFrozen']>) =>
    getRequest('isVaultOpsFrozen', args),
  redemptionBuffer: (...args: ExtractArgs<Contract['calls']['redemptionBuffer']>) =>
    getRequest('redemptionBuffer', args),
  minYieldWithdrawAmount: (...args: ExtractArgs<Contract['calls']['minYieldWithdrawAmount']>) =>
    getRequest('minYieldWithdrawAmount', args),
  redemptionConfig: (...args: ExtractArgs<Contract['calls']['redemptionConfig']>) =>
    getRequest('redemptionConfig', args),
  getPerformanceFee: (...args: ExtractArgs<Contract['calls']['getPerformanceFee']>) =>
    getRequest('getPerformanceFee', args),
  getDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['getDefaultTargetVaultToken']>) =>
    getRequest('getDefaultTargetVaultToken', args),
  shouldAutoDeposit: (...args: ExtractArgs<Contract['calls']['shouldAutoDeposit']>) =>
    getRequest('shouldAutoDeposit', args),
  shouldEnforceAllowlist: (...args: ExtractArgs<Contract['calls']['shouldEnforceAllowlist']>) =>
    getRequest('shouldEnforceAllowlist', args),
  isUserAllowed: (...args: ExtractArgs<Contract['calls']['isUserAllowed']>) => getRequest('isUserAllowed', args),
  isApprovedVaultTokenByAddr: (...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenByAddr']>) =>
    getRequest('isApprovedVaultTokenByAddr', args),
  checkVaultApprovals: (...args: ExtractArgs<Contract['calls']['checkVaultApprovals']>) =>
    getRequest('checkVaultApprovals', args),
  getVaultConfig: (...args: ExtractArgs<Contract['calls']['getVaultConfig']>) => getRequest('getVaultConfig', args),
  getVaultConfigByAddr: (...args: ExtractArgs<Contract['calls']['getVaultConfigByAddr']>) =>
    getRequest('getVaultConfigByAddr', args),
  getVaultActionDataBundle: (...args: ExtractArgs<Contract['calls']['getVaultActionDataBundle']>) =>
    getRequest('getVaultActionDataBundle', args),
  getVaultActionDataWithFrozenStatus: (...args: ExtractArgs<Contract['calls']['getVaultActionDataWithFrozenStatus']>) =>
    getRequest('getVaultActionDataWithFrozenStatus', args),
  getLegoDataFromVaultToken: (...args: ExtractArgs<Contract['calls']['getLegoDataFromVaultToken']>) =>
    getRequest('getLegoDataFromVaultToken', args),
  getLegoAddrFromVaultToken: (...args: ExtractArgs<Contract['calls']['getLegoAddrFromVaultToken']>) =>
    getRequest('getLegoAddrFromVaultToken', args),
  getDepositConfig: (...args: ExtractArgs<Contract['calls']['getDepositConfig']>) =>
    getRequest('getDepositConfig', args),
  canUserDeposit: (...args: ExtractArgs<Contract['calls']['canUserDeposit']>) => getRequest('canUserDeposit', args),
  vaultConfigs: (...args: ExtractArgs<Contract['calls']['vaultConfigs']>) => getRequest('vaultConfigs', args),
  isApprovedVaultToken: (...args: ExtractArgs<Contract['calls']['isApprovedVaultToken']>) =>
    getRequest('isApprovedVaultToken', args),
  approvedVaultTokens: (...args: ExtractArgs<Contract['calls']['approvedVaultTokens']>) =>
    getRequest('approvedVaultTokens', args),
  indexOfApprovedVaultToken: (...args: ExtractArgs<Contract['calls']['indexOfApprovedVaultToken']>) =>
    getRequest('indexOfApprovedVaultToken', args),
  numApprovedVaultTokens: (...args: ExtractArgs<Contract['calls']['numApprovedVaultTokens']>) =>
    getRequest('numApprovedVaultTokens', args),
  assetVaultTokens: (...args: ExtractArgs<Contract['calls']['assetVaultTokens']>) =>
    getRequest('assetVaultTokens', args),
  indexOfAssetVaultToken: (...args: ExtractArgs<Contract['calls']['indexOfAssetVaultToken']>) =>
    getRequest('indexOfAssetVaultToken', args),
  numAssetVaultTokens: (...args: ExtractArgs<Contract['calls']['numAssetVaultTokens']>) =>
    getRequest('numAssetVaultTokens', args),
  assetVaultTokenRefCount: (...args: ExtractArgs<Contract['calls']['assetVaultTokenRefCount']>) =>
    getRequest('assetVaultTokenRefCount', args),
  isAllowed: (...args: ExtractArgs<Contract['calls']['isAllowed']>) => getRequest('isAllowed', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'VaultRegistry' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'VaultRegistry'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  startGovernanceChange: getMutation('startGovernanceChange'),
  confirmGovernanceChange: getMutation('confirmGovernanceChange'),
  cancelGovernanceChange: getMutation('cancelGovernanceChange'),
  relinquishGov: getMutation('relinquishGov'),
  setGovTimeLock: getMutation('setGovTimeLock'),
  finishUndyHqSetup: getMutation('finishUndyHqSetup'),
  setRegistryTimeLock: getMutation('setRegistryTimeLock'),
  setRegistryTimeLockAfterSetup: getMutation('setRegistryTimeLockAfterSetup'),
  pause: getMutation('pause'),
  recoverFunds: getMutation('recoverFunds'),
  recoverFundsMany: getMutation('recoverFundsMany'),
  startAddNewAddressToRegistry: getMutation('startAddNewAddressToRegistry'),
  confirmNewAddressToRegistry: getMutation('confirmNewAddressToRegistry'),
  cancelNewAddressToRegistry: getMutation('cancelNewAddressToRegistry'),
  startAddressDisableInRegistry: getMutation('startAddressDisableInRegistry'),
  confirmAddressDisableInRegistry: getMutation('confirmAddressDisableInRegistry'),
  cancelAddressDisableInRegistry: getMutation('cancelAddressDisableInRegistry'),
  setCanDeposit: getMutation('setCanDeposit'),
  setCanWithdraw: getMutation('setCanWithdraw'),
  setMaxDepositAmount: getMutation('setMaxDepositAmount'),
  setVaultOpsFrozen: getMutation('setVaultOpsFrozen'),
  setShouldAutoDeposit: getMutation('setShouldAutoDeposit'),
  setMinYieldWithdrawAmount: getMutation('setMinYieldWithdrawAmount'),
  setIsLeveragedVault: getMutation('setIsLeveragedVault'),
  setShouldEnforceAllowlist: getMutation('setShouldEnforceAllowlist'),
  setAllowed: getMutation('setAllowed'),
  setAllowedBatch: getMutation('setAllowedBatch'),
  setDefaultTargetVaultToken: getMutation('setDefaultTargetVaultToken'),
  setPerformanceFee: getMutation('setPerformanceFee'),
  setRedemptionBuffer: getMutation('setRedemptionBuffer'),
  setApprovedVaultToken: getMutation('setApprovedVaultToken'),
  setApprovedVaultTokens: getMutation('setApprovedVaultTokens'),
}

export type ParsedEvent<T extends keyof Contract['events']> = {
  event: RpcLog | Log
  parsed: ParseEventLogsReturnType<typeof abi, T>
}

export function parseEvents<T extends keyof Contract['events']>(
  eventName: T,
  events: (RpcLog | Log)[],
): ParsedEvent<T>[] {
  return events.map((event) => {
    return {
      event,
      parsed: parseEventLogs({
        abi,
        eventName,
        logs: [event],
      }),
    }
  })
}

export function getEventTopic<T extends keyof Contract['events']>(eventName: T): Address {
  return encodeEventTopics({ abi, eventName })[0] as Address
}

export type SDK = {
  deployAddress: Address | undefined
  abi: typeof abi
  events: {
    CanDepositSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'CanDepositSet'>[] }
    CanWithdrawSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'CanWithdrawSet'>[] }
    MaxDepositAmountSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'MaxDepositAmountSet'>[] }
    VaultOpsFrozenSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'VaultOpsFrozenSet'>[] }
    RedemptionBufferSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'RedemptionBufferSet'>[] }
    MinYieldWithdrawAmountSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'MinYieldWithdrawAmountSet'>[]
    }
    PerformanceFeeSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PerformanceFeeSet'>[] }
    DefaultTargetVaultTokenSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'DefaultTargetVaultTokenSet'>[]
    }
    ShouldAutoDepositSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ShouldAutoDepositSet'>[] }
    IsLeveragedVaultSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'IsLeveragedVaultSet'>[] }
    ApprovedVaultTokenSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ApprovedVaultTokenSet'>[]
    }
    VaultTokenAdded: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'VaultTokenAdded'>[] }
    VaultTokenRemoved: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'VaultTokenRemoved'>[] }
    AssetVaultTokenAdded: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AssetVaultTokenAdded'>[] }
    AssetVaultTokenRemoved: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AssetVaultTokenRemoved'>[]
    }
    ShouldEnforceAllowlistSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ShouldEnforceAllowlistSet'>[]
    }
    AllowlistSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AllowlistSet'>[] }
    GovChangeTimeLockModified: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovChangeTimeLockModified'>[]
    }
    RegistryTimeLockModified: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'RegistryTimeLockModified'>[]
    }
    GovChangeStarted: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovChangeStarted'>[] }
    GovChangeConfirmed: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovChangeConfirmed'>[] }
    GovChangeCancelled: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovChangeCancelled'>[] }
    GovRelinquished: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovRelinquished'>[] }
    UndyHqSetupFinished: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'UndyHqSetupFinished'>[] }
    DepartmentPauseModified: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'DepartmentPauseModified'>[]
    }
    DepartmentFundsRecovered: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'DepartmentFundsRecovered'>[]
    }
    NewAddressPending: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'NewAddressPending'>[] }
    NewAddressConfirmed: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'NewAddressConfirmed'>[] }
    NewAddressCancelled: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'NewAddressCancelled'>[] }
    AddressDisablePending: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AddressDisablePending'>[]
    }
    AddressDisableConfirmed: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AddressDisableConfirmed'>[]
    }
    AddressDisableCancelled: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AddressDisableCancelled'>[]
    }
  }
  getUndyHqFromGov: (
    ...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>
  ) => Promise<CallReturn<'getUndyHqFromGov'>>
  canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) => Promise<CallReturn<'canGovern'>>
  getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) => Promise<CallReturn<'getGovernors'>>
  hasPendingGovChange: (
    ...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>
  ) => Promise<CallReturn<'hasPendingGovChange'>>
  isValidGovTimeLock: (
    ...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>
  ) => Promise<CallReturn<'isValidGovTimeLock'>>
  minGovChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>
  ) => Promise<CallReturn<'minGovChangeTimeLock'>>
  maxGovChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>
  ) => Promise<CallReturn<'maxGovChangeTimeLock'>>
  governance: (...args: ExtractArgs<Contract['calls']['governance']>) => Promise<CallReturn<'governance'>>
  pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) => Promise<CallReturn<'pendingGov'>>
  numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) => Promise<CallReturn<'numGovChanges'>>
  govChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>
  ) => Promise<CallReturn<'govChangeTimeLock'>>
  getRegistryDescription: (
    ...args: ExtractArgs<Contract['calls']['getRegistryDescription']>
  ) => Promise<CallReturn<'getRegistryDescription'>>
  isValidNewAddress: (
    ...args: ExtractArgs<Contract['calls']['isValidNewAddress']>
  ) => Promise<CallReturn<'isValidNewAddress'>>
  isValidAddressUpdate: (
    ...args: ExtractArgs<Contract['calls']['isValidAddressUpdate']>
  ) => Promise<CallReturn<'isValidAddressUpdate'>>
  isValidAddressDisable: (
    ...args: ExtractArgs<Contract['calls']['isValidAddressDisable']>
  ) => Promise<CallReturn<'isValidAddressDisable'>>
  isValidRegistryTimeLock: (
    ...args: ExtractArgs<Contract['calls']['isValidRegistryTimeLock']>
  ) => Promise<CallReturn<'isValidRegistryTimeLock'>>
  minRegistryTimeLock: (
    ...args: ExtractArgs<Contract['calls']['minRegistryTimeLock']>
  ) => Promise<CallReturn<'minRegistryTimeLock'>>
  maxRegistryTimeLock: (
    ...args: ExtractArgs<Contract['calls']['maxRegistryTimeLock']>
  ) => Promise<CallReturn<'maxRegistryTimeLock'>>
  isValidAddr: (...args: ExtractArgs<Contract['calls']['isValidAddr']>) => Promise<CallReturn<'isValidAddr'>>
  isValidRegId: (...args: ExtractArgs<Contract['calls']['isValidRegId']>) => Promise<CallReturn<'isValidRegId'>>
  getRegId: (...args: ExtractArgs<Contract['calls']['getRegId']>) => Promise<CallReturn<'getRegId'>>
  getAddr: (...args: ExtractArgs<Contract['calls']['getAddr']>) => Promise<CallReturn<'getAddr'>>
  getAddrInfo: (...args: ExtractArgs<Contract['calls']['getAddrInfo']>) => Promise<CallReturn<'getAddrInfo'>>
  getAddrDescription: (
    ...args: ExtractArgs<Contract['calls']['getAddrDescription']>
  ) => Promise<CallReturn<'getAddrDescription'>>
  getNumAddrs: (...args: ExtractArgs<Contract['calls']['getNumAddrs']>) => Promise<CallReturn<'getNumAddrs'>>
  getLastAddr: (...args: ExtractArgs<Contract['calls']['getLastAddr']>) => Promise<CallReturn<'getLastAddr'>>
  getLastRegId: (...args: ExtractArgs<Contract['calls']['getLastRegId']>) => Promise<CallReturn<'getLastRegId'>>
  registryChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['registryChangeTimeLock']>
  ) => Promise<CallReturn<'registryChangeTimeLock'>>
  addrInfo: (...args: ExtractArgs<Contract['calls']['addrInfo']>) => Promise<CallReturn<'addrInfo'>>
  addrToRegId: (...args: ExtractArgs<Contract['calls']['addrToRegId']>) => Promise<CallReturn<'addrToRegId'>>
  numAddrs: (...args: ExtractArgs<Contract['calls']['numAddrs']>) => Promise<CallReturn<'numAddrs'>>
  pendingNewAddr: (...args: ExtractArgs<Contract['calls']['pendingNewAddr']>) => Promise<CallReturn<'pendingNewAddr'>>
  pendingAddrUpdate: (
    ...args: ExtractArgs<Contract['calls']['pendingAddrUpdate']>
  ) => Promise<CallReturn<'pendingAddrUpdate'>>
  pendingAddrDisable: (
    ...args: ExtractArgs<Contract['calls']['pendingAddrDisable']>
  ) => Promise<CallReturn<'pendingAddrDisable'>>
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => Promise<CallReturn<'getAddys'>>
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => Promise<CallReturn<'getUndyHq'>>
  canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) => Promise<CallReturn<'canMintUndy'>>
  isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) => Promise<CallReturn<'isPaused'>>
  isEarnVault: (...args: ExtractArgs<Contract['calls']['isEarnVault']>) => Promise<CallReturn<'isEarnVault'>>
  isLeveragedVault: (
    ...args: ExtractArgs<Contract['calls']['isLeveragedVault']>
  ) => Promise<CallReturn<'isLeveragedVault'>>
  isBasicEarnVault: (
    ...args: ExtractArgs<Contract['calls']['isBasicEarnVault']>
  ) => Promise<CallReturn<'isBasicEarnVault'>>
  hasConfig: (...args: ExtractArgs<Contract['calls']['hasConfig']>) => Promise<CallReturn<'hasConfig'>>
  isValidDefaultTargetVaultToken: (
    ...args: ExtractArgs<Contract['calls']['isValidDefaultTargetVaultToken']>
  ) => Promise<CallReturn<'isValidDefaultTargetVaultToken'>>
  isValidPerformanceFee: (
    ...args: ExtractArgs<Contract['calls']['isValidPerformanceFee']>
  ) => Promise<CallReturn<'isValidPerformanceFee'>>
  isValidRedemptionBuffer: (
    ...args: ExtractArgs<Contract['calls']['isValidRedemptionBuffer']>
  ) => Promise<CallReturn<'isValidRedemptionBuffer'>>
  getApprovedVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['getApprovedVaultTokens']>
  ) => Promise<CallReturn<'getApprovedVaultTokens'>>
  getAssetVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['getAssetVaultTokens']>
  ) => Promise<CallReturn<'getAssetVaultTokens'>>
  getNumApprovedVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['getNumApprovedVaultTokens']>
  ) => Promise<CallReturn<'getNumApprovedVaultTokens'>>
  getNumAssetVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['getNumAssetVaultTokens']>
  ) => Promise<CallReturn<'getNumAssetVaultTokens'>>
  isApprovedVaultTokenForAsset: (
    ...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenForAsset']>
  ) => Promise<CallReturn<'isApprovedVaultTokenForAsset'>>
  canDeposit: (...args: ExtractArgs<Contract['calls']['canDeposit']>) => Promise<CallReturn<'canDeposit'>>
  canWithdraw: (...args: ExtractArgs<Contract['calls']['canWithdraw']>) => Promise<CallReturn<'canWithdraw'>>
  maxDepositAmount: (
    ...args: ExtractArgs<Contract['calls']['maxDepositAmount']>
  ) => Promise<CallReturn<'maxDepositAmount'>>
  isVaultOpsFrozen: (
    ...args: ExtractArgs<Contract['calls']['isVaultOpsFrozen']>
  ) => Promise<CallReturn<'isVaultOpsFrozen'>>
  redemptionBuffer: (
    ...args: ExtractArgs<Contract['calls']['redemptionBuffer']>
  ) => Promise<CallReturn<'redemptionBuffer'>>
  minYieldWithdrawAmount: (
    ...args: ExtractArgs<Contract['calls']['minYieldWithdrawAmount']>
  ) => Promise<CallReturn<'minYieldWithdrawAmount'>>
  redemptionConfig: (
    ...args: ExtractArgs<Contract['calls']['redemptionConfig']>
  ) => Promise<CallReturn<'redemptionConfig'>>
  getPerformanceFee: (
    ...args: ExtractArgs<Contract['calls']['getPerformanceFee']>
  ) => Promise<CallReturn<'getPerformanceFee'>>
  getDefaultTargetVaultToken: (
    ...args: ExtractArgs<Contract['calls']['getDefaultTargetVaultToken']>
  ) => Promise<CallReturn<'getDefaultTargetVaultToken'>>
  shouldAutoDeposit: (
    ...args: ExtractArgs<Contract['calls']['shouldAutoDeposit']>
  ) => Promise<CallReturn<'shouldAutoDeposit'>>
  shouldEnforceAllowlist: (
    ...args: ExtractArgs<Contract['calls']['shouldEnforceAllowlist']>
  ) => Promise<CallReturn<'shouldEnforceAllowlist'>>
  isUserAllowed: (...args: ExtractArgs<Contract['calls']['isUserAllowed']>) => Promise<CallReturn<'isUserAllowed'>>
  isApprovedVaultTokenByAddr: (
    ...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenByAddr']>
  ) => Promise<CallReturn<'isApprovedVaultTokenByAddr'>>
  checkVaultApprovals: (
    ...args: ExtractArgs<Contract['calls']['checkVaultApprovals']>
  ) => Promise<CallReturn<'checkVaultApprovals'>>
  getVaultConfig: (...args: ExtractArgs<Contract['calls']['getVaultConfig']>) => Promise<CallReturn<'getVaultConfig'>>
  getVaultConfigByAddr: (
    ...args: ExtractArgs<Contract['calls']['getVaultConfigByAddr']>
  ) => Promise<CallReturn<'getVaultConfigByAddr'>>
  getVaultActionDataBundle: (
    ...args: ExtractArgs<Contract['calls']['getVaultActionDataBundle']>
  ) => Promise<CallReturn<'getVaultActionDataBundle'>>
  getVaultActionDataWithFrozenStatus: (
    ...args: ExtractArgs<Contract['calls']['getVaultActionDataWithFrozenStatus']>
  ) => Promise<CallReturn<'getVaultActionDataWithFrozenStatus'>>
  getLegoDataFromVaultToken: (
    ...args: ExtractArgs<Contract['calls']['getLegoDataFromVaultToken']>
  ) => Promise<CallReturn<'getLegoDataFromVaultToken'>>
  getLegoAddrFromVaultToken: (
    ...args: ExtractArgs<Contract['calls']['getLegoAddrFromVaultToken']>
  ) => Promise<CallReturn<'getLegoAddrFromVaultToken'>>
  getDepositConfig: (
    ...args: ExtractArgs<Contract['calls']['getDepositConfig']>
  ) => Promise<CallReturn<'getDepositConfig'>>
  canUserDeposit: (...args: ExtractArgs<Contract['calls']['canUserDeposit']>) => Promise<CallReturn<'canUserDeposit'>>
  vaultConfigs: (...args: ExtractArgs<Contract['calls']['vaultConfigs']>) => Promise<CallReturn<'vaultConfigs'>>
  isApprovedVaultToken: (
    ...args: ExtractArgs<Contract['calls']['isApprovedVaultToken']>
  ) => Promise<CallReturn<'isApprovedVaultToken'>>
  approvedVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['approvedVaultTokens']>
  ) => Promise<CallReturn<'approvedVaultTokens'>>
  indexOfApprovedVaultToken: (
    ...args: ExtractArgs<Contract['calls']['indexOfApprovedVaultToken']>
  ) => Promise<CallReturn<'indexOfApprovedVaultToken'>>
  numApprovedVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['numApprovedVaultTokens']>
  ) => Promise<CallReturn<'numApprovedVaultTokens'>>
  assetVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['assetVaultTokens']>
  ) => Promise<CallReturn<'assetVaultTokens'>>
  indexOfAssetVaultToken: (
    ...args: ExtractArgs<Contract['calls']['indexOfAssetVaultToken']>
  ) => Promise<CallReturn<'indexOfAssetVaultToken'>>
  numAssetVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['numAssetVaultTokens']>
  ) => Promise<CallReturn<'numAssetVaultTokens'>>
  assetVaultTokenRefCount: (
    ...args: ExtractArgs<Contract['calls']['assetVaultTokenRefCount']>
  ) => Promise<CallReturn<'assetVaultTokenRefCount'>>
  isAllowed: (...args: ExtractArgs<Contract['calls']['isAllowed']>) => Promise<CallReturn<'isAllowed'>>
  startGovernanceChange: (...args: ExtractArgs<Contract['mutations']['startGovernanceChange']>) => Promise<Address>
  confirmGovernanceChange: (...args: ExtractArgs<Contract['mutations']['confirmGovernanceChange']>) => Promise<Address>
  cancelGovernanceChange: (...args: ExtractArgs<Contract['mutations']['cancelGovernanceChange']>) => Promise<Address>
  relinquishGov: (...args: ExtractArgs<Contract['mutations']['relinquishGov']>) => Promise<Address>
  setGovTimeLock: (...args: ExtractArgs<Contract['mutations']['setGovTimeLock']>) => Promise<Address>
  finishUndyHqSetup: (...args: ExtractArgs<Contract['mutations']['finishUndyHqSetup']>) => Promise<Address>
  setRegistryTimeLock: (...args: ExtractArgs<Contract['mutations']['setRegistryTimeLock']>) => Promise<Address>
  setRegistryTimeLockAfterSetup: (
    ...args: ExtractArgs<Contract['mutations']['setRegistryTimeLockAfterSetup']>
  ) => Promise<Address>
  pause: (...args: ExtractArgs<Contract['mutations']['pause']>) => Promise<Address>
  recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) => Promise<Address>
  recoverFundsMany: (...args: ExtractArgs<Contract['mutations']['recoverFundsMany']>) => Promise<Address>
  startAddNewAddressToRegistry: (
    ...args: ExtractArgs<Contract['mutations']['startAddNewAddressToRegistry']>
  ) => Promise<Address>
  confirmNewAddressToRegistry: (
    ...args: ExtractArgs<Contract['mutations']['confirmNewAddressToRegistry']>
  ) => Promise<Address>
  cancelNewAddressToRegistry: (
    ...args: ExtractArgs<Contract['mutations']['cancelNewAddressToRegistry']>
  ) => Promise<Address>
  startAddressDisableInRegistry: (
    ...args: ExtractArgs<Contract['mutations']['startAddressDisableInRegistry']>
  ) => Promise<Address>
  confirmAddressDisableInRegistry: (
    ...args: ExtractArgs<Contract['mutations']['confirmAddressDisableInRegistry']>
  ) => Promise<Address>
  cancelAddressDisableInRegistry: (
    ...args: ExtractArgs<Contract['mutations']['cancelAddressDisableInRegistry']>
  ) => Promise<Address>
  setCanDeposit: (...args: ExtractArgs<Contract['mutations']['setCanDeposit']>) => Promise<Address>
  setCanWithdraw: (...args: ExtractArgs<Contract['mutations']['setCanWithdraw']>) => Promise<Address>
  setMaxDepositAmount: (...args: ExtractArgs<Contract['mutations']['setMaxDepositAmount']>) => Promise<Address>
  setVaultOpsFrozen: (...args: ExtractArgs<Contract['mutations']['setVaultOpsFrozen']>) => Promise<Address>
  setShouldAutoDeposit: (...args: ExtractArgs<Contract['mutations']['setShouldAutoDeposit']>) => Promise<Address>
  setMinYieldWithdrawAmount: (
    ...args: ExtractArgs<Contract['mutations']['setMinYieldWithdrawAmount']>
  ) => Promise<Address>
  setIsLeveragedVault: (...args: ExtractArgs<Contract['mutations']['setIsLeveragedVault']>) => Promise<Address>
  setShouldEnforceAllowlist: (
    ...args: ExtractArgs<Contract['mutations']['setShouldEnforceAllowlist']>
  ) => Promise<Address>
  setAllowed: (...args: ExtractArgs<Contract['mutations']['setAllowed']>) => Promise<Address>
  setAllowedBatch: (...args: ExtractArgs<Contract['mutations']['setAllowedBatch']>) => Promise<Address>
  setDefaultTargetVaultToken: (
    ...args: ExtractArgs<Contract['mutations']['setDefaultTargetVaultToken']>
  ) => Promise<Address>
  setPerformanceFee: (...args: ExtractArgs<Contract['mutations']['setPerformanceFee']>) => Promise<Address>
  setRedemptionBuffer: (...args: ExtractArgs<Contract['mutations']['setRedemptionBuffer']>) => Promise<Address>
  setApprovedVaultToken: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultToken']>) => Promise<Address>
  setApprovedVaultTokens: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultTokens']>) => Promise<Address>
}

export function toSdk(
  publicClient?: PublicClient,
  walletClient?: WalletClient,
  addressResolver?: AddressResolverFunction,
): SDK {
  return {
    deployAddress,
    abi,

    events: {
      CanDepositSet: {
        topic: getEventTopic('CanDepositSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('CanDepositSet', events),
      },
      CanWithdrawSet: {
        topic: getEventTopic('CanWithdrawSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('CanWithdrawSet', events),
      },
      MaxDepositAmountSet: {
        topic: getEventTopic('MaxDepositAmountSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('MaxDepositAmountSet', events),
      },
      VaultOpsFrozenSet: {
        topic: getEventTopic('VaultOpsFrozenSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('VaultOpsFrozenSet', events),
      },
      RedemptionBufferSet: {
        topic: getEventTopic('RedemptionBufferSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('RedemptionBufferSet', events),
      },
      MinYieldWithdrawAmountSet: {
        topic: getEventTopic('MinYieldWithdrawAmountSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('MinYieldWithdrawAmountSet', events),
      },
      PerformanceFeeSet: {
        topic: getEventTopic('PerformanceFeeSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PerformanceFeeSet', events),
      },
      DefaultTargetVaultTokenSet: {
        topic: getEventTopic('DefaultTargetVaultTokenSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('DefaultTargetVaultTokenSet', events),
      },
      ShouldAutoDepositSet: {
        topic: getEventTopic('ShouldAutoDepositSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ShouldAutoDepositSet', events),
      },
      IsLeveragedVaultSet: {
        topic: getEventTopic('IsLeveragedVaultSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('IsLeveragedVaultSet', events),
      },
      ApprovedVaultTokenSet: {
        topic: getEventTopic('ApprovedVaultTokenSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ApprovedVaultTokenSet', events),
      },
      VaultTokenAdded: {
        topic: getEventTopic('VaultTokenAdded'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('VaultTokenAdded', events),
      },
      VaultTokenRemoved: {
        topic: getEventTopic('VaultTokenRemoved'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('VaultTokenRemoved', events),
      },
      AssetVaultTokenAdded: {
        topic: getEventTopic('AssetVaultTokenAdded'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AssetVaultTokenAdded', events),
      },
      AssetVaultTokenRemoved: {
        topic: getEventTopic('AssetVaultTokenRemoved'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AssetVaultTokenRemoved', events),
      },
      ShouldEnforceAllowlistSet: {
        topic: getEventTopic('ShouldEnforceAllowlistSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ShouldEnforceAllowlistSet', events),
      },
      AllowlistSet: {
        topic: getEventTopic('AllowlistSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AllowlistSet', events),
      },
      GovChangeTimeLockModified: {
        topic: getEventTopic('GovChangeTimeLockModified'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovChangeTimeLockModified', events),
      },
      RegistryTimeLockModified: {
        topic: getEventTopic('RegistryTimeLockModified'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('RegistryTimeLockModified', events),
      },
      GovChangeStarted: {
        topic: getEventTopic('GovChangeStarted'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovChangeStarted', events),
      },
      GovChangeConfirmed: {
        topic: getEventTopic('GovChangeConfirmed'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovChangeConfirmed', events),
      },
      GovChangeCancelled: {
        topic: getEventTopic('GovChangeCancelled'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovChangeCancelled', events),
      },
      GovRelinquished: {
        topic: getEventTopic('GovRelinquished'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovRelinquished', events),
      },
      UndyHqSetupFinished: {
        topic: getEventTopic('UndyHqSetupFinished'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('UndyHqSetupFinished', events),
      },
      DepartmentPauseModified: {
        topic: getEventTopic('DepartmentPauseModified'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('DepartmentPauseModified', events),
      },
      DepartmentFundsRecovered: {
        topic: getEventTopic('DepartmentFundsRecovered'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('DepartmentFundsRecovered', events),
      },
      NewAddressPending: {
        topic: getEventTopic('NewAddressPending'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('NewAddressPending', events),
      },
      NewAddressConfirmed: {
        topic: getEventTopic('NewAddressConfirmed'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('NewAddressConfirmed', events),
      },
      NewAddressCancelled: {
        topic: getEventTopic('NewAddressCancelled'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('NewAddressCancelled', events),
      },
      AddressDisablePending: {
        topic: getEventTopic('AddressDisablePending'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AddressDisablePending', events),
      },
      AddressDisableConfirmed: {
        topic: getEventTopic('AddressDisableConfirmed'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AddressDisableConfirmed', events),
      },
      AddressDisableCancelled: {
        topic: getEventTopic('AddressDisableCancelled'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AddressDisableCancelled', events),
      },
    },
    // Queries
    getUndyHqFromGov: (...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>) =>
      singleQuery(publicClient!, call.getUndyHqFromGov(...args), {}, addressResolver) as Promise<
        CallReturn<'getUndyHqFromGov'>
      >,
    canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) =>
      singleQuery(publicClient!, call.canGovern(...args), {}, addressResolver) as Promise<CallReturn<'canGovern'>>,
    getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) =>
      singleQuery(publicClient!, call.getGovernors(...args), {}, addressResolver) as Promise<
        CallReturn<'getGovernors'>
      >,
    hasPendingGovChange: (...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>) =>
      singleQuery(publicClient!, call.hasPendingGovChange(...args), {}, addressResolver) as Promise<
        CallReturn<'hasPendingGovChange'>
      >,
    isValidGovTimeLock: (...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>) =>
      singleQuery(publicClient!, call.isValidGovTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidGovTimeLock'>
      >,
    minGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>) =>
      singleQuery(publicClient!, call.minGovChangeTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'minGovChangeTimeLock'>
      >,
    maxGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>) =>
      singleQuery(publicClient!, call.maxGovChangeTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'maxGovChangeTimeLock'>
      >,
    governance: (...args: ExtractArgs<Contract['calls']['governance']>) =>
      singleQuery(publicClient!, call.governance(...args), {}, addressResolver) as Promise<CallReturn<'governance'>>,
    pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) =>
      singleQuery(publicClient!, call.pendingGov(...args), {}, addressResolver) as Promise<CallReturn<'pendingGov'>>,
    numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) =>
      singleQuery(publicClient!, call.numGovChanges(...args), {}, addressResolver) as Promise<
        CallReturn<'numGovChanges'>
      >,
    govChangeTimeLock: (...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>) =>
      singleQuery(publicClient!, call.govChangeTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'govChangeTimeLock'>
      >,
    getRegistryDescription: (...args: ExtractArgs<Contract['calls']['getRegistryDescription']>) =>
      singleQuery(publicClient!, call.getRegistryDescription(...args), {}, addressResolver) as Promise<
        CallReturn<'getRegistryDescription'>
      >,
    isValidNewAddress: (...args: ExtractArgs<Contract['calls']['isValidNewAddress']>) =>
      singleQuery(publicClient!, call.isValidNewAddress(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidNewAddress'>
      >,
    isValidAddressUpdate: (...args: ExtractArgs<Contract['calls']['isValidAddressUpdate']>) =>
      singleQuery(publicClient!, call.isValidAddressUpdate(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidAddressUpdate'>
      >,
    isValidAddressDisable: (...args: ExtractArgs<Contract['calls']['isValidAddressDisable']>) =>
      singleQuery(publicClient!, call.isValidAddressDisable(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidAddressDisable'>
      >,
    isValidRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['isValidRegistryTimeLock']>) =>
      singleQuery(publicClient!, call.isValidRegistryTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidRegistryTimeLock'>
      >,
    minRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['minRegistryTimeLock']>) =>
      singleQuery(publicClient!, call.minRegistryTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'minRegistryTimeLock'>
      >,
    maxRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['maxRegistryTimeLock']>) =>
      singleQuery(publicClient!, call.maxRegistryTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'maxRegistryTimeLock'>
      >,
    isValidAddr: (...args: ExtractArgs<Contract['calls']['isValidAddr']>) =>
      singleQuery(publicClient!, call.isValidAddr(...args), {}, addressResolver) as Promise<CallReturn<'isValidAddr'>>,
    isValidRegId: (...args: ExtractArgs<Contract['calls']['isValidRegId']>) =>
      singleQuery(publicClient!, call.isValidRegId(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidRegId'>
      >,
    getRegId: (...args: ExtractArgs<Contract['calls']['getRegId']>) =>
      singleQuery(publicClient!, call.getRegId(...args), {}, addressResolver) as Promise<CallReturn<'getRegId'>>,
    getAddr: (...args: ExtractArgs<Contract['calls']['getAddr']>) =>
      singleQuery(publicClient!, call.getAddr(...args), {}, addressResolver) as Promise<CallReturn<'getAddr'>>,
    getAddrInfo: (...args: ExtractArgs<Contract['calls']['getAddrInfo']>) =>
      singleQuery(publicClient!, call.getAddrInfo(...args), {}, addressResolver) as Promise<CallReturn<'getAddrInfo'>>,
    getAddrDescription: (...args: ExtractArgs<Contract['calls']['getAddrDescription']>) =>
      singleQuery(publicClient!, call.getAddrDescription(...args), {}, addressResolver) as Promise<
        CallReturn<'getAddrDescription'>
      >,
    getNumAddrs: (...args: ExtractArgs<Contract['calls']['getNumAddrs']>) =>
      singleQuery(publicClient!, call.getNumAddrs(...args), {}, addressResolver) as Promise<CallReturn<'getNumAddrs'>>,
    getLastAddr: (...args: ExtractArgs<Contract['calls']['getLastAddr']>) =>
      singleQuery(publicClient!, call.getLastAddr(...args), {}, addressResolver) as Promise<CallReturn<'getLastAddr'>>,
    getLastRegId: (...args: ExtractArgs<Contract['calls']['getLastRegId']>) =>
      singleQuery(publicClient!, call.getLastRegId(...args), {}, addressResolver) as Promise<
        CallReturn<'getLastRegId'>
      >,
    registryChangeTimeLock: (...args: ExtractArgs<Contract['calls']['registryChangeTimeLock']>) =>
      singleQuery(publicClient!, call.registryChangeTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'registryChangeTimeLock'>
      >,
    addrInfo: (...args: ExtractArgs<Contract['calls']['addrInfo']>) =>
      singleQuery(publicClient!, call.addrInfo(...args), {}, addressResolver) as Promise<CallReturn<'addrInfo'>>,
    addrToRegId: (...args: ExtractArgs<Contract['calls']['addrToRegId']>) =>
      singleQuery(publicClient!, call.addrToRegId(...args), {}, addressResolver) as Promise<CallReturn<'addrToRegId'>>,
    numAddrs: (...args: ExtractArgs<Contract['calls']['numAddrs']>) =>
      singleQuery(publicClient!, call.numAddrs(...args), {}, addressResolver) as Promise<CallReturn<'numAddrs'>>,
    pendingNewAddr: (...args: ExtractArgs<Contract['calls']['pendingNewAddr']>) =>
      singleQuery(publicClient!, call.pendingNewAddr(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingNewAddr'>
      >,
    pendingAddrUpdate: (...args: ExtractArgs<Contract['calls']['pendingAddrUpdate']>) =>
      singleQuery(publicClient!, call.pendingAddrUpdate(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingAddrUpdate'>
      >,
    pendingAddrDisable: (...args: ExtractArgs<Contract['calls']['pendingAddrDisable']>) =>
      singleQuery(publicClient!, call.pendingAddrDisable(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingAddrDisable'>
      >,
    getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) =>
      singleQuery(publicClient!, call.getAddys(...args), {}, addressResolver) as Promise<CallReturn<'getAddys'>>,
    getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) =>
      singleQuery(publicClient!, call.getUndyHq(...args), {}, addressResolver) as Promise<CallReturn<'getUndyHq'>>,
    canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) =>
      singleQuery(publicClient!, call.canMintUndy(...args), {}, addressResolver) as Promise<CallReturn<'canMintUndy'>>,
    isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) =>
      singleQuery(publicClient!, call.isPaused(...args), {}, addressResolver) as Promise<CallReturn<'isPaused'>>,
    isEarnVault: (...args: ExtractArgs<Contract['calls']['isEarnVault']>) =>
      singleQuery(publicClient!, call.isEarnVault(...args), {}, addressResolver) as Promise<CallReturn<'isEarnVault'>>,
    isLeveragedVault: (...args: ExtractArgs<Contract['calls']['isLeveragedVault']>) =>
      singleQuery(publicClient!, call.isLeveragedVault(...args), {}, addressResolver) as Promise<
        CallReturn<'isLeveragedVault'>
      >,
    isBasicEarnVault: (...args: ExtractArgs<Contract['calls']['isBasicEarnVault']>) =>
      singleQuery(publicClient!, call.isBasicEarnVault(...args), {}, addressResolver) as Promise<
        CallReturn<'isBasicEarnVault'>
      >,
    hasConfig: (...args: ExtractArgs<Contract['calls']['hasConfig']>) =>
      singleQuery(publicClient!, call.hasConfig(...args), {}, addressResolver) as Promise<CallReturn<'hasConfig'>>,
    isValidDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['isValidDefaultTargetVaultToken']>) =>
      singleQuery(publicClient!, call.isValidDefaultTargetVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidDefaultTargetVaultToken'>
      >,
    isValidPerformanceFee: (...args: ExtractArgs<Contract['calls']['isValidPerformanceFee']>) =>
      singleQuery(publicClient!, call.isValidPerformanceFee(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidPerformanceFee'>
      >,
    isValidRedemptionBuffer: (...args: ExtractArgs<Contract['calls']['isValidRedemptionBuffer']>) =>
      singleQuery(publicClient!, call.isValidRedemptionBuffer(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidRedemptionBuffer'>
      >,
    getApprovedVaultTokens: (...args: ExtractArgs<Contract['calls']['getApprovedVaultTokens']>) =>
      singleQuery(publicClient!, call.getApprovedVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'getApprovedVaultTokens'>
      >,
    getAssetVaultTokens: (...args: ExtractArgs<Contract['calls']['getAssetVaultTokens']>) =>
      singleQuery(publicClient!, call.getAssetVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'getAssetVaultTokens'>
      >,
    getNumApprovedVaultTokens: (...args: ExtractArgs<Contract['calls']['getNumApprovedVaultTokens']>) =>
      singleQuery(publicClient!, call.getNumApprovedVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'getNumApprovedVaultTokens'>
      >,
    getNumAssetVaultTokens: (...args: ExtractArgs<Contract['calls']['getNumAssetVaultTokens']>) =>
      singleQuery(publicClient!, call.getNumAssetVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'getNumAssetVaultTokens'>
      >,
    isApprovedVaultTokenForAsset: (...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenForAsset']>) =>
      singleQuery(publicClient!, call.isApprovedVaultTokenForAsset(...args), {}, addressResolver) as Promise<
        CallReturn<'isApprovedVaultTokenForAsset'>
      >,
    canDeposit: (...args: ExtractArgs<Contract['calls']['canDeposit']>) =>
      singleQuery(publicClient!, call.canDeposit(...args), {}, addressResolver) as Promise<CallReturn<'canDeposit'>>,
    canWithdraw: (...args: ExtractArgs<Contract['calls']['canWithdraw']>) =>
      singleQuery(publicClient!, call.canWithdraw(...args), {}, addressResolver) as Promise<CallReturn<'canWithdraw'>>,
    maxDepositAmount: (...args: ExtractArgs<Contract['calls']['maxDepositAmount']>) =>
      singleQuery(publicClient!, call.maxDepositAmount(...args), {}, addressResolver) as Promise<
        CallReturn<'maxDepositAmount'>
      >,
    isVaultOpsFrozen: (...args: ExtractArgs<Contract['calls']['isVaultOpsFrozen']>) =>
      singleQuery(publicClient!, call.isVaultOpsFrozen(...args), {}, addressResolver) as Promise<
        CallReturn<'isVaultOpsFrozen'>
      >,
    redemptionBuffer: (...args: ExtractArgs<Contract['calls']['redemptionBuffer']>) =>
      singleQuery(publicClient!, call.redemptionBuffer(...args), {}, addressResolver) as Promise<
        CallReturn<'redemptionBuffer'>
      >,
    minYieldWithdrawAmount: (...args: ExtractArgs<Contract['calls']['minYieldWithdrawAmount']>) =>
      singleQuery(publicClient!, call.minYieldWithdrawAmount(...args), {}, addressResolver) as Promise<
        CallReturn<'minYieldWithdrawAmount'>
      >,
    redemptionConfig: (...args: ExtractArgs<Contract['calls']['redemptionConfig']>) =>
      singleQuery(publicClient!, call.redemptionConfig(...args), {}, addressResolver) as Promise<
        CallReturn<'redemptionConfig'>
      >,
    getPerformanceFee: (...args: ExtractArgs<Contract['calls']['getPerformanceFee']>) =>
      singleQuery(publicClient!, call.getPerformanceFee(...args), {}, addressResolver) as Promise<
        CallReturn<'getPerformanceFee'>
      >,
    getDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['getDefaultTargetVaultToken']>) =>
      singleQuery(publicClient!, call.getDefaultTargetVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'getDefaultTargetVaultToken'>
      >,
    shouldAutoDeposit: (...args: ExtractArgs<Contract['calls']['shouldAutoDeposit']>) =>
      singleQuery(publicClient!, call.shouldAutoDeposit(...args), {}, addressResolver) as Promise<
        CallReturn<'shouldAutoDeposit'>
      >,
    shouldEnforceAllowlist: (...args: ExtractArgs<Contract['calls']['shouldEnforceAllowlist']>) =>
      singleQuery(publicClient!, call.shouldEnforceAllowlist(...args), {}, addressResolver) as Promise<
        CallReturn<'shouldEnforceAllowlist'>
      >,
    isUserAllowed: (...args: ExtractArgs<Contract['calls']['isUserAllowed']>) =>
      singleQuery(publicClient!, call.isUserAllowed(...args), {}, addressResolver) as Promise<
        CallReturn<'isUserAllowed'>
      >,
    isApprovedVaultTokenByAddr: (...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenByAddr']>) =>
      singleQuery(publicClient!, call.isApprovedVaultTokenByAddr(...args), {}, addressResolver) as Promise<
        CallReturn<'isApprovedVaultTokenByAddr'>
      >,
    checkVaultApprovals: (...args: ExtractArgs<Contract['calls']['checkVaultApprovals']>) =>
      singleQuery(publicClient!, call.checkVaultApprovals(...args), {}, addressResolver) as Promise<
        CallReturn<'checkVaultApprovals'>
      >,
    getVaultConfig: (...args: ExtractArgs<Contract['calls']['getVaultConfig']>) =>
      singleQuery(publicClient!, call.getVaultConfig(...args), {}, addressResolver) as Promise<
        CallReturn<'getVaultConfig'>
      >,
    getVaultConfigByAddr: (...args: ExtractArgs<Contract['calls']['getVaultConfigByAddr']>) =>
      singleQuery(publicClient!, call.getVaultConfigByAddr(...args), {}, addressResolver) as Promise<
        CallReturn<'getVaultConfigByAddr'>
      >,
    getVaultActionDataBundle: (...args: ExtractArgs<Contract['calls']['getVaultActionDataBundle']>) =>
      singleQuery(publicClient!, call.getVaultActionDataBundle(...args), {}, addressResolver) as Promise<
        CallReturn<'getVaultActionDataBundle'>
      >,
    getVaultActionDataWithFrozenStatus: (
      ...args: ExtractArgs<Contract['calls']['getVaultActionDataWithFrozenStatus']>
    ) =>
      singleQuery(publicClient!, call.getVaultActionDataWithFrozenStatus(...args), {}, addressResolver) as Promise<
        CallReturn<'getVaultActionDataWithFrozenStatus'>
      >,
    getLegoDataFromVaultToken: (...args: ExtractArgs<Contract['calls']['getLegoDataFromVaultToken']>) =>
      singleQuery(publicClient!, call.getLegoDataFromVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'getLegoDataFromVaultToken'>
      >,
    getLegoAddrFromVaultToken: (...args: ExtractArgs<Contract['calls']['getLegoAddrFromVaultToken']>) =>
      singleQuery(publicClient!, call.getLegoAddrFromVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'getLegoAddrFromVaultToken'>
      >,
    getDepositConfig: (...args: ExtractArgs<Contract['calls']['getDepositConfig']>) =>
      singleQuery(publicClient!, call.getDepositConfig(...args), {}, addressResolver) as Promise<
        CallReturn<'getDepositConfig'>
      >,
    canUserDeposit: (...args: ExtractArgs<Contract['calls']['canUserDeposit']>) =>
      singleQuery(publicClient!, call.canUserDeposit(...args), {}, addressResolver) as Promise<
        CallReturn<'canUserDeposit'>
      >,
    vaultConfigs: (...args: ExtractArgs<Contract['calls']['vaultConfigs']>) =>
      singleQuery(publicClient!, call.vaultConfigs(...args), {}, addressResolver) as Promise<
        CallReturn<'vaultConfigs'>
      >,
    isApprovedVaultToken: (...args: ExtractArgs<Contract['calls']['isApprovedVaultToken']>) =>
      singleQuery(publicClient!, call.isApprovedVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'isApprovedVaultToken'>
      >,
    approvedVaultTokens: (...args: ExtractArgs<Contract['calls']['approvedVaultTokens']>) =>
      singleQuery(publicClient!, call.approvedVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'approvedVaultTokens'>
      >,
    indexOfApprovedVaultToken: (...args: ExtractArgs<Contract['calls']['indexOfApprovedVaultToken']>) =>
      singleQuery(publicClient!, call.indexOfApprovedVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'indexOfApprovedVaultToken'>
      >,
    numApprovedVaultTokens: (...args: ExtractArgs<Contract['calls']['numApprovedVaultTokens']>) =>
      singleQuery(publicClient!, call.numApprovedVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'numApprovedVaultTokens'>
      >,
    assetVaultTokens: (...args: ExtractArgs<Contract['calls']['assetVaultTokens']>) =>
      singleQuery(publicClient!, call.assetVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'assetVaultTokens'>
      >,
    indexOfAssetVaultToken: (...args: ExtractArgs<Contract['calls']['indexOfAssetVaultToken']>) =>
      singleQuery(publicClient!, call.indexOfAssetVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'indexOfAssetVaultToken'>
      >,
    numAssetVaultTokens: (...args: ExtractArgs<Contract['calls']['numAssetVaultTokens']>) =>
      singleQuery(publicClient!, call.numAssetVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'numAssetVaultTokens'>
      >,
    assetVaultTokenRefCount: (...args: ExtractArgs<Contract['calls']['assetVaultTokenRefCount']>) =>
      singleQuery(publicClient!, call.assetVaultTokenRefCount(...args), {}, addressResolver) as Promise<
        CallReturn<'assetVaultTokenRefCount'>
      >,
    isAllowed: (...args: ExtractArgs<Contract['calls']['isAllowed']>) =>
      singleQuery(publicClient!, call.isAllowed(...args), {}, addressResolver) as Promise<CallReturn<'isAllowed'>>,

    // Mutations
    startGovernanceChange: (...args: ExtractArgs<Contract['mutations']['startGovernanceChange']>) =>
      mutate(walletClient!, mutation.startGovernanceChange, { addressResolver })(...args),
    confirmGovernanceChange: (...args: ExtractArgs<Contract['mutations']['confirmGovernanceChange']>) =>
      mutate(walletClient!, mutation.confirmGovernanceChange, { addressResolver })(...args),
    cancelGovernanceChange: (...args: ExtractArgs<Contract['mutations']['cancelGovernanceChange']>) =>
      mutate(walletClient!, mutation.cancelGovernanceChange, { addressResolver })(...args),
    relinquishGov: (...args: ExtractArgs<Contract['mutations']['relinquishGov']>) =>
      mutate(walletClient!, mutation.relinquishGov, { addressResolver })(...args),
    setGovTimeLock: (...args: ExtractArgs<Contract['mutations']['setGovTimeLock']>) =>
      mutate(walletClient!, mutation.setGovTimeLock, { addressResolver })(...args),
    finishUndyHqSetup: (...args: ExtractArgs<Contract['mutations']['finishUndyHqSetup']>) =>
      mutate(walletClient!, mutation.finishUndyHqSetup, { addressResolver })(...args),
    setRegistryTimeLock: (...args: ExtractArgs<Contract['mutations']['setRegistryTimeLock']>) =>
      mutate(walletClient!, mutation.setRegistryTimeLock, { addressResolver })(...args),
    setRegistryTimeLockAfterSetup: (...args: ExtractArgs<Contract['mutations']['setRegistryTimeLockAfterSetup']>) =>
      mutate(walletClient!, mutation.setRegistryTimeLockAfterSetup, { addressResolver })(...args),
    pause: (...args: ExtractArgs<Contract['mutations']['pause']>) =>
      mutate(walletClient!, mutation.pause, { addressResolver })(...args),
    recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) =>
      mutate(walletClient!, mutation.recoverFunds, { addressResolver })(...args),
    recoverFundsMany: (...args: ExtractArgs<Contract['mutations']['recoverFundsMany']>) =>
      mutate(walletClient!, mutation.recoverFundsMany, { addressResolver })(...args),
    startAddNewAddressToRegistry: (...args: ExtractArgs<Contract['mutations']['startAddNewAddressToRegistry']>) =>
      mutate(walletClient!, mutation.startAddNewAddressToRegistry, { addressResolver })(...args),
    confirmNewAddressToRegistry: (...args: ExtractArgs<Contract['mutations']['confirmNewAddressToRegistry']>) =>
      mutate(walletClient!, mutation.confirmNewAddressToRegistry, { addressResolver })(...args),
    cancelNewAddressToRegistry: (...args: ExtractArgs<Contract['mutations']['cancelNewAddressToRegistry']>) =>
      mutate(walletClient!, mutation.cancelNewAddressToRegistry, { addressResolver })(...args),
    startAddressDisableInRegistry: (...args: ExtractArgs<Contract['mutations']['startAddressDisableInRegistry']>) =>
      mutate(walletClient!, mutation.startAddressDisableInRegistry, { addressResolver })(...args),
    confirmAddressDisableInRegistry: (...args: ExtractArgs<Contract['mutations']['confirmAddressDisableInRegistry']>) =>
      mutate(walletClient!, mutation.confirmAddressDisableInRegistry, { addressResolver })(...args),
    cancelAddressDisableInRegistry: (...args: ExtractArgs<Contract['mutations']['cancelAddressDisableInRegistry']>) =>
      mutate(walletClient!, mutation.cancelAddressDisableInRegistry, { addressResolver })(...args),
    setCanDeposit: (...args: ExtractArgs<Contract['mutations']['setCanDeposit']>) =>
      mutate(walletClient!, mutation.setCanDeposit, { addressResolver })(...args),
    setCanWithdraw: (...args: ExtractArgs<Contract['mutations']['setCanWithdraw']>) =>
      mutate(walletClient!, mutation.setCanWithdraw, { addressResolver })(...args),
    setMaxDepositAmount: (...args: ExtractArgs<Contract['mutations']['setMaxDepositAmount']>) =>
      mutate(walletClient!, mutation.setMaxDepositAmount, { addressResolver })(...args),
    setVaultOpsFrozen: (...args: ExtractArgs<Contract['mutations']['setVaultOpsFrozen']>) =>
      mutate(walletClient!, mutation.setVaultOpsFrozen, { addressResolver })(...args),
    setShouldAutoDeposit: (...args: ExtractArgs<Contract['mutations']['setShouldAutoDeposit']>) =>
      mutate(walletClient!, mutation.setShouldAutoDeposit, { addressResolver })(...args),
    setMinYieldWithdrawAmount: (...args: ExtractArgs<Contract['mutations']['setMinYieldWithdrawAmount']>) =>
      mutate(walletClient!, mutation.setMinYieldWithdrawAmount, { addressResolver })(...args),
    setIsLeveragedVault: (...args: ExtractArgs<Contract['mutations']['setIsLeveragedVault']>) =>
      mutate(walletClient!, mutation.setIsLeveragedVault, { addressResolver })(...args),
    setShouldEnforceAllowlist: (...args: ExtractArgs<Contract['mutations']['setShouldEnforceAllowlist']>) =>
      mutate(walletClient!, mutation.setShouldEnforceAllowlist, { addressResolver })(...args),
    setAllowed: (...args: ExtractArgs<Contract['mutations']['setAllowed']>) =>
      mutate(walletClient!, mutation.setAllowed, { addressResolver })(...args),
    setAllowedBatch: (...args: ExtractArgs<Contract['mutations']['setAllowedBatch']>) =>
      mutate(walletClient!, mutation.setAllowedBatch, { addressResolver })(...args),
    setDefaultTargetVaultToken: (...args: ExtractArgs<Contract['mutations']['setDefaultTargetVaultToken']>) =>
      mutate(walletClient!, mutation.setDefaultTargetVaultToken, { addressResolver })(...args),
    setPerformanceFee: (...args: ExtractArgs<Contract['mutations']['setPerformanceFee']>) =>
      mutate(walletClient!, mutation.setPerformanceFee, { addressResolver })(...args),
    setRedemptionBuffer: (...args: ExtractArgs<Contract['mutations']['setRedemptionBuffer']>) =>
      mutate(walletClient!, mutation.setRedemptionBuffer, { addressResolver })(...args),
    setApprovedVaultToken: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultToken']>) =>
      mutate(walletClient!, mutation.setApprovedVaultToken, { addressResolver })(...args),
    setApprovedVaultTokens: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultTokens']>) =>
      mutate(walletClient!, mutation.setApprovedVaultTokens, { addressResolver })(...args),
  }
}
