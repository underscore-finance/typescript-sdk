/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate } from '@dappql/async'
import { PublicClient, WalletClient } from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    name: 'CanDepositSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'canDeposit',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'CanWithdrawSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'canWithdraw',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'MaxDepositAmountSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'maxDepositAmount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'VaultOpsFrozenSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isFrozen',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'RedemptionBufferSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'buffer',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'MinYieldWithdrawAmountSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PerformanceFeeSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'performanceFee',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'DefaultTargetVaultTokenSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'targetVaultToken',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ShouldAutoDepositSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'shouldAutoDeposit',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ApprovedVaultTokenSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isApproved',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeTimeLockModified',
    inputs: [
      {
        name: 'prevTimeLock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'newTimeLock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'RegistryTimeLockModified',
    inputs: [
      {
        name: 'newTimeLock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'prevTimeLock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeStarted',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeConfirmed',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeCancelled',
    inputs: [
      {
        name: 'cancelledGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovRelinquished',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'UndyHqSetupFinished',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'timeLock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'DepartmentPauseModified',
    inputs: [
      {
        name: 'isPaused',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'DepartmentFundsRecovered',
    inputs: [
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'recipient',
        type: 'address',
        indexed: true,
      },
      {
        name: 'balance',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'NewAddressPending',
    inputs: [
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'NewAddressConfirmed',
    inputs: [
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'regId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'NewAddressCancelled',
    inputs: [
      {
        name: 'description',
        type: 'string',
        indexed: false,
      },
      {
        name: 'addr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'registry',
        type: 'string',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUndyHqFromGov',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canGovern',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getGovernors',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasPendingGovChange',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'startGovernanceChange',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmGovernanceChange',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cancelGovernanceChange',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'relinquishGov',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setGovTimeLock',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidGovTimeLock',
    inputs: [
      {
        name: '_newTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'minGovChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'maxGovChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'finishUndyHqSetup',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'finishUndyHqSetup',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
      {
        name: '_timeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'governance',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingGov',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'newGov',
            type: 'address',
          },
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numGovChanges',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'govChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getRegistryDescription',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'string',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidNewAddress',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidAddressUpdate',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
      {
        name: '_newAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidAddressDisable',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRegistryTimeLock',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidRegistryTimeLock',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRegistryTimeLockAfterSetup',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRegistryTimeLockAfterSetup',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'minRegistryTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'maxRegistryTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidAddr',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidRegId',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getRegId',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddr',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddrInfo',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'addr',
            type: 'address',
          },
          {
            name: 'version',
            type: 'uint256',
          },
          {
            name: 'lastModified',
            type: 'uint256',
          },
          {
            name: 'description',
            type: 'string',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddrDescription',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'string',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getNumAddrs',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLastAddr',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLastRegId',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'registryChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'addrInfo',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'addr',
            type: 'address',
          },
          {
            name: 'version',
            type: 'uint256',
          },
          {
            name: 'lastModified',
            type: 'uint256',
          },
          {
            name: 'description',
            type: 'string',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'addrToRegId',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numAddrs',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingNewAddr',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'description',
            type: 'string',
          },
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingAddrUpdate',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'newAddr',
            type: 'address',
          },
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingAddrDisable',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddys',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'hq',
            type: 'address',
          },
          {
            name: 'undyToken',
            type: 'address',
          },
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'switchboard',
            type: 'address',
          },
          {
            name: 'hatchery',
            type: 'address',
          },
          {
            name: 'lootDistributor',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'walletBackpack',
            type: 'address',
          },
          {
            name: 'billing',
            type: 'address',
          },
          {
            name: 'vaultRegistry',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUndyHq',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canMintUndy',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'pause',
    inputs: [
      {
        name: '_shouldPause',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFunds',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFundsMany',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_assets',
        type: 'address[]',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isPaused',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isEarnVault',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'startAddNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_description',
        type: 'string',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
      {
        name: '_isVaultOpsFrozen',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_approvedVaultTokens',
        type: 'address[]',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
      {
        name: '_minYieldWithdrawAmount',
        type: 'uint256',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
      {
        name: '_defaultTargetVaultToken',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
      {
        name: '_isVaultOpsFrozen',
        type: 'bool',
      },
      {
        name: '_redemptionBuffer',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cancelNewAddressToRegistry',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setCanDeposit',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setCanWithdraw',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setMaxDepositAmount',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setVaultOpsFrozen',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_isFrozen',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setShouldAutoDeposit',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setMinYieldWithdrawAmount',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setApprovedVaultToken',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_isApproved',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setDefaultTargetVaultToken',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_targetVaultToken',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidDefaultTargetVaultToken',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_targetVaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setPerformanceFee',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidPerformanceFee',
    inputs: [
      {
        name: '_performanceFee',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRedemptionBuffer',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_buffer',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidRedemptionBuffer',
    inputs: [
      {
        name: '_buffer',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canDeposit',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canWithdraw',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'maxDepositAmount',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isVaultOpsFrozen',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'redemptionBuffer',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'minYieldWithdrawAmount',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'redemptionConfig',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getPerformanceFee',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getDefaultTargetVaultToken',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'shouldAutoDeposit',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isApprovedVaultTokenByAddr',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'checkVaultApprovals',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultConfig',
    inputs: [
      {
        name: '_regId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'canDeposit',
            type: 'bool',
          },
          {
            name: 'canWithdraw',
            type: 'bool',
          },
          {
            name: 'maxDepositAmount',
            type: 'uint256',
          },
          {
            name: 'isVaultOpsFrozen',
            type: 'bool',
          },
          {
            name: 'redemptionBuffer',
            type: 'uint256',
          },
          {
            name: 'minYieldWithdrawAmount',
            type: 'uint256',
          },
          {
            name: 'performanceFee',
            type: 'uint256',
          },
          {
            name: 'shouldAutoDeposit',
            type: 'bool',
          },
          {
            name: 'defaultTargetVaultToken',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultConfigByAddr',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'canDeposit',
            type: 'bool',
          },
          {
            name: 'canWithdraw',
            type: 'bool',
          },
          {
            name: 'maxDepositAmount',
            type: 'uint256',
          },
          {
            name: 'isVaultOpsFrozen',
            type: 'bool',
          },
          {
            name: 'redemptionBuffer',
            type: 'uint256',
          },
          {
            name: 'minYieldWithdrawAmount',
            type: 'uint256',
          },
          {
            name: 'performanceFee',
            type: 'uint256',
          },
          {
            name: 'shouldAutoDeposit',
            type: 'bool',
          },
          {
            name: 'defaultTargetVaultToken',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultActionDataBundle',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_signer',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'vaultRegistry',
            type: 'address',
          },
          {
            name: 'vaultAsset',
            type: 'address',
          },
          {
            name: 'signer',
            type: 'address',
          },
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'legoAddr',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultActionDataWithFrozenStatus',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_signer',
        type: 'address',
      },
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'vaultRegistry',
            type: 'address',
          },
          {
            name: 'vaultAsset',
            type: 'address',
          },
          {
            name: 'signer',
            type: 'address',
          },
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'legoAddr',
            type: 'address',
          },
        ],
      },
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLegoDataFromVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLegoAddrFromVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getDepositConfig',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'vaultConfigs',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'canDeposit',
            type: 'bool',
          },
          {
            name: 'canWithdraw',
            type: 'bool',
          },
          {
            name: 'maxDepositAmount',
            type: 'uint256',
          },
          {
            name: 'isVaultOpsFrozen',
            type: 'bool',
          },
          {
            name: 'redemptionBuffer',
            type: 'uint256',
          },
          {
            name: 'minYieldWithdrawAmount',
            type: 'uint256',
          },
          {
            name: 'performanceFee',
            type: 'uint256',
          },
          {
            name: 'shouldAutoDeposit',
            type: 'bool',
          },
          {
            name: 'defaultTargetVaultToken',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isApprovedVaultToken',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'constructor',
    inputs: [
      {
        name: '_undyHq',
        type: 'address',
      },
      {
        name: '_tempGov',
        type: 'address',
      },
      {
        name: '_minRegistryTimeLock',
        type: 'uint256',
      },
      {
        name: '_maxRegistryTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
] as const

export const deployAddress: Address | undefined = '0x73388bD7f17CeCA0679604405A5d2C418Db2b702'

export type Contract = {
  calls: {
    getUndyHqFromGov: () => Promise<`0x${string}`>
    canGovern: (addr: `0x${string}`) => Promise<boolean>
    getGovernors: () => Promise<`0x${string}`[]>
    hasPendingGovChange: () => Promise<boolean>
    isValidGovTimeLock: (newTimeLock: bigint) => Promise<boolean>
    minGovChangeTimeLock: () => Promise<bigint>
    maxGovChangeTimeLock: () => Promise<bigint>
    governance: () => Promise<`0x${string}`>
    pendingGov: () => Promise<{ newGov: `0x${string}`; initiatedBlock: bigint; confirmBlock: bigint }>
    numGovChanges: () => Promise<bigint>
    govChangeTimeLock: () => Promise<bigint>
    getRegistryDescription: () => Promise<string>
    isValidNewAddress: (addr: `0x${string}`) => Promise<boolean>
    isValidAddressUpdate: (regId: bigint, newAddr: `0x${string}`) => Promise<boolean>
    isValidAddressDisable: (regId: bigint) => Promise<boolean>
    isValidRegistryTimeLock: (numBlocks: bigint) => Promise<boolean>
    minRegistryTimeLock: () => Promise<bigint>
    maxRegistryTimeLock: () => Promise<bigint>
    isValidAddr: (addr: `0x${string}`) => Promise<boolean>
    isValidRegId: (regId: bigint) => Promise<boolean>
    getRegId: (addr: `0x${string}`) => Promise<bigint>
    getAddr: (regId: bigint) => Promise<`0x${string}`>
    getAddrInfo: (
      regId: bigint,
    ) => Promise<{ addr: `0x${string}`; version: bigint; lastModified: bigint; description: string }>
    getAddrDescription: (regId: bigint) => Promise<string>
    getNumAddrs: () => Promise<bigint>
    getLastAddr: () => Promise<`0x${string}`>
    getLastRegId: () => Promise<bigint>
    registryChangeTimeLock: () => Promise<bigint>
    addrInfo: (
      arg0: bigint,
    ) => Promise<{ addr: `0x${string}`; version: bigint; lastModified: bigint; description: string }>
    addrToRegId: (arg0: `0x${string}`) => Promise<bigint>
    numAddrs: () => Promise<bigint>
    pendingNewAddr: (
      arg0: `0x${string}`,
    ) => Promise<{ description: string; initiatedBlock: bigint; confirmBlock: bigint }>
    pendingAddrUpdate: (
      arg0: bigint,
    ) => Promise<{ newAddr: `0x${string}`; initiatedBlock: bigint; confirmBlock: bigint }>
    pendingAddrDisable: (arg0: bigint) => Promise<{ initiatedBlock: bigint; confirmBlock: bigint }>
    getAddys: () => Promise<{
      hq: `0x${string}`
      undyToken: `0x${string}`
      ledger: `0x${string}`
      missionControl: `0x${string}`
      legoBook: `0x${string}`
      switchboard: `0x${string}`
      hatchery: `0x${string}`
      lootDistributor: `0x${string}`
      appraiser: `0x${string}`
      walletBackpack: `0x${string}`
      billing: `0x${string}`
      vaultRegistry: `0x${string}`
    }>
    getUndyHq: () => Promise<`0x${string}`>
    canMintUndy: () => Promise<boolean>
    isPaused: () => Promise<boolean>
    isEarnVault: (vaultAddr: `0x${string}`) => Promise<boolean>
    isValidVaultToken: (vaultToken: `0x${string}`) => Promise<boolean>
    isValidDefaultTargetVaultToken: (vaultAddr: `0x${string}`, targetVaultToken: `0x${string}`) => Promise<boolean>
    isValidPerformanceFee: (performanceFee: bigint) => Promise<boolean>
    isValidRedemptionBuffer: (buffer: bigint) => Promise<boolean>
    canDeposit: (vaultAddr: `0x${string}`) => Promise<boolean>
    canWithdraw: (vaultAddr: `0x${string}`) => Promise<boolean>
    maxDepositAmount: (vaultAddr: `0x${string}`) => Promise<bigint>
    isVaultOpsFrozen: (vaultAddr: `0x${string}`) => Promise<boolean>
    redemptionBuffer: (vaultAddr: `0x${string}`) => Promise<bigint>
    minYieldWithdrawAmount: (vaultAddr: `0x${string}`) => Promise<bigint>
    redemptionConfig: (vaultAddr: `0x${string}`) => Promise<[bigint, bigint]>
    getPerformanceFee: (vaultAddr: `0x${string}`) => Promise<bigint>
    getDefaultTargetVaultToken: (vaultAddr: `0x${string}`) => Promise<`0x${string}`>
    shouldAutoDeposit: (vaultAddr: `0x${string}`) => Promise<boolean>
    isApprovedVaultTokenByAddr: (vaultAddr: `0x${string}`, vaultToken: `0x${string}`) => Promise<boolean>
    checkVaultApprovals: (vaultAddr: `0x${string}`, vaultToken: `0x${string}`) => Promise<boolean>
    getVaultConfig: (
      regId: bigint,
    ) => Promise<{
      canDeposit: boolean
      canWithdraw: boolean
      maxDepositAmount: bigint
      isVaultOpsFrozen: boolean
      redemptionBuffer: bigint
      minYieldWithdrawAmount: bigint
      performanceFee: bigint
      shouldAutoDeposit: boolean
      defaultTargetVaultToken: `0x${string}`
    }>
    getVaultConfigByAddr: (
      vaultAddr: `0x${string}`,
    ) => Promise<{
      canDeposit: boolean
      canWithdraw: boolean
      maxDepositAmount: bigint
      isVaultOpsFrozen: boolean
      redemptionBuffer: bigint
      minYieldWithdrawAmount: bigint
      performanceFee: bigint
      shouldAutoDeposit: boolean
      defaultTargetVaultToken: `0x${string}`
    }>
    getVaultActionDataBundle: (
      legoId: bigint,
      signer: `0x${string}`,
    ) => Promise<{
      ledger: `0x${string}`
      missionControl: `0x${string}`
      legoBook: `0x${string}`
      appraiser: `0x${string}`
      vaultRegistry: `0x${string}`
      vaultAsset: `0x${string}`
      signer: `0x${string}`
      legoId: bigint
      legoAddr: `0x${string}`
    }>
    getVaultActionDataWithFrozenStatus: (
      legoId: bigint,
      signer: `0x${string}`,
      vaultAddr: `0x${string}`,
    ) => Promise<
      [
        {
          ledger: `0x${string}`
          missionControl: `0x${string}`
          legoBook: `0x${string}`
          appraiser: `0x${string}`
          vaultRegistry: `0x${string}`
          vaultAsset: `0x${string}`
          signer: `0x${string}`
          legoId: bigint
          legoAddr: `0x${string}`
        },
        boolean,
      ]
    >
    getLegoDataFromVaultToken: (vaultToken: `0x${string}`) => Promise<[bigint, `0x${string}`]>
    getLegoAddrFromVaultToken: (vaultToken: `0x${string}`) => Promise<`0x${string}`>
    getDepositConfig: (vaultAddr: `0x${string}`) => Promise<[boolean, bigint, boolean, `0x${string}`]>
    vaultConfigs: (
      arg0: `0x${string}`,
    ) => Promise<{
      canDeposit: boolean
      canWithdraw: boolean
      maxDepositAmount: bigint
      isVaultOpsFrozen: boolean
      redemptionBuffer: bigint
      minYieldWithdrawAmount: bigint
      performanceFee: bigint
      shouldAutoDeposit: boolean
      defaultTargetVaultToken: `0x${string}`
    }>
    isApprovedVaultToken: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<boolean>
  }
  mutations: {
    startGovernanceChange: (newGov: `0x${string}`) => Promise<void>
    confirmGovernanceChange: () => Promise<void>
    cancelGovernanceChange: () => Promise<void>
    relinquishGov: () => Promise<void>
    setGovTimeLock: (numBlocks: bigint) => Promise<boolean>
    finishUndyHqSetup: (newGov: `0x${string}`, timeLock?: bigint) => Promise<boolean>
    setRegistryTimeLock: (numBlocks: bigint) => Promise<boolean>
    setRegistryTimeLockAfterSetup: (numBlocks?: bigint) => Promise<boolean>
    pause: (shouldPause: boolean) => Promise<void>
    recoverFunds: (recipient: `0x${string}`, asset: `0x${string}`) => Promise<void>
    recoverFundsMany: (recipient: `0x${string}`, assets: `0x${string}`[]) => Promise<void>
    startAddNewAddressToRegistry: (vaultAddr: `0x${string}`, description: string) => Promise<boolean>
    confirmNewAddressToRegistry: (
      vaultAddr: `0x${string}`,
      approvedVaultTokens?: `0x${string}`[],
      maxDepositAmount?: bigint,
      minYieldWithdrawAmount?: bigint,
      performanceFee?: bigint,
      defaultTargetVaultToken?: `0x${string}`,
      shouldAutoDeposit?: boolean,
      canDeposit?: boolean,
      canWithdraw?: boolean,
      isVaultOpsFrozen?: boolean,
      redemptionBuffer?: bigint,
    ) => Promise<bigint>
    cancelNewAddressToRegistry: (vaultAddr: `0x${string}`) => Promise<boolean>
    setCanDeposit: (vaultAddr: `0x${string}`, canDeposit: boolean) => Promise<void>
    setCanWithdraw: (vaultAddr: `0x${string}`, canWithdraw: boolean) => Promise<void>
    setMaxDepositAmount: (vaultAddr: `0x${string}`, maxDepositAmount: bigint) => Promise<void>
    setVaultOpsFrozen: (vaultAddr: `0x${string}`, isFrozen: boolean) => Promise<void>
    setShouldAutoDeposit: (vaultAddr: `0x${string}`, shouldAutoDeposit: boolean) => Promise<void>
    setMinYieldWithdrawAmount: (vaultAddr: `0x${string}`, amount: bigint) => Promise<void>
    setApprovedVaultToken: (vaultAddr: `0x${string}`, vaultToken: `0x${string}`, isApproved: boolean) => Promise<void>
    setDefaultTargetVaultToken: (vaultAddr: `0x${string}`, targetVaultToken: `0x${string}`) => Promise<void>
    setPerformanceFee: (vaultAddr: `0x${string}`, performanceFee: bigint) => Promise<void>
    setRedemptionBuffer: (vaultAddr: `0x${string}`, buffer: bigint) => Promise<void>
  }
  events: {
    CanDepositSet: (vaultAddr: `0x${string}`, canDeposit: boolean) => Promise<void>
    CanWithdrawSet: (vaultAddr: `0x${string}`, canWithdraw: boolean) => Promise<void>
    MaxDepositAmountSet: (vaultAddr: `0x${string}`, maxDepositAmount: bigint) => Promise<void>
    VaultOpsFrozenSet: (vaultAddr: `0x${string}`, isFrozen: boolean) => Promise<void>
    RedemptionBufferSet: (vaultAddr: `0x${string}`, buffer: bigint) => Promise<void>
    MinYieldWithdrawAmountSet: (vaultAddr: `0x${string}`, amount: bigint) => Promise<void>
    PerformanceFeeSet: (vaultAddr: `0x${string}`, performanceFee: bigint) => Promise<void>
    DefaultTargetVaultTokenSet: (vaultAddr: `0x${string}`, targetVaultToken: `0x${string}`) => Promise<void>
    ShouldAutoDepositSet: (vaultAddr: `0x${string}`, shouldAutoDeposit: boolean) => Promise<void>
    ApprovedVaultTokenSet: (vaultAddr: `0x${string}`, vaultToken: `0x${string}`, isApproved: boolean) => Promise<void>
    GovChangeTimeLockModified: (prevTimeLock: bigint, newTimeLock: bigint) => Promise<void>
    RegistryTimeLockModified: (newTimeLock: bigint, prevTimeLock: bigint, registry: string) => Promise<void>
    GovChangeStarted: (prevGov: `0x${string}`, newGov: `0x${string}`, confirmBlock: bigint) => Promise<void>
    GovChangeConfirmed: (
      prevGov: `0x${string}`,
      newGov: `0x${string}`,
      initiatedBlock: bigint,
      confirmBlock: bigint,
    ) => Promise<void>
    GovChangeCancelled: (cancelledGov: `0x${string}`, initiatedBlock: bigint, confirmBlock: bigint) => Promise<void>
    GovRelinquished: (prevGov: `0x${string}`) => Promise<void>
    UndyHqSetupFinished: (prevGov: `0x${string}`, newGov: `0x${string}`, timeLock: bigint) => Promise<void>
    DepartmentPauseModified: (isPaused: boolean) => Promise<void>
    DepartmentFundsRecovered: (asset: `0x${string}`, recipient: `0x${string}`, balance: bigint) => Promise<void>
    NewAddressPending: (
      addr: `0x${string}`,
      description: string,
      confirmBlock: bigint,
      registry: string,
    ) => Promise<void>
    NewAddressConfirmed: (addr: `0x${string}`, regId: bigint, description: string, registry: string) => Promise<void>
    NewAddressCancelled: (
      description: string,
      addr: `0x${string}`,
      initiatedBlock: bigint,
      confirmBlock: bigint,
      registry: string,
    ) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'VaultRegistry'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'VaultRegistry' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  getUndyHqFromGov: (...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>) =>
    getRequest('getUndyHqFromGov', args),
  canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) => getRequest('canGovern', args),
  getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) => getRequest('getGovernors', args),
  hasPendingGovChange: (...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>) =>
    getRequest('hasPendingGovChange', args),
  isValidGovTimeLock: (...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>) =>
    getRequest('isValidGovTimeLock', args),
  minGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>) =>
    getRequest('minGovChangeTimeLock', args),
  maxGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>) =>
    getRequest('maxGovChangeTimeLock', args),
  governance: (...args: ExtractArgs<Contract['calls']['governance']>) => getRequest('governance', args),
  pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) => getRequest('pendingGov', args),
  numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) => getRequest('numGovChanges', args),
  govChangeTimeLock: (...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>) =>
    getRequest('govChangeTimeLock', args),
  getRegistryDescription: (...args: ExtractArgs<Contract['calls']['getRegistryDescription']>) =>
    getRequest('getRegistryDescription', args),
  isValidNewAddress: (...args: ExtractArgs<Contract['calls']['isValidNewAddress']>) =>
    getRequest('isValidNewAddress', args),
  isValidAddressUpdate: (...args: ExtractArgs<Contract['calls']['isValidAddressUpdate']>) =>
    getRequest('isValidAddressUpdate', args),
  isValidAddressDisable: (...args: ExtractArgs<Contract['calls']['isValidAddressDisable']>) =>
    getRequest('isValidAddressDisable', args),
  isValidRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['isValidRegistryTimeLock']>) =>
    getRequest('isValidRegistryTimeLock', args),
  minRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['minRegistryTimeLock']>) =>
    getRequest('minRegistryTimeLock', args),
  maxRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['maxRegistryTimeLock']>) =>
    getRequest('maxRegistryTimeLock', args),
  isValidAddr: (...args: ExtractArgs<Contract['calls']['isValidAddr']>) => getRequest('isValidAddr', args),
  isValidRegId: (...args: ExtractArgs<Contract['calls']['isValidRegId']>) => getRequest('isValidRegId', args),
  getRegId: (...args: ExtractArgs<Contract['calls']['getRegId']>) => getRequest('getRegId', args),
  getAddr: (...args: ExtractArgs<Contract['calls']['getAddr']>) => getRequest('getAddr', args),
  getAddrInfo: (...args: ExtractArgs<Contract['calls']['getAddrInfo']>) => getRequest('getAddrInfo', args),
  getAddrDescription: (...args: ExtractArgs<Contract['calls']['getAddrDescription']>) =>
    getRequest('getAddrDescription', args),
  getNumAddrs: (...args: ExtractArgs<Contract['calls']['getNumAddrs']>) => getRequest('getNumAddrs', args),
  getLastAddr: (...args: ExtractArgs<Contract['calls']['getLastAddr']>) => getRequest('getLastAddr', args),
  getLastRegId: (...args: ExtractArgs<Contract['calls']['getLastRegId']>) => getRequest('getLastRegId', args),
  registryChangeTimeLock: (...args: ExtractArgs<Contract['calls']['registryChangeTimeLock']>) =>
    getRequest('registryChangeTimeLock', args),
  addrInfo: (...args: ExtractArgs<Contract['calls']['addrInfo']>) => getRequest('addrInfo', args),
  addrToRegId: (...args: ExtractArgs<Contract['calls']['addrToRegId']>) => getRequest('addrToRegId', args),
  numAddrs: (...args: ExtractArgs<Contract['calls']['numAddrs']>) => getRequest('numAddrs', args),
  pendingNewAddr: (...args: ExtractArgs<Contract['calls']['pendingNewAddr']>) => getRequest('pendingNewAddr', args),
  pendingAddrUpdate: (...args: ExtractArgs<Contract['calls']['pendingAddrUpdate']>) =>
    getRequest('pendingAddrUpdate', args),
  pendingAddrDisable: (...args: ExtractArgs<Contract['calls']['pendingAddrDisable']>) =>
    getRequest('pendingAddrDisable', args),
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => getRequest('getAddys', args),
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => getRequest('getUndyHq', args),
  canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) => getRequest('canMintUndy', args),
  isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) => getRequest('isPaused', args),
  isEarnVault: (...args: ExtractArgs<Contract['calls']['isEarnVault']>) => getRequest('isEarnVault', args),
  isValidVaultToken: (...args: ExtractArgs<Contract['calls']['isValidVaultToken']>) =>
    getRequest('isValidVaultToken', args),
  isValidDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['isValidDefaultTargetVaultToken']>) =>
    getRequest('isValidDefaultTargetVaultToken', args),
  isValidPerformanceFee: (...args: ExtractArgs<Contract['calls']['isValidPerformanceFee']>) =>
    getRequest('isValidPerformanceFee', args),
  isValidRedemptionBuffer: (...args: ExtractArgs<Contract['calls']['isValidRedemptionBuffer']>) =>
    getRequest('isValidRedemptionBuffer', args),
  canDeposit: (...args: ExtractArgs<Contract['calls']['canDeposit']>) => getRequest('canDeposit', args),
  canWithdraw: (...args: ExtractArgs<Contract['calls']['canWithdraw']>) => getRequest('canWithdraw', args),
  maxDepositAmount: (...args: ExtractArgs<Contract['calls']['maxDepositAmount']>) =>
    getRequest('maxDepositAmount', args),
  isVaultOpsFrozen: (...args: ExtractArgs<Contract['calls']['isVaultOpsFrozen']>) =>
    getRequest('isVaultOpsFrozen', args),
  redemptionBuffer: (...args: ExtractArgs<Contract['calls']['redemptionBuffer']>) =>
    getRequest('redemptionBuffer', args),
  minYieldWithdrawAmount: (...args: ExtractArgs<Contract['calls']['minYieldWithdrawAmount']>) =>
    getRequest('minYieldWithdrawAmount', args),
  redemptionConfig: (...args: ExtractArgs<Contract['calls']['redemptionConfig']>) =>
    getRequest('redemptionConfig', args),
  getPerformanceFee: (...args: ExtractArgs<Contract['calls']['getPerformanceFee']>) =>
    getRequest('getPerformanceFee', args),
  getDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['getDefaultTargetVaultToken']>) =>
    getRequest('getDefaultTargetVaultToken', args),
  shouldAutoDeposit: (...args: ExtractArgs<Contract['calls']['shouldAutoDeposit']>) =>
    getRequest('shouldAutoDeposit', args),
  isApprovedVaultTokenByAddr: (...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenByAddr']>) =>
    getRequest('isApprovedVaultTokenByAddr', args),
  checkVaultApprovals: (...args: ExtractArgs<Contract['calls']['checkVaultApprovals']>) =>
    getRequest('checkVaultApprovals', args),
  getVaultConfig: (...args: ExtractArgs<Contract['calls']['getVaultConfig']>) => getRequest('getVaultConfig', args),
  getVaultConfigByAddr: (...args: ExtractArgs<Contract['calls']['getVaultConfigByAddr']>) =>
    getRequest('getVaultConfigByAddr', args),
  getVaultActionDataBundle: (...args: ExtractArgs<Contract['calls']['getVaultActionDataBundle']>) =>
    getRequest('getVaultActionDataBundle', args),
  getVaultActionDataWithFrozenStatus: (...args: ExtractArgs<Contract['calls']['getVaultActionDataWithFrozenStatus']>) =>
    getRequest('getVaultActionDataWithFrozenStatus', args),
  getLegoDataFromVaultToken: (...args: ExtractArgs<Contract['calls']['getLegoDataFromVaultToken']>) =>
    getRequest('getLegoDataFromVaultToken', args),
  getLegoAddrFromVaultToken: (...args: ExtractArgs<Contract['calls']['getLegoAddrFromVaultToken']>) =>
    getRequest('getLegoAddrFromVaultToken', args),
  getDepositConfig: (...args: ExtractArgs<Contract['calls']['getDepositConfig']>) =>
    getRequest('getDepositConfig', args),
  vaultConfigs: (...args: ExtractArgs<Contract['calls']['vaultConfigs']>) => getRequest('vaultConfigs', args),
  isApprovedVaultToken: (...args: ExtractArgs<Contract['calls']['isApprovedVaultToken']>) =>
    getRequest('isApprovedVaultToken', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'VaultRegistry' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'VaultRegistry'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  startGovernanceChange: getMutation('startGovernanceChange'),
  confirmGovernanceChange: getMutation('confirmGovernanceChange'),
  cancelGovernanceChange: getMutation('cancelGovernanceChange'),
  relinquishGov: getMutation('relinquishGov'),
  setGovTimeLock: getMutation('setGovTimeLock'),
  finishUndyHqSetup: getMutation('finishUndyHqSetup'),
  setRegistryTimeLock: getMutation('setRegistryTimeLock'),
  setRegistryTimeLockAfterSetup: getMutation('setRegistryTimeLockAfterSetup'),
  pause: getMutation('pause'),
  recoverFunds: getMutation('recoverFunds'),
  recoverFundsMany: getMutation('recoverFundsMany'),
  startAddNewAddressToRegistry: getMutation('startAddNewAddressToRegistry'),
  confirmNewAddressToRegistry: getMutation('confirmNewAddressToRegistry'),
  cancelNewAddressToRegistry: getMutation('cancelNewAddressToRegistry'),
  setCanDeposit: getMutation('setCanDeposit'),
  setCanWithdraw: getMutation('setCanWithdraw'),
  setMaxDepositAmount: getMutation('setMaxDepositAmount'),
  setVaultOpsFrozen: getMutation('setVaultOpsFrozen'),
  setShouldAutoDeposit: getMutation('setShouldAutoDeposit'),
  setMinYieldWithdrawAmount: getMutation('setMinYieldWithdrawAmount'),
  setApprovedVaultToken: getMutation('setApprovedVaultToken'),
  setDefaultTargetVaultToken: getMutation('setDefaultTargetVaultToken'),
  setPerformanceFee: getMutation('setPerformanceFee'),
  setRedemptionBuffer: getMutation('setRedemptionBuffer'),
}

export type SDK = {
  deployAddress: Address | undefined
  abi: typeof abi
  getUndyHqFromGov: (
    ...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>
  ) => Promise<CallReturn<'getUndyHqFromGov'>>
  canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) => Promise<CallReturn<'canGovern'>>
  getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) => Promise<CallReturn<'getGovernors'>>
  hasPendingGovChange: (
    ...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>
  ) => Promise<CallReturn<'hasPendingGovChange'>>
  isValidGovTimeLock: (
    ...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>
  ) => Promise<CallReturn<'isValidGovTimeLock'>>
  minGovChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>
  ) => Promise<CallReturn<'minGovChangeTimeLock'>>
  maxGovChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>
  ) => Promise<CallReturn<'maxGovChangeTimeLock'>>
  governance: (...args: ExtractArgs<Contract['calls']['governance']>) => Promise<CallReturn<'governance'>>
  pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) => Promise<CallReturn<'pendingGov'>>
  numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) => Promise<CallReturn<'numGovChanges'>>
  govChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>
  ) => Promise<CallReturn<'govChangeTimeLock'>>
  getRegistryDescription: (
    ...args: ExtractArgs<Contract['calls']['getRegistryDescription']>
  ) => Promise<CallReturn<'getRegistryDescription'>>
  isValidNewAddress: (
    ...args: ExtractArgs<Contract['calls']['isValidNewAddress']>
  ) => Promise<CallReturn<'isValidNewAddress'>>
  isValidAddressUpdate: (
    ...args: ExtractArgs<Contract['calls']['isValidAddressUpdate']>
  ) => Promise<CallReturn<'isValidAddressUpdate'>>
  isValidAddressDisable: (
    ...args: ExtractArgs<Contract['calls']['isValidAddressDisable']>
  ) => Promise<CallReturn<'isValidAddressDisable'>>
  isValidRegistryTimeLock: (
    ...args: ExtractArgs<Contract['calls']['isValidRegistryTimeLock']>
  ) => Promise<CallReturn<'isValidRegistryTimeLock'>>
  minRegistryTimeLock: (
    ...args: ExtractArgs<Contract['calls']['minRegistryTimeLock']>
  ) => Promise<CallReturn<'minRegistryTimeLock'>>
  maxRegistryTimeLock: (
    ...args: ExtractArgs<Contract['calls']['maxRegistryTimeLock']>
  ) => Promise<CallReturn<'maxRegistryTimeLock'>>
  isValidAddr: (...args: ExtractArgs<Contract['calls']['isValidAddr']>) => Promise<CallReturn<'isValidAddr'>>
  isValidRegId: (...args: ExtractArgs<Contract['calls']['isValidRegId']>) => Promise<CallReturn<'isValidRegId'>>
  getRegId: (...args: ExtractArgs<Contract['calls']['getRegId']>) => Promise<CallReturn<'getRegId'>>
  getAddr: (...args: ExtractArgs<Contract['calls']['getAddr']>) => Promise<CallReturn<'getAddr'>>
  getAddrInfo: (...args: ExtractArgs<Contract['calls']['getAddrInfo']>) => Promise<CallReturn<'getAddrInfo'>>
  getAddrDescription: (
    ...args: ExtractArgs<Contract['calls']['getAddrDescription']>
  ) => Promise<CallReturn<'getAddrDescription'>>
  getNumAddrs: (...args: ExtractArgs<Contract['calls']['getNumAddrs']>) => Promise<CallReturn<'getNumAddrs'>>
  getLastAddr: (...args: ExtractArgs<Contract['calls']['getLastAddr']>) => Promise<CallReturn<'getLastAddr'>>
  getLastRegId: (...args: ExtractArgs<Contract['calls']['getLastRegId']>) => Promise<CallReturn<'getLastRegId'>>
  registryChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['registryChangeTimeLock']>
  ) => Promise<CallReturn<'registryChangeTimeLock'>>
  addrInfo: (...args: ExtractArgs<Contract['calls']['addrInfo']>) => Promise<CallReturn<'addrInfo'>>
  addrToRegId: (...args: ExtractArgs<Contract['calls']['addrToRegId']>) => Promise<CallReturn<'addrToRegId'>>
  numAddrs: (...args: ExtractArgs<Contract['calls']['numAddrs']>) => Promise<CallReturn<'numAddrs'>>
  pendingNewAddr: (...args: ExtractArgs<Contract['calls']['pendingNewAddr']>) => Promise<CallReturn<'pendingNewAddr'>>
  pendingAddrUpdate: (
    ...args: ExtractArgs<Contract['calls']['pendingAddrUpdate']>
  ) => Promise<CallReturn<'pendingAddrUpdate'>>
  pendingAddrDisable: (
    ...args: ExtractArgs<Contract['calls']['pendingAddrDisable']>
  ) => Promise<CallReturn<'pendingAddrDisable'>>
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => Promise<CallReturn<'getAddys'>>
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => Promise<CallReturn<'getUndyHq'>>
  canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) => Promise<CallReturn<'canMintUndy'>>
  isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) => Promise<CallReturn<'isPaused'>>
  isEarnVault: (...args: ExtractArgs<Contract['calls']['isEarnVault']>) => Promise<CallReturn<'isEarnVault'>>
  isValidVaultToken: (
    ...args: ExtractArgs<Contract['calls']['isValidVaultToken']>
  ) => Promise<CallReturn<'isValidVaultToken'>>
  isValidDefaultTargetVaultToken: (
    ...args: ExtractArgs<Contract['calls']['isValidDefaultTargetVaultToken']>
  ) => Promise<CallReturn<'isValidDefaultTargetVaultToken'>>
  isValidPerformanceFee: (
    ...args: ExtractArgs<Contract['calls']['isValidPerformanceFee']>
  ) => Promise<CallReturn<'isValidPerformanceFee'>>
  isValidRedemptionBuffer: (
    ...args: ExtractArgs<Contract['calls']['isValidRedemptionBuffer']>
  ) => Promise<CallReturn<'isValidRedemptionBuffer'>>
  canDeposit: (...args: ExtractArgs<Contract['calls']['canDeposit']>) => Promise<CallReturn<'canDeposit'>>
  canWithdraw: (...args: ExtractArgs<Contract['calls']['canWithdraw']>) => Promise<CallReturn<'canWithdraw'>>
  maxDepositAmount: (
    ...args: ExtractArgs<Contract['calls']['maxDepositAmount']>
  ) => Promise<CallReturn<'maxDepositAmount'>>
  isVaultOpsFrozen: (
    ...args: ExtractArgs<Contract['calls']['isVaultOpsFrozen']>
  ) => Promise<CallReturn<'isVaultOpsFrozen'>>
  redemptionBuffer: (
    ...args: ExtractArgs<Contract['calls']['redemptionBuffer']>
  ) => Promise<CallReturn<'redemptionBuffer'>>
  minYieldWithdrawAmount: (
    ...args: ExtractArgs<Contract['calls']['minYieldWithdrawAmount']>
  ) => Promise<CallReturn<'minYieldWithdrawAmount'>>
  redemptionConfig: (
    ...args: ExtractArgs<Contract['calls']['redemptionConfig']>
  ) => Promise<CallReturn<'redemptionConfig'>>
  getPerformanceFee: (
    ...args: ExtractArgs<Contract['calls']['getPerformanceFee']>
  ) => Promise<CallReturn<'getPerformanceFee'>>
  getDefaultTargetVaultToken: (
    ...args: ExtractArgs<Contract['calls']['getDefaultTargetVaultToken']>
  ) => Promise<CallReturn<'getDefaultTargetVaultToken'>>
  shouldAutoDeposit: (
    ...args: ExtractArgs<Contract['calls']['shouldAutoDeposit']>
  ) => Promise<CallReturn<'shouldAutoDeposit'>>
  isApprovedVaultTokenByAddr: (
    ...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenByAddr']>
  ) => Promise<CallReturn<'isApprovedVaultTokenByAddr'>>
  checkVaultApprovals: (
    ...args: ExtractArgs<Contract['calls']['checkVaultApprovals']>
  ) => Promise<CallReturn<'checkVaultApprovals'>>
  getVaultConfig: (...args: ExtractArgs<Contract['calls']['getVaultConfig']>) => Promise<CallReturn<'getVaultConfig'>>
  getVaultConfigByAddr: (
    ...args: ExtractArgs<Contract['calls']['getVaultConfigByAddr']>
  ) => Promise<CallReturn<'getVaultConfigByAddr'>>
  getVaultActionDataBundle: (
    ...args: ExtractArgs<Contract['calls']['getVaultActionDataBundle']>
  ) => Promise<CallReturn<'getVaultActionDataBundle'>>
  getVaultActionDataWithFrozenStatus: (
    ...args: ExtractArgs<Contract['calls']['getVaultActionDataWithFrozenStatus']>
  ) => Promise<CallReturn<'getVaultActionDataWithFrozenStatus'>>
  getLegoDataFromVaultToken: (
    ...args: ExtractArgs<Contract['calls']['getLegoDataFromVaultToken']>
  ) => Promise<CallReturn<'getLegoDataFromVaultToken'>>
  getLegoAddrFromVaultToken: (
    ...args: ExtractArgs<Contract['calls']['getLegoAddrFromVaultToken']>
  ) => Promise<CallReturn<'getLegoAddrFromVaultToken'>>
  getDepositConfig: (
    ...args: ExtractArgs<Contract['calls']['getDepositConfig']>
  ) => Promise<CallReturn<'getDepositConfig'>>
  vaultConfigs: (...args: ExtractArgs<Contract['calls']['vaultConfigs']>) => Promise<CallReturn<'vaultConfigs'>>
  isApprovedVaultToken: (
    ...args: ExtractArgs<Contract['calls']['isApprovedVaultToken']>
  ) => Promise<CallReturn<'isApprovedVaultToken'>>
  startGovernanceChange: (...args: ExtractArgs<Contract['mutations']['startGovernanceChange']>) => Promise<Address>
  confirmGovernanceChange: (...args: ExtractArgs<Contract['mutations']['confirmGovernanceChange']>) => Promise<Address>
  cancelGovernanceChange: (...args: ExtractArgs<Contract['mutations']['cancelGovernanceChange']>) => Promise<Address>
  relinquishGov: (...args: ExtractArgs<Contract['mutations']['relinquishGov']>) => Promise<Address>
  setGovTimeLock: (...args: ExtractArgs<Contract['mutations']['setGovTimeLock']>) => Promise<Address>
  finishUndyHqSetup: (...args: ExtractArgs<Contract['mutations']['finishUndyHqSetup']>) => Promise<Address>
  setRegistryTimeLock: (...args: ExtractArgs<Contract['mutations']['setRegistryTimeLock']>) => Promise<Address>
  setRegistryTimeLockAfterSetup: (
    ...args: ExtractArgs<Contract['mutations']['setRegistryTimeLockAfterSetup']>
  ) => Promise<Address>
  pause: (...args: ExtractArgs<Contract['mutations']['pause']>) => Promise<Address>
  recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) => Promise<Address>
  recoverFundsMany: (...args: ExtractArgs<Contract['mutations']['recoverFundsMany']>) => Promise<Address>
  startAddNewAddressToRegistry: (
    ...args: ExtractArgs<Contract['mutations']['startAddNewAddressToRegistry']>
  ) => Promise<Address>
  confirmNewAddressToRegistry: (
    ...args: ExtractArgs<Contract['mutations']['confirmNewAddressToRegistry']>
  ) => Promise<Address>
  cancelNewAddressToRegistry: (
    ...args: ExtractArgs<Contract['mutations']['cancelNewAddressToRegistry']>
  ) => Promise<Address>
  setCanDeposit: (...args: ExtractArgs<Contract['mutations']['setCanDeposit']>) => Promise<Address>
  setCanWithdraw: (...args: ExtractArgs<Contract['mutations']['setCanWithdraw']>) => Promise<Address>
  setMaxDepositAmount: (...args: ExtractArgs<Contract['mutations']['setMaxDepositAmount']>) => Promise<Address>
  setVaultOpsFrozen: (...args: ExtractArgs<Contract['mutations']['setVaultOpsFrozen']>) => Promise<Address>
  setShouldAutoDeposit: (...args: ExtractArgs<Contract['mutations']['setShouldAutoDeposit']>) => Promise<Address>
  setMinYieldWithdrawAmount: (
    ...args: ExtractArgs<Contract['mutations']['setMinYieldWithdrawAmount']>
  ) => Promise<Address>
  setApprovedVaultToken: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultToken']>) => Promise<Address>
  setDefaultTargetVaultToken: (
    ...args: ExtractArgs<Contract['mutations']['setDefaultTargetVaultToken']>
  ) => Promise<Address>
  setPerformanceFee: (...args: ExtractArgs<Contract['mutations']['setPerformanceFee']>) => Promise<Address>
  setRedemptionBuffer: (...args: ExtractArgs<Contract['mutations']['setRedemptionBuffer']>) => Promise<Address>
}

export function toSdk(publicClient?: PublicClient, walletClient?: WalletClient): SDK {
  return {
    deployAddress,
    abi,
    // Queries
    getUndyHqFromGov: (...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>) =>
      singleQuery(publicClient!, call.getUndyHqFromGov(...args)) as Promise<CallReturn<'getUndyHqFromGov'>>,
    canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) =>
      singleQuery(publicClient!, call.canGovern(...args)) as Promise<CallReturn<'canGovern'>>,
    getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) =>
      singleQuery(publicClient!, call.getGovernors(...args)) as Promise<CallReturn<'getGovernors'>>,
    hasPendingGovChange: (...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>) =>
      singleQuery(publicClient!, call.hasPendingGovChange(...args)) as Promise<CallReturn<'hasPendingGovChange'>>,
    isValidGovTimeLock: (...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>) =>
      singleQuery(publicClient!, call.isValidGovTimeLock(...args)) as Promise<CallReturn<'isValidGovTimeLock'>>,
    minGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>) =>
      singleQuery(publicClient!, call.minGovChangeTimeLock(...args)) as Promise<CallReturn<'minGovChangeTimeLock'>>,
    maxGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>) =>
      singleQuery(publicClient!, call.maxGovChangeTimeLock(...args)) as Promise<CallReturn<'maxGovChangeTimeLock'>>,
    governance: (...args: ExtractArgs<Contract['calls']['governance']>) =>
      singleQuery(publicClient!, call.governance(...args)) as Promise<CallReturn<'governance'>>,
    pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) =>
      singleQuery(publicClient!, call.pendingGov(...args)) as Promise<CallReturn<'pendingGov'>>,
    numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) =>
      singleQuery(publicClient!, call.numGovChanges(...args)) as Promise<CallReturn<'numGovChanges'>>,
    govChangeTimeLock: (...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>) =>
      singleQuery(publicClient!, call.govChangeTimeLock(...args)) as Promise<CallReturn<'govChangeTimeLock'>>,
    getRegistryDescription: (...args: ExtractArgs<Contract['calls']['getRegistryDescription']>) =>
      singleQuery(publicClient!, call.getRegistryDescription(...args)) as Promise<CallReturn<'getRegistryDescription'>>,
    isValidNewAddress: (...args: ExtractArgs<Contract['calls']['isValidNewAddress']>) =>
      singleQuery(publicClient!, call.isValidNewAddress(...args)) as Promise<CallReturn<'isValidNewAddress'>>,
    isValidAddressUpdate: (...args: ExtractArgs<Contract['calls']['isValidAddressUpdate']>) =>
      singleQuery(publicClient!, call.isValidAddressUpdate(...args)) as Promise<CallReturn<'isValidAddressUpdate'>>,
    isValidAddressDisable: (...args: ExtractArgs<Contract['calls']['isValidAddressDisable']>) =>
      singleQuery(publicClient!, call.isValidAddressDisable(...args)) as Promise<CallReturn<'isValidAddressDisable'>>,
    isValidRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['isValidRegistryTimeLock']>) =>
      singleQuery(publicClient!, call.isValidRegistryTimeLock(...args)) as Promise<
        CallReturn<'isValidRegistryTimeLock'>
      >,
    minRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['minRegistryTimeLock']>) =>
      singleQuery(publicClient!, call.minRegistryTimeLock(...args)) as Promise<CallReturn<'minRegistryTimeLock'>>,
    maxRegistryTimeLock: (...args: ExtractArgs<Contract['calls']['maxRegistryTimeLock']>) =>
      singleQuery(publicClient!, call.maxRegistryTimeLock(...args)) as Promise<CallReturn<'maxRegistryTimeLock'>>,
    isValidAddr: (...args: ExtractArgs<Contract['calls']['isValidAddr']>) =>
      singleQuery(publicClient!, call.isValidAddr(...args)) as Promise<CallReturn<'isValidAddr'>>,
    isValidRegId: (...args: ExtractArgs<Contract['calls']['isValidRegId']>) =>
      singleQuery(publicClient!, call.isValidRegId(...args)) as Promise<CallReturn<'isValidRegId'>>,
    getRegId: (...args: ExtractArgs<Contract['calls']['getRegId']>) =>
      singleQuery(publicClient!, call.getRegId(...args)) as Promise<CallReturn<'getRegId'>>,
    getAddr: (...args: ExtractArgs<Contract['calls']['getAddr']>) =>
      singleQuery(publicClient!, call.getAddr(...args)) as Promise<CallReturn<'getAddr'>>,
    getAddrInfo: (...args: ExtractArgs<Contract['calls']['getAddrInfo']>) =>
      singleQuery(publicClient!, call.getAddrInfo(...args)) as Promise<CallReturn<'getAddrInfo'>>,
    getAddrDescription: (...args: ExtractArgs<Contract['calls']['getAddrDescription']>) =>
      singleQuery(publicClient!, call.getAddrDescription(...args)) as Promise<CallReturn<'getAddrDescription'>>,
    getNumAddrs: (...args: ExtractArgs<Contract['calls']['getNumAddrs']>) =>
      singleQuery(publicClient!, call.getNumAddrs(...args)) as Promise<CallReturn<'getNumAddrs'>>,
    getLastAddr: (...args: ExtractArgs<Contract['calls']['getLastAddr']>) =>
      singleQuery(publicClient!, call.getLastAddr(...args)) as Promise<CallReturn<'getLastAddr'>>,
    getLastRegId: (...args: ExtractArgs<Contract['calls']['getLastRegId']>) =>
      singleQuery(publicClient!, call.getLastRegId(...args)) as Promise<CallReturn<'getLastRegId'>>,
    registryChangeTimeLock: (...args: ExtractArgs<Contract['calls']['registryChangeTimeLock']>) =>
      singleQuery(publicClient!, call.registryChangeTimeLock(...args)) as Promise<CallReturn<'registryChangeTimeLock'>>,
    addrInfo: (...args: ExtractArgs<Contract['calls']['addrInfo']>) =>
      singleQuery(publicClient!, call.addrInfo(...args)) as Promise<CallReturn<'addrInfo'>>,
    addrToRegId: (...args: ExtractArgs<Contract['calls']['addrToRegId']>) =>
      singleQuery(publicClient!, call.addrToRegId(...args)) as Promise<CallReturn<'addrToRegId'>>,
    numAddrs: (...args: ExtractArgs<Contract['calls']['numAddrs']>) =>
      singleQuery(publicClient!, call.numAddrs(...args)) as Promise<CallReturn<'numAddrs'>>,
    pendingNewAddr: (...args: ExtractArgs<Contract['calls']['pendingNewAddr']>) =>
      singleQuery(publicClient!, call.pendingNewAddr(...args)) as Promise<CallReturn<'pendingNewAddr'>>,
    pendingAddrUpdate: (...args: ExtractArgs<Contract['calls']['pendingAddrUpdate']>) =>
      singleQuery(publicClient!, call.pendingAddrUpdate(...args)) as Promise<CallReturn<'pendingAddrUpdate'>>,
    pendingAddrDisable: (...args: ExtractArgs<Contract['calls']['pendingAddrDisable']>) =>
      singleQuery(publicClient!, call.pendingAddrDisable(...args)) as Promise<CallReturn<'pendingAddrDisable'>>,
    getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) =>
      singleQuery(publicClient!, call.getAddys(...args)) as Promise<CallReturn<'getAddys'>>,
    getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) =>
      singleQuery(publicClient!, call.getUndyHq(...args)) as Promise<CallReturn<'getUndyHq'>>,
    canMintUndy: (...args: ExtractArgs<Contract['calls']['canMintUndy']>) =>
      singleQuery(publicClient!, call.canMintUndy(...args)) as Promise<CallReturn<'canMintUndy'>>,
    isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) =>
      singleQuery(publicClient!, call.isPaused(...args)) as Promise<CallReturn<'isPaused'>>,
    isEarnVault: (...args: ExtractArgs<Contract['calls']['isEarnVault']>) =>
      singleQuery(publicClient!, call.isEarnVault(...args)) as Promise<CallReturn<'isEarnVault'>>,
    isValidVaultToken: (...args: ExtractArgs<Contract['calls']['isValidVaultToken']>) =>
      singleQuery(publicClient!, call.isValidVaultToken(...args)) as Promise<CallReturn<'isValidVaultToken'>>,
    isValidDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['isValidDefaultTargetVaultToken']>) =>
      singleQuery(publicClient!, call.isValidDefaultTargetVaultToken(...args)) as Promise<
        CallReturn<'isValidDefaultTargetVaultToken'>
      >,
    isValidPerformanceFee: (...args: ExtractArgs<Contract['calls']['isValidPerformanceFee']>) =>
      singleQuery(publicClient!, call.isValidPerformanceFee(...args)) as Promise<CallReturn<'isValidPerformanceFee'>>,
    isValidRedemptionBuffer: (...args: ExtractArgs<Contract['calls']['isValidRedemptionBuffer']>) =>
      singleQuery(publicClient!, call.isValidRedemptionBuffer(...args)) as Promise<
        CallReturn<'isValidRedemptionBuffer'>
      >,
    canDeposit: (...args: ExtractArgs<Contract['calls']['canDeposit']>) =>
      singleQuery(publicClient!, call.canDeposit(...args)) as Promise<CallReturn<'canDeposit'>>,
    canWithdraw: (...args: ExtractArgs<Contract['calls']['canWithdraw']>) =>
      singleQuery(publicClient!, call.canWithdraw(...args)) as Promise<CallReturn<'canWithdraw'>>,
    maxDepositAmount: (...args: ExtractArgs<Contract['calls']['maxDepositAmount']>) =>
      singleQuery(publicClient!, call.maxDepositAmount(...args)) as Promise<CallReturn<'maxDepositAmount'>>,
    isVaultOpsFrozen: (...args: ExtractArgs<Contract['calls']['isVaultOpsFrozen']>) =>
      singleQuery(publicClient!, call.isVaultOpsFrozen(...args)) as Promise<CallReturn<'isVaultOpsFrozen'>>,
    redemptionBuffer: (...args: ExtractArgs<Contract['calls']['redemptionBuffer']>) =>
      singleQuery(publicClient!, call.redemptionBuffer(...args)) as Promise<CallReturn<'redemptionBuffer'>>,
    minYieldWithdrawAmount: (...args: ExtractArgs<Contract['calls']['minYieldWithdrawAmount']>) =>
      singleQuery(publicClient!, call.minYieldWithdrawAmount(...args)) as Promise<CallReturn<'minYieldWithdrawAmount'>>,
    redemptionConfig: (...args: ExtractArgs<Contract['calls']['redemptionConfig']>) =>
      singleQuery(publicClient!, call.redemptionConfig(...args)) as Promise<CallReturn<'redemptionConfig'>>,
    getPerformanceFee: (...args: ExtractArgs<Contract['calls']['getPerformanceFee']>) =>
      singleQuery(publicClient!, call.getPerformanceFee(...args)) as Promise<CallReturn<'getPerformanceFee'>>,
    getDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['getDefaultTargetVaultToken']>) =>
      singleQuery(publicClient!, call.getDefaultTargetVaultToken(...args)) as Promise<
        CallReturn<'getDefaultTargetVaultToken'>
      >,
    shouldAutoDeposit: (...args: ExtractArgs<Contract['calls']['shouldAutoDeposit']>) =>
      singleQuery(publicClient!, call.shouldAutoDeposit(...args)) as Promise<CallReturn<'shouldAutoDeposit'>>,
    isApprovedVaultTokenByAddr: (...args: ExtractArgs<Contract['calls']['isApprovedVaultTokenByAddr']>) =>
      singleQuery(publicClient!, call.isApprovedVaultTokenByAddr(...args)) as Promise<
        CallReturn<'isApprovedVaultTokenByAddr'>
      >,
    checkVaultApprovals: (...args: ExtractArgs<Contract['calls']['checkVaultApprovals']>) =>
      singleQuery(publicClient!, call.checkVaultApprovals(...args)) as Promise<CallReturn<'checkVaultApprovals'>>,
    getVaultConfig: (...args: ExtractArgs<Contract['calls']['getVaultConfig']>) =>
      singleQuery(publicClient!, call.getVaultConfig(...args)) as Promise<CallReturn<'getVaultConfig'>>,
    getVaultConfigByAddr: (...args: ExtractArgs<Contract['calls']['getVaultConfigByAddr']>) =>
      singleQuery(publicClient!, call.getVaultConfigByAddr(...args)) as Promise<CallReturn<'getVaultConfigByAddr'>>,
    getVaultActionDataBundle: (...args: ExtractArgs<Contract['calls']['getVaultActionDataBundle']>) =>
      singleQuery(publicClient!, call.getVaultActionDataBundle(...args)) as Promise<
        CallReturn<'getVaultActionDataBundle'>
      >,
    getVaultActionDataWithFrozenStatus: (
      ...args: ExtractArgs<Contract['calls']['getVaultActionDataWithFrozenStatus']>
    ) =>
      singleQuery(publicClient!, call.getVaultActionDataWithFrozenStatus(...args)) as Promise<
        CallReturn<'getVaultActionDataWithFrozenStatus'>
      >,
    getLegoDataFromVaultToken: (...args: ExtractArgs<Contract['calls']['getLegoDataFromVaultToken']>) =>
      singleQuery(publicClient!, call.getLegoDataFromVaultToken(...args)) as Promise<
        CallReturn<'getLegoDataFromVaultToken'>
      >,
    getLegoAddrFromVaultToken: (...args: ExtractArgs<Contract['calls']['getLegoAddrFromVaultToken']>) =>
      singleQuery(publicClient!, call.getLegoAddrFromVaultToken(...args)) as Promise<
        CallReturn<'getLegoAddrFromVaultToken'>
      >,
    getDepositConfig: (...args: ExtractArgs<Contract['calls']['getDepositConfig']>) =>
      singleQuery(publicClient!, call.getDepositConfig(...args)) as Promise<CallReturn<'getDepositConfig'>>,
    vaultConfigs: (...args: ExtractArgs<Contract['calls']['vaultConfigs']>) =>
      singleQuery(publicClient!, call.vaultConfigs(...args)) as Promise<CallReturn<'vaultConfigs'>>,
    isApprovedVaultToken: (...args: ExtractArgs<Contract['calls']['isApprovedVaultToken']>) =>
      singleQuery(publicClient!, call.isApprovedVaultToken(...args)) as Promise<CallReturn<'isApprovedVaultToken'>>,

    // Mutations
    startGovernanceChange: (...args: ExtractArgs<Contract['mutations']['startGovernanceChange']>) =>
      mutate(walletClient!, mutation.startGovernanceChange)(...args),
    confirmGovernanceChange: (...args: ExtractArgs<Contract['mutations']['confirmGovernanceChange']>) =>
      mutate(walletClient!, mutation.confirmGovernanceChange)(...args),
    cancelGovernanceChange: (...args: ExtractArgs<Contract['mutations']['cancelGovernanceChange']>) =>
      mutate(walletClient!, mutation.cancelGovernanceChange)(...args),
    relinquishGov: (...args: ExtractArgs<Contract['mutations']['relinquishGov']>) =>
      mutate(walletClient!, mutation.relinquishGov)(...args),
    setGovTimeLock: (...args: ExtractArgs<Contract['mutations']['setGovTimeLock']>) =>
      mutate(walletClient!, mutation.setGovTimeLock)(...args),
    finishUndyHqSetup: (...args: ExtractArgs<Contract['mutations']['finishUndyHqSetup']>) =>
      mutate(walletClient!, mutation.finishUndyHqSetup)(...args),
    setRegistryTimeLock: (...args: ExtractArgs<Contract['mutations']['setRegistryTimeLock']>) =>
      mutate(walletClient!, mutation.setRegistryTimeLock)(...args),
    setRegistryTimeLockAfterSetup: (...args: ExtractArgs<Contract['mutations']['setRegistryTimeLockAfterSetup']>) =>
      mutate(walletClient!, mutation.setRegistryTimeLockAfterSetup)(...args),
    pause: (...args: ExtractArgs<Contract['mutations']['pause']>) => mutate(walletClient!, mutation.pause)(...args),
    recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) =>
      mutate(walletClient!, mutation.recoverFunds)(...args),
    recoverFundsMany: (...args: ExtractArgs<Contract['mutations']['recoverFundsMany']>) =>
      mutate(walletClient!, mutation.recoverFundsMany)(...args),
    startAddNewAddressToRegistry: (...args: ExtractArgs<Contract['mutations']['startAddNewAddressToRegistry']>) =>
      mutate(walletClient!, mutation.startAddNewAddressToRegistry)(...args),
    confirmNewAddressToRegistry: (...args: ExtractArgs<Contract['mutations']['confirmNewAddressToRegistry']>) =>
      mutate(walletClient!, mutation.confirmNewAddressToRegistry)(...args),
    cancelNewAddressToRegistry: (...args: ExtractArgs<Contract['mutations']['cancelNewAddressToRegistry']>) =>
      mutate(walletClient!, mutation.cancelNewAddressToRegistry)(...args),
    setCanDeposit: (...args: ExtractArgs<Contract['mutations']['setCanDeposit']>) =>
      mutate(walletClient!, mutation.setCanDeposit)(...args),
    setCanWithdraw: (...args: ExtractArgs<Contract['mutations']['setCanWithdraw']>) =>
      mutate(walletClient!, mutation.setCanWithdraw)(...args),
    setMaxDepositAmount: (...args: ExtractArgs<Contract['mutations']['setMaxDepositAmount']>) =>
      mutate(walletClient!, mutation.setMaxDepositAmount)(...args),
    setVaultOpsFrozen: (...args: ExtractArgs<Contract['mutations']['setVaultOpsFrozen']>) =>
      mutate(walletClient!, mutation.setVaultOpsFrozen)(...args),
    setShouldAutoDeposit: (...args: ExtractArgs<Contract['mutations']['setShouldAutoDeposit']>) =>
      mutate(walletClient!, mutation.setShouldAutoDeposit)(...args),
    setMinYieldWithdrawAmount: (...args: ExtractArgs<Contract['mutations']['setMinYieldWithdrawAmount']>) =>
      mutate(walletClient!, mutation.setMinYieldWithdrawAmount)(...args),
    setApprovedVaultToken: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultToken']>) =>
      mutate(walletClient!, mutation.setApprovedVaultToken)(...args),
    setDefaultTargetVaultToken: (...args: ExtractArgs<Contract['mutations']['setDefaultTargetVaultToken']>) =>
      mutate(walletClient!, mutation.setDefaultTargetVaultToken)(...args),
    setPerformanceFee: (...args: ExtractArgs<Contract['mutations']['setPerformanceFee']>) =>
      mutate(walletClient!, mutation.setPerformanceFee)(...args),
    setRedemptionBuffer: (...args: ExtractArgs<Contract['mutations']['setRedemptionBuffer']>) =>
      mutate(walletClient!, mutation.setRedemptionBuffer)(...args),
  }
}
