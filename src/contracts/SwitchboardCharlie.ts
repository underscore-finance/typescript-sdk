/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate, AddressResolverFunction } from '@dappql/async'
import {
  encodeEventTopics,
  parseEventLogs,
  ParseEventLogsReturnType,
  Log,
  RpcLog,
  PublicClient,
  WalletClient,
} from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    name: 'PendingRedemptionBufferChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'buffer',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'RedemptionBufferSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'buffer',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingMinYieldWithdrawAmountChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'MinYieldWithdrawAmountSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingSnapShotPriceConfigChange',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'minSnapshotDelay',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'maxNumSnapshots',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'maxUpsideDeviation',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'staleTime',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'SnapShotPriceConfigSet',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'legoAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'minSnapshotDelay',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'maxNumSnapshots',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'maxUpsideDeviation',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'staleTime',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingApprovedVaultTokenChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isApproved',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ApprovedVaultTokenSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isApproved',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingApprovedVaultTokensChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'numTokens',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'isApproved',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ApprovedVaultTokensSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'numTokens',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'isApproved',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingPerformanceFeeChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'performanceFee',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PerformanceFeeSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'performanceFee',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingDefaultTargetVaultTokenChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'targetVaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'DefaultTargetVaultTokenSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'targetVaultToken',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingMaxDepositAmountChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'maxDepositAmount',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'MaxDepositAmountSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'maxDepositAmount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingIsLeveragedVaultChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isLeveragedVault',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'IsLeveragedVaultSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isLeveragedVault',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'CanDepositSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'canDeposit',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'CanWithdrawSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'canWithdraw',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'VaultOpsFrozenSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isFrozen',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ShouldAutoDepositSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'shouldAutoDeposit',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ShouldEnforceAllowlistSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'shouldEnforce',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AllowlistUserSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'user',
        type: 'address',
        indexed: true,
      },
      {
        name: 'isAllowed',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AllowlistBatchSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'numUsers',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'isAllowed',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingCollateralVaultChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'ripeVaultId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'legoId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'shouldMaxWithdraw',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'CollateralVaultSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'ripeVaultId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'legoId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingLeverageVaultChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'legoId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'ripeVaultId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'shouldMaxWithdraw',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'LeverageVaultSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'legoId',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'ripeVaultId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingSlippagesChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'usdcSlippage',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'greenSlippage',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'SlippagesSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'usdcSlippage',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'greenSlippage',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingLevgVaultHelperChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'levgVaultHelper',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'LevgVaultHelperSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'levgVaultHelper',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingMaxDebtRatioChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'ratio',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'MaxDebtRatioSet',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'ratio',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingAddManagerChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'manager',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ManagerAdded',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'manager',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingRemoveManagerChange',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'manager',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ManagerRemoved',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'manager',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PriceSnapshotAdded',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'legoAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'success',
        type: 'bool',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'YieldPositionUpdated',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PerformanceFeesClaimed',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingRegisterVaultTokenOnLegoChange',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'VaultTokenRegisteredOnLego',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'legoAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'VaultTokenDeregisteredOnLego',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'legoAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingMorphoRewardsAddrChange',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'rewardsAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'MorphoRewardsAddrSet',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'legoAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'rewardsAddr',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingEulerRewardsAddrChange',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'rewardsAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'EulerRewardsAddrSet',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'legoAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'rewardsAddr',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PendingCompRewardsAddrChange',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'rewardsAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmationBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'actionId',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'CompRewardsAddrSet',
    inputs: [
      {
        name: 'legoId',
        type: 'uint256',
        indexed: true,
      },
      {
        name: 'legoAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'rewardsAddr',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'LeftoversSwept',
    inputs: [
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'caller',
        type: 'address',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeTimeLockModified',
    inputs: [
      {
        name: 'prevTimeLock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'newTimeLock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ExpirationSet',
    inputs: [
      {
        name: 'expiration',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ActionTimeLockSet',
    inputs: [
      {
        name: 'newTimeLock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'prevTimeLock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeStarted',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeConfirmed',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovChangeCancelled',
    inputs: [
      {
        name: 'cancelledGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'GovRelinquished',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'UndyHqSetupFinished',
    inputs: [
      {
        name: 'prevGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newGov',
        type: 'address',
        indexed: true,
      },
      {
        name: 'timeLock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddys',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'hq',
            type: 'address',
          },
          {
            name: 'undyToken',
            type: 'address',
          },
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'switchboard',
            type: 'address',
          },
          {
            name: 'hatchery',
            type: 'address',
          },
          {
            name: 'lootDistributor',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'walletBackpack',
            type: 'address',
          },
          {
            name: 'billing',
            type: 'address',
          },
          {
            name: 'vaultRegistry',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUndyHq',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUndyHqFromGov',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canGovern',
    inputs: [
      {
        name: '_addr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getGovernors',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasPendingGovChange',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'startGovernanceChange',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmGovernanceChange',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cancelGovernanceChange',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'relinquishGov',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setGovTimeLock',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidGovTimeLock',
    inputs: [
      {
        name: '_newTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'minGovChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'maxGovChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'finishUndyHqSetup',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'finishUndyHqSetup',
    inputs: [
      {
        name: '_newGov',
        type: 'address',
      },
      {
        name: '_timeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'governance',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingGov',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'newGov',
            type: 'address',
          },
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numGovChanges',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'govChangeTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canConfirmAction',
    inputs: [
      {
        name: '_actionId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isExpired',
    inputs: [
      {
        name: '_actionId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasPendingAction',
    inputs: [
      {
        name: '_actionId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getActionConfirmationBlock',
    inputs: [
      {
        name: '_actionId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setActionTimeLock',
    inputs: [
      {
        name: '_newTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidActionTimeLock',
    inputs: [
      {
        name: '_newTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'minActionTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'maxActionTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setExpiration',
    inputs: [
      {
        name: '_expiration',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setActionTimeLockAfterSetup',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setActionTimeLockAfterSetup',
    inputs: [
      {
        name: '_newTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingActions',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
          {
            name: 'expiration',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'actionId',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'actionTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'expiration',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setCanDeposit',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_canDeposit',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setCanWithdraw',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_canWithdraw',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setVaultOpsFrozen',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_isFrozen',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setShouldAutoDeposit',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_shouldAutoDeposit',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setShouldEnforceAllowlist',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_shouldEnforce',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setAllowed',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_isAllowed',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setAllowedBatch',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_users',
        type: 'address[]',
      },
      {
        name: '_isAllowed',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addPriceSnapshot',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'deregisterVaultTokenOnLego',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'updateYieldPosition',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimPerformanceFees',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'sweepLeftovers',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setRedemptionBuffer',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_buffer',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setMinYieldWithdrawAmount',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setSnapShotPriceConfig',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_minSnapshotDelay',
        type: 'uint256',
      },
      {
        name: '_maxNumSnapshots',
        type: 'uint256',
      },
      {
        name: '_maxUpsideDeviation',
        type: 'uint256',
      },
      {
        name: '_staleTime',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setApprovedVaultToken',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_isApproved',
        type: 'bool',
      },
      {
        name: '_shouldMaxWithdraw',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setApprovedVaultTokens',
    inputs: [
      {
        name: '_undyVaultAddr',
        type: 'address',
      },
      {
        name: '_vaultTokens',
        type: 'address[]',
      },
      {
        name: '_isApproved',
        type: 'bool',
      },
      {
        name: '_shouldMaxWithdraw',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setPerformanceFee',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_performanceFee',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setDefaultTargetVaultToken',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_targetVaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setMaxDepositAmount',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_maxDepositAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setIsLeveragedVault',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_isLeveragedVault',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setCollateralVault',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_ripeVaultId',
        type: 'uint256',
      },
      {
        name: '_shouldMaxWithdraw',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setLeverageVault',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_ripeVaultId',
        type: 'uint256',
      },
      {
        name: '_shouldMaxWithdraw',
        type: 'bool',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setSlippagesAllowed',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_usdcSlippage',
        type: 'uint256',
      },
      {
        name: '_greenSlippage',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setLevgVaultHelper',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_levgVaultHelper',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setMaxDebtRatio',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_ratio',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addVaultManager',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_manager',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'removeVaultManager',
    inputs: [
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_manager',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'registerVaultTokenOnLego',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setMorphoRewardsAddr',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_rewardsAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setEulerRewardsAddr',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_rewardsAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setCompRewardsAddr',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
      {
        name: '_rewardsAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'executePendingAction',
    inputs: [
      {
        name: '_aid',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cancelPendingAction',
    inputs: [
      {
        name: '_aid',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'actionType',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingRedemptionBuffer',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'buffer',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingMinYieldWithdrawAmount',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingSnapShotPriceConfig',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'config',
            type: 'tuple',
            components: [
              {
                name: 'minSnapshotDelay',
                type: 'uint256',
              },
              {
                name: 'maxNumSnapshots',
                type: 'uint256',
              },
              {
                name: 'maxUpsideDeviation',
                type: 'uint256',
              },
              {
                name: 'staleTime',
                type: 'uint256',
              },
            ],
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingApprovedVaultToken',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'isApproved',
            type: 'bool',
          },
          {
            name: 'shouldMaxWithdraw',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingApprovedVaultTokens',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'vaultTokens',
            type: 'address[]',
          },
          {
            name: 'isApproved',
            type: 'bool',
          },
          {
            name: 'shouldMaxWithdraw',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingPerformanceFee',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'performanceFee',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingDefaultTargetVaultToken',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'targetVaultToken',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingMaxDepositAmount',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'maxDepositAmount',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingIsLeveragedVault',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'isLeveragedVault',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingCollateralVault',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'ripeVaultId',
            type: 'uint256',
          },
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'shouldMaxWithdraw',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingLeverageVault',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'ripeVaultId',
            type: 'uint256',
          },
          {
            name: 'shouldMaxWithdraw',
            type: 'bool',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingSlippages',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'usdcSlippage',
            type: 'uint256',
          },
          {
            name: 'greenSlippage',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingLevgVaultHelper',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'levgVaultHelper',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingMaxDebtRatio',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'ratio',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingAddManager',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'manager',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingRemoveManager',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'vaultAddr',
            type: 'address',
          },
          {
            name: 'manager',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingRegisterVaultTokenOnLego',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingMorphoRewardsAddr',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'rewardsAddr',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingEulerRewardsAddr',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'rewardsAddr',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingCompRewardsAddr',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'rewardsAddr',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'constructor',
    inputs: [
      {
        name: '_undyHq',
        type: 'address',
      },
      {
        name: '_tempGov',
        type: 'address',
      },
      {
        name: '_minConfigTimeLock',
        type: 'uint256',
      },
      {
        name: '_maxConfigTimeLock',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
] as const

export const deployAddress: Address | undefined = '0x7EDa08C6eFE04A204c783D6b35EA67Cf682Da2aE'

export type Contract = {
  calls: {
    getAddys: () => Promise<{
      hq: `0x${string}`
      undyToken: `0x${string}`
      ledger: `0x${string}`
      missionControl: `0x${string}`
      legoBook: `0x${string}`
      switchboard: `0x${string}`
      hatchery: `0x${string}`
      lootDistributor: `0x${string}`
      appraiser: `0x${string}`
      walletBackpack: `0x${string}`
      billing: `0x${string}`
      vaultRegistry: `0x${string}`
    }>
    getUndyHq: () => Promise<`0x${string}`>
    getUndyHqFromGov: () => Promise<`0x${string}`>
    canGovern: (addr: `0x${string}`) => Promise<boolean>
    getGovernors: () => Promise<`0x${string}`[]>
    hasPendingGovChange: () => Promise<boolean>
    isValidGovTimeLock: (newTimeLock: bigint) => Promise<boolean>
    minGovChangeTimeLock: () => Promise<bigint>
    maxGovChangeTimeLock: () => Promise<bigint>
    governance: () => Promise<`0x${string}`>
    pendingGov: () => Promise<{ newGov: `0x${string}`; initiatedBlock: bigint; confirmBlock: bigint }>
    numGovChanges: () => Promise<bigint>
    govChangeTimeLock: () => Promise<bigint>
    canConfirmAction: (actionId: bigint) => Promise<boolean>
    isExpired: (actionId: bigint) => Promise<boolean>
    hasPendingAction: (actionId: bigint) => Promise<boolean>
    getActionConfirmationBlock: (actionId: bigint) => Promise<bigint>
    isValidActionTimeLock: (newTimeLock: bigint) => Promise<boolean>
    minActionTimeLock: () => Promise<bigint>
    maxActionTimeLock: () => Promise<bigint>
    pendingActions: (arg0: bigint) => Promise<{ initiatedBlock: bigint; confirmBlock: bigint; expiration: bigint }>
    actionId: () => Promise<bigint>
    actionTimeLock: () => Promise<bigint>
    expiration: () => Promise<bigint>
    actionType: (arg0: bigint) => Promise<bigint>
    pendingRedemptionBuffer: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; buffer: bigint }>
    pendingMinYieldWithdrawAmount: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; amount: bigint }>
    pendingSnapShotPriceConfig: (
      arg0: bigint,
    ) => Promise<{
      legoId: bigint
      config: { minSnapshotDelay: bigint; maxNumSnapshots: bigint; maxUpsideDeviation: bigint; staleTime: bigint }
    }>
    pendingApprovedVaultToken: (
      arg0: bigint,
    ) => Promise<{
      vaultAddr: `0x${string}`
      vaultToken: `0x${string}`
      isApproved: boolean
      shouldMaxWithdraw: boolean
    }>
    pendingApprovedVaultTokens: (
      arg0: bigint,
    ) => Promise<{
      vaultAddr: `0x${string}`
      vaultTokens: `0x${string}`[]
      isApproved: boolean
      shouldMaxWithdraw: boolean
    }>
    pendingPerformanceFee: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; performanceFee: bigint }>
    pendingDefaultTargetVaultToken: (
      arg0: bigint,
    ) => Promise<{ vaultAddr: `0x${string}`; targetVaultToken: `0x${string}` }>
    pendingMaxDepositAmount: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; maxDepositAmount: bigint }>
    pendingIsLeveragedVault: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; isLeveragedVault: boolean }>
    pendingCollateralVault: (
      arg0: bigint,
    ) => Promise<{
      vaultAddr: `0x${string}`
      vaultToken: `0x${string}`
      ripeVaultId: bigint
      legoId: bigint
      shouldMaxWithdraw: boolean
    }>
    pendingLeverageVault: (
      arg0: bigint,
    ) => Promise<{
      vaultAddr: `0x${string}`
      vaultToken: `0x${string}`
      legoId: bigint
      ripeVaultId: bigint
      shouldMaxWithdraw: boolean
    }>
    pendingSlippages: (
      arg0: bigint,
    ) => Promise<{ vaultAddr: `0x${string}`; usdcSlippage: bigint; greenSlippage: bigint }>
    pendingLevgVaultHelper: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; levgVaultHelper: `0x${string}` }>
    pendingMaxDebtRatio: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; ratio: bigint }>
    pendingAddManager: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; manager: `0x${string}` }>
    pendingRemoveManager: (arg0: bigint) => Promise<{ vaultAddr: `0x${string}`; manager: `0x${string}` }>
    pendingRegisterVaultTokenOnLego: (
      arg0: bigint,
    ) => Promise<{ legoId: bigint; asset: `0x${string}`; vaultToken: `0x${string}` }>
    pendingMorphoRewardsAddr: (arg0: bigint) => Promise<{ legoId: bigint; rewardsAddr: `0x${string}` }>
    pendingEulerRewardsAddr: (arg0: bigint) => Promise<{ legoId: bigint; rewardsAddr: `0x${string}` }>
    pendingCompRewardsAddr: (arg0: bigint) => Promise<{ legoId: bigint; rewardsAddr: `0x${string}` }>
  }
  mutations: {
    startGovernanceChange: (newGov: `0x${string}`) => Promise<void>
    confirmGovernanceChange: () => Promise<void>
    cancelGovernanceChange: () => Promise<void>
    relinquishGov: () => Promise<void>
    setGovTimeLock: (numBlocks: bigint) => Promise<boolean>
    finishUndyHqSetup: (newGov: `0x${string}`, timeLock?: bigint) => Promise<boolean>
    setActionTimeLock: (newTimeLock: bigint) => Promise<boolean>
    setExpiration: (expiration: bigint) => Promise<boolean>
    setActionTimeLockAfterSetup: (newTimeLock?: bigint) => Promise<boolean>
    setCanDeposit: (vaultAddr: `0x${string}`, canDeposit: boolean) => Promise<void>
    setCanWithdraw: (vaultAddr: `0x${string}`, canWithdraw: boolean) => Promise<void>
    setVaultOpsFrozen: (vaultAddr: `0x${string}`, isFrozen: boolean) => Promise<void>
    setShouldAutoDeposit: (vaultAddr: `0x${string}`, shouldAutoDeposit: boolean) => Promise<void>
    setShouldEnforceAllowlist: (vaultAddr: `0x${string}`, shouldEnforce: boolean) => Promise<void>
    setAllowed: (vaultAddr: `0x${string}`, user: `0x${string}`, isAllowed: boolean) => Promise<void>
    setAllowedBatch: (vaultAddr: `0x${string}`, users: `0x${string}`[], isAllowed: boolean) => Promise<void>
    addPriceSnapshot: (legoId: bigint, vaultToken: `0x${string}`) => Promise<boolean>
    deregisterVaultTokenOnLego: (legoId: bigint, asset: `0x${string}`, vaultToken: `0x${string}`) => Promise<bigint>
    updateYieldPosition: (vaultAddr: `0x${string}`, vaultToken: `0x${string}`) => Promise<void>
    claimPerformanceFees: (vaultAddr: `0x${string}`) => Promise<bigint>
    sweepLeftovers: (vaultAddr: `0x${string}`) => Promise<bigint>
    setRedemptionBuffer: (vaultAddr: `0x${string}`, buffer: bigint) => Promise<bigint>
    setMinYieldWithdrawAmount: (vaultAddr: `0x${string}`, amount: bigint) => Promise<bigint>
    setSnapShotPriceConfig: (
      legoId: bigint,
      minSnapshotDelay: bigint,
      maxNumSnapshots: bigint,
      maxUpsideDeviation: bigint,
      staleTime: bigint,
    ) => Promise<bigint>
    setApprovedVaultToken: (
      undyVaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      isApproved: boolean,
      shouldMaxWithdraw: boolean,
    ) => Promise<bigint>
    setApprovedVaultTokens: (
      undyVaultAddr: `0x${string}`,
      vaultTokens: `0x${string}`[],
      isApproved: boolean,
      shouldMaxWithdraw: boolean,
    ) => Promise<bigint>
    setPerformanceFee: (vaultAddr: `0x${string}`, performanceFee: bigint) => Promise<bigint>
    setDefaultTargetVaultToken: (vaultAddr: `0x${string}`, targetVaultToken: `0x${string}`) => Promise<bigint>
    setMaxDepositAmount: (vaultAddr: `0x${string}`, maxDepositAmount: bigint) => Promise<bigint>
    setIsLeveragedVault: (vaultAddr: `0x${string}`, isLeveragedVault: boolean) => Promise<bigint>
    setCollateralVault: (
      vaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      legoId: bigint,
      ripeVaultId: bigint,
      shouldMaxWithdraw: boolean,
    ) => Promise<bigint>
    setLeverageVault: (
      vaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      legoId: bigint,
      ripeVaultId: bigint,
      shouldMaxWithdraw: boolean,
    ) => Promise<bigint>
    setSlippagesAllowed: (vaultAddr: `0x${string}`, usdcSlippage: bigint, greenSlippage: bigint) => Promise<bigint>
    setLevgVaultHelper: (vaultAddr: `0x${string}`, levgVaultHelper: `0x${string}`) => Promise<bigint>
    setMaxDebtRatio: (vaultAddr: `0x${string}`, ratio: bigint) => Promise<bigint>
    addVaultManager: (vaultAddr: `0x${string}`, manager: `0x${string}`) => Promise<bigint>
    removeVaultManager: (vaultAddr: `0x${string}`, manager: `0x${string}`) => Promise<bigint>
    registerVaultTokenOnLego: (legoId: bigint, asset: `0x${string}`, vaultToken: `0x${string}`) => Promise<bigint>
    setMorphoRewardsAddr: (legoId: bigint, rewardsAddr: `0x${string}`) => Promise<bigint>
    setEulerRewardsAddr: (legoId: bigint, rewardsAddr: `0x${string}`) => Promise<bigint>
    setCompRewardsAddr: (legoId: bigint, rewardsAddr: `0x${string}`) => Promise<bigint>
    executePendingAction: (aid: bigint) => Promise<boolean>
    cancelPendingAction: (aid: bigint) => Promise<boolean>
  }
  events: {
    PendingRedemptionBufferChange: (
      vaultAddr: `0x${string}`,
      buffer: bigint,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    RedemptionBufferSet: (vaultAddr: `0x${string}`, buffer: bigint) => Promise<void>
    PendingMinYieldWithdrawAmountChange: (
      vaultAddr: `0x${string}`,
      amount: bigint,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    MinYieldWithdrawAmountSet: (vaultAddr: `0x${string}`, amount: bigint) => Promise<void>
    PendingSnapShotPriceConfigChange: (
      legoId: bigint,
      minSnapshotDelay: bigint,
      maxNumSnapshots: bigint,
      maxUpsideDeviation: bigint,
      staleTime: bigint,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    SnapShotPriceConfigSet: (
      legoId: bigint,
      legoAddr: `0x${string}`,
      minSnapshotDelay: bigint,
      maxNumSnapshots: bigint,
      maxUpsideDeviation: bigint,
      staleTime: bigint,
    ) => Promise<void>
    PendingApprovedVaultTokenChange: (
      vaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      isApproved: boolean,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    ApprovedVaultTokenSet: (vaultAddr: `0x${string}`, vaultToken: `0x${string}`, isApproved: boolean) => Promise<void>
    PendingApprovedVaultTokensChange: (
      vaultAddr: `0x${string}`,
      numTokens: bigint,
      isApproved: boolean,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    ApprovedVaultTokensSet: (vaultAddr: `0x${string}`, numTokens: bigint, isApproved: boolean) => Promise<void>
    PendingPerformanceFeeChange: (
      vaultAddr: `0x${string}`,
      performanceFee: bigint,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    PerformanceFeeSet: (vaultAddr: `0x${string}`, performanceFee: bigint) => Promise<void>
    PendingDefaultTargetVaultTokenChange: (
      vaultAddr: `0x${string}`,
      targetVaultToken: `0x${string}`,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    DefaultTargetVaultTokenSet: (vaultAddr: `0x${string}`, targetVaultToken: `0x${string}`) => Promise<void>
    PendingMaxDepositAmountChange: (
      vaultAddr: `0x${string}`,
      maxDepositAmount: bigint,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    MaxDepositAmountSet: (vaultAddr: `0x${string}`, maxDepositAmount: bigint) => Promise<void>
    PendingIsLeveragedVaultChange: (
      vaultAddr: `0x${string}`,
      isLeveragedVault: boolean,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    IsLeveragedVaultSet: (vaultAddr: `0x${string}`, isLeveragedVault: boolean) => Promise<void>
    CanDepositSet: (vaultAddr: `0x${string}`, canDeposit: boolean, caller: `0x${string}`) => Promise<void>
    CanWithdrawSet: (vaultAddr: `0x${string}`, canWithdraw: boolean, caller: `0x${string}`) => Promise<void>
    VaultOpsFrozenSet: (vaultAddr: `0x${string}`, isFrozen: boolean, caller: `0x${string}`) => Promise<void>
    ShouldAutoDepositSet: (vaultAddr: `0x${string}`, shouldAutoDeposit: boolean, caller: `0x${string}`) => Promise<void>
    ShouldEnforceAllowlistSet: (
      vaultAddr: `0x${string}`,
      shouldEnforce: boolean,
      caller: `0x${string}`,
    ) => Promise<void>
    AllowlistUserSet: (
      vaultAddr: `0x${string}`,
      user: `0x${string}`,
      isAllowed: boolean,
      caller: `0x${string}`,
    ) => Promise<void>
    AllowlistBatchSet: (
      vaultAddr: `0x${string}`,
      numUsers: bigint,
      isAllowed: boolean,
      caller: `0x${string}`,
    ) => Promise<void>
    PendingCollateralVaultChange: (
      vaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      ripeVaultId: bigint,
      legoId: bigint,
      shouldMaxWithdraw: boolean,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    CollateralVaultSet: (
      vaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      ripeVaultId: bigint,
      legoId: bigint,
    ) => Promise<void>
    PendingLeverageVaultChange: (
      vaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      legoId: bigint,
      ripeVaultId: bigint,
      shouldMaxWithdraw: boolean,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    LeverageVaultSet: (
      vaultAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      legoId: bigint,
      ripeVaultId: bigint,
    ) => Promise<void>
    PendingSlippagesChange: (
      vaultAddr: `0x${string}`,
      usdcSlippage: bigint,
      greenSlippage: bigint,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    SlippagesSet: (vaultAddr: `0x${string}`, usdcSlippage: bigint, greenSlippage: bigint) => Promise<void>
    PendingLevgVaultHelperChange: (
      vaultAddr: `0x${string}`,
      levgVaultHelper: `0x${string}`,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    LevgVaultHelperSet: (vaultAddr: `0x${string}`, levgVaultHelper: `0x${string}`) => Promise<void>
    PendingMaxDebtRatioChange: (
      vaultAddr: `0x${string}`,
      ratio: bigint,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    MaxDebtRatioSet: (vaultAddr: `0x${string}`, ratio: bigint) => Promise<void>
    PendingAddManagerChange: (
      vaultAddr: `0x${string}`,
      manager: `0x${string}`,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    ManagerAdded: (vaultAddr: `0x${string}`, manager: `0x${string}`) => Promise<void>
    PendingRemoveManagerChange: (
      vaultAddr: `0x${string}`,
      manager: `0x${string}`,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    ManagerRemoved: (vaultAddr: `0x${string}`, manager: `0x${string}`) => Promise<void>
    PriceSnapshotAdded: (
      legoId: bigint,
      legoAddr: `0x${string}`,
      vaultToken: `0x${string}`,
      success: boolean,
      caller: `0x${string}`,
    ) => Promise<void>
    YieldPositionUpdated: (vaultAddr: `0x${string}`, vaultToken: `0x${string}`, caller: `0x${string}`) => Promise<void>
    PerformanceFeesClaimed: (vaultAddr: `0x${string}`, amount: bigint, caller: `0x${string}`) => Promise<void>
    PendingRegisterVaultTokenOnLegoChange: (
      legoId: bigint,
      asset: `0x${string}`,
      vaultToken: `0x${string}`,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    VaultTokenRegisteredOnLego: (
      legoId: bigint,
      legoAddr: `0x${string}`,
      asset: `0x${string}`,
      vaultToken: `0x${string}`,
    ) => Promise<void>
    VaultTokenDeregisteredOnLego: (
      legoId: bigint,
      legoAddr: `0x${string}`,
      asset: `0x${string}`,
      vaultToken: `0x${string}`,
      caller: `0x${string}`,
    ) => Promise<void>
    PendingMorphoRewardsAddrChange: (
      legoId: bigint,
      rewardsAddr: `0x${string}`,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    MorphoRewardsAddrSet: (legoId: bigint, legoAddr: `0x${string}`, rewardsAddr: `0x${string}`) => Promise<void>
    PendingEulerRewardsAddrChange: (
      legoId: bigint,
      rewardsAddr: `0x${string}`,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    EulerRewardsAddrSet: (legoId: bigint, legoAddr: `0x${string}`, rewardsAddr: `0x${string}`) => Promise<void>
    PendingCompRewardsAddrChange: (
      legoId: bigint,
      rewardsAddr: `0x${string}`,
      confirmationBlock: bigint,
      actionId: bigint,
    ) => Promise<void>
    CompRewardsAddrSet: (legoId: bigint, legoAddr: `0x${string}`, rewardsAddr: `0x${string}`) => Promise<void>
    LeftoversSwept: (vaultAddr: `0x${string}`, amount: bigint, caller: `0x${string}`) => Promise<void>
    GovChangeTimeLockModified: (prevTimeLock: bigint, newTimeLock: bigint) => Promise<void>
    ExpirationSet: (expiration: bigint) => Promise<void>
    ActionTimeLockSet: (newTimeLock: bigint, prevTimeLock: bigint) => Promise<void>
    GovChangeStarted: (prevGov: `0x${string}`, newGov: `0x${string}`, confirmBlock: bigint) => Promise<void>
    GovChangeConfirmed: (
      prevGov: `0x${string}`,
      newGov: `0x${string}`,
      initiatedBlock: bigint,
      confirmBlock: bigint,
    ) => Promise<void>
    GovChangeCancelled: (cancelledGov: `0x${string}`, initiatedBlock: bigint, confirmBlock: bigint) => Promise<void>
    GovRelinquished: (prevGov: `0x${string}`) => Promise<void>
    UndyHqSetupFinished: (prevGov: `0x${string}`, newGov: `0x${string}`, timeLock: bigint) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'SwitchboardCharlie'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'SwitchboardCharlie' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => getRequest('getAddys', args),
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => getRequest('getUndyHq', args),
  getUndyHqFromGov: (...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>) =>
    getRequest('getUndyHqFromGov', args),
  canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) => getRequest('canGovern', args),
  getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) => getRequest('getGovernors', args),
  hasPendingGovChange: (...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>) =>
    getRequest('hasPendingGovChange', args),
  isValidGovTimeLock: (...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>) =>
    getRequest('isValidGovTimeLock', args),
  minGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>) =>
    getRequest('minGovChangeTimeLock', args),
  maxGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>) =>
    getRequest('maxGovChangeTimeLock', args),
  governance: (...args: ExtractArgs<Contract['calls']['governance']>) => getRequest('governance', args),
  pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) => getRequest('pendingGov', args),
  numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) => getRequest('numGovChanges', args),
  govChangeTimeLock: (...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>) =>
    getRequest('govChangeTimeLock', args),
  canConfirmAction: (...args: ExtractArgs<Contract['calls']['canConfirmAction']>) =>
    getRequest('canConfirmAction', args),
  isExpired: (...args: ExtractArgs<Contract['calls']['isExpired']>) => getRequest('isExpired', args),
  hasPendingAction: (...args: ExtractArgs<Contract['calls']['hasPendingAction']>) =>
    getRequest('hasPendingAction', args),
  getActionConfirmationBlock: (...args: ExtractArgs<Contract['calls']['getActionConfirmationBlock']>) =>
    getRequest('getActionConfirmationBlock', args),
  isValidActionTimeLock: (...args: ExtractArgs<Contract['calls']['isValidActionTimeLock']>) =>
    getRequest('isValidActionTimeLock', args),
  minActionTimeLock: (...args: ExtractArgs<Contract['calls']['minActionTimeLock']>) =>
    getRequest('minActionTimeLock', args),
  maxActionTimeLock: (...args: ExtractArgs<Contract['calls']['maxActionTimeLock']>) =>
    getRequest('maxActionTimeLock', args),
  pendingActions: (...args: ExtractArgs<Contract['calls']['pendingActions']>) => getRequest('pendingActions', args),
  actionId: (...args: ExtractArgs<Contract['calls']['actionId']>) => getRequest('actionId', args),
  actionTimeLock: (...args: ExtractArgs<Contract['calls']['actionTimeLock']>) => getRequest('actionTimeLock', args),
  expiration: (...args: ExtractArgs<Contract['calls']['expiration']>) => getRequest('expiration', args),
  actionType: (...args: ExtractArgs<Contract['calls']['actionType']>) => getRequest('actionType', args),
  pendingRedemptionBuffer: (...args: ExtractArgs<Contract['calls']['pendingRedemptionBuffer']>) =>
    getRequest('pendingRedemptionBuffer', args),
  pendingMinYieldWithdrawAmount: (...args: ExtractArgs<Contract['calls']['pendingMinYieldWithdrawAmount']>) =>
    getRequest('pendingMinYieldWithdrawAmount', args),
  pendingSnapShotPriceConfig: (...args: ExtractArgs<Contract['calls']['pendingSnapShotPriceConfig']>) =>
    getRequest('pendingSnapShotPriceConfig', args),
  pendingApprovedVaultToken: (...args: ExtractArgs<Contract['calls']['pendingApprovedVaultToken']>) =>
    getRequest('pendingApprovedVaultToken', args),
  pendingApprovedVaultTokens: (...args: ExtractArgs<Contract['calls']['pendingApprovedVaultTokens']>) =>
    getRequest('pendingApprovedVaultTokens', args),
  pendingPerformanceFee: (...args: ExtractArgs<Contract['calls']['pendingPerformanceFee']>) =>
    getRequest('pendingPerformanceFee', args),
  pendingDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['pendingDefaultTargetVaultToken']>) =>
    getRequest('pendingDefaultTargetVaultToken', args),
  pendingMaxDepositAmount: (...args: ExtractArgs<Contract['calls']['pendingMaxDepositAmount']>) =>
    getRequest('pendingMaxDepositAmount', args),
  pendingIsLeveragedVault: (...args: ExtractArgs<Contract['calls']['pendingIsLeveragedVault']>) =>
    getRequest('pendingIsLeveragedVault', args),
  pendingCollateralVault: (...args: ExtractArgs<Contract['calls']['pendingCollateralVault']>) =>
    getRequest('pendingCollateralVault', args),
  pendingLeverageVault: (...args: ExtractArgs<Contract['calls']['pendingLeverageVault']>) =>
    getRequest('pendingLeverageVault', args),
  pendingSlippages: (...args: ExtractArgs<Contract['calls']['pendingSlippages']>) =>
    getRequest('pendingSlippages', args),
  pendingLevgVaultHelper: (...args: ExtractArgs<Contract['calls']['pendingLevgVaultHelper']>) =>
    getRequest('pendingLevgVaultHelper', args),
  pendingMaxDebtRatio: (...args: ExtractArgs<Contract['calls']['pendingMaxDebtRatio']>) =>
    getRequest('pendingMaxDebtRatio', args),
  pendingAddManager: (...args: ExtractArgs<Contract['calls']['pendingAddManager']>) =>
    getRequest('pendingAddManager', args),
  pendingRemoveManager: (...args: ExtractArgs<Contract['calls']['pendingRemoveManager']>) =>
    getRequest('pendingRemoveManager', args),
  pendingRegisterVaultTokenOnLego: (...args: ExtractArgs<Contract['calls']['pendingRegisterVaultTokenOnLego']>) =>
    getRequest('pendingRegisterVaultTokenOnLego', args),
  pendingMorphoRewardsAddr: (...args: ExtractArgs<Contract['calls']['pendingMorphoRewardsAddr']>) =>
    getRequest('pendingMorphoRewardsAddr', args),
  pendingEulerRewardsAddr: (...args: ExtractArgs<Contract['calls']['pendingEulerRewardsAddr']>) =>
    getRequest('pendingEulerRewardsAddr', args),
  pendingCompRewardsAddr: (...args: ExtractArgs<Contract['calls']['pendingCompRewardsAddr']>) =>
    getRequest('pendingCompRewardsAddr', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'SwitchboardCharlie' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'SwitchboardCharlie'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  startGovernanceChange: getMutation('startGovernanceChange'),
  confirmGovernanceChange: getMutation('confirmGovernanceChange'),
  cancelGovernanceChange: getMutation('cancelGovernanceChange'),
  relinquishGov: getMutation('relinquishGov'),
  setGovTimeLock: getMutation('setGovTimeLock'),
  finishUndyHqSetup: getMutation('finishUndyHqSetup'),
  setActionTimeLock: getMutation('setActionTimeLock'),
  setExpiration: getMutation('setExpiration'),
  setActionTimeLockAfterSetup: getMutation('setActionTimeLockAfterSetup'),
  setCanDeposit: getMutation('setCanDeposit'),
  setCanWithdraw: getMutation('setCanWithdraw'),
  setVaultOpsFrozen: getMutation('setVaultOpsFrozen'),
  setShouldAutoDeposit: getMutation('setShouldAutoDeposit'),
  setShouldEnforceAllowlist: getMutation('setShouldEnforceAllowlist'),
  setAllowed: getMutation('setAllowed'),
  setAllowedBatch: getMutation('setAllowedBatch'),
  addPriceSnapshot: getMutation('addPriceSnapshot'),
  deregisterVaultTokenOnLego: getMutation('deregisterVaultTokenOnLego'),
  updateYieldPosition: getMutation('updateYieldPosition'),
  claimPerformanceFees: getMutation('claimPerformanceFees'),
  sweepLeftovers: getMutation('sweepLeftovers'),
  setRedemptionBuffer: getMutation('setRedemptionBuffer'),
  setMinYieldWithdrawAmount: getMutation('setMinYieldWithdrawAmount'),
  setSnapShotPriceConfig: getMutation('setSnapShotPriceConfig'),
  setApprovedVaultToken: getMutation('setApprovedVaultToken'),
  setApprovedVaultTokens: getMutation('setApprovedVaultTokens'),
  setPerformanceFee: getMutation('setPerformanceFee'),
  setDefaultTargetVaultToken: getMutation('setDefaultTargetVaultToken'),
  setMaxDepositAmount: getMutation('setMaxDepositAmount'),
  setIsLeveragedVault: getMutation('setIsLeveragedVault'),
  setCollateralVault: getMutation('setCollateralVault'),
  setLeverageVault: getMutation('setLeverageVault'),
  setSlippagesAllowed: getMutation('setSlippagesAllowed'),
  setLevgVaultHelper: getMutation('setLevgVaultHelper'),
  setMaxDebtRatio: getMutation('setMaxDebtRatio'),
  addVaultManager: getMutation('addVaultManager'),
  removeVaultManager: getMutation('removeVaultManager'),
  registerVaultTokenOnLego: getMutation('registerVaultTokenOnLego'),
  setMorphoRewardsAddr: getMutation('setMorphoRewardsAddr'),
  setEulerRewardsAddr: getMutation('setEulerRewardsAddr'),
  setCompRewardsAddr: getMutation('setCompRewardsAddr'),
  executePendingAction: getMutation('executePendingAction'),
  cancelPendingAction: getMutation('cancelPendingAction'),
}

export type ParsedEvent<T extends keyof Contract['events']> = {
  event: RpcLog | Log
  parsed: ParseEventLogsReturnType<typeof abi, T>
}

export function parseEvents<T extends keyof Contract['events']>(
  eventName: T,
  events: (RpcLog | Log)[],
): ParsedEvent<T>[] {
  return events.map((event) => {
    return {
      event,
      parsed: parseEventLogs({
        abi,
        eventName,
        logs: [event],
      }),
    }
  })
}

export function getEventTopic<T extends keyof Contract['events']>(eventName: T): Address {
  return encodeEventTopics({ abi, eventName })[0] as Address
}

export type SDK = {
  deployAddress: Address | undefined
  abi: typeof abi
  events: {
    PendingRedemptionBufferChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingRedemptionBufferChange'>[]
    }
    RedemptionBufferSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'RedemptionBufferSet'>[] }
    PendingMinYieldWithdrawAmountChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingMinYieldWithdrawAmountChange'>[]
    }
    MinYieldWithdrawAmountSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'MinYieldWithdrawAmountSet'>[]
    }
    PendingSnapShotPriceConfigChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingSnapShotPriceConfigChange'>[]
    }
    SnapShotPriceConfigSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'SnapShotPriceConfigSet'>[]
    }
    PendingApprovedVaultTokenChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingApprovedVaultTokenChange'>[]
    }
    ApprovedVaultTokenSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ApprovedVaultTokenSet'>[]
    }
    PendingApprovedVaultTokensChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingApprovedVaultTokensChange'>[]
    }
    ApprovedVaultTokensSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ApprovedVaultTokensSet'>[]
    }
    PendingPerformanceFeeChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingPerformanceFeeChange'>[]
    }
    PerformanceFeeSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PerformanceFeeSet'>[] }
    PendingDefaultTargetVaultTokenChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingDefaultTargetVaultTokenChange'>[]
    }
    DefaultTargetVaultTokenSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'DefaultTargetVaultTokenSet'>[]
    }
    PendingMaxDepositAmountChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingMaxDepositAmountChange'>[]
    }
    MaxDepositAmountSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'MaxDepositAmountSet'>[] }
    PendingIsLeveragedVaultChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingIsLeveragedVaultChange'>[]
    }
    IsLeveragedVaultSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'IsLeveragedVaultSet'>[] }
    CanDepositSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'CanDepositSet'>[] }
    CanWithdrawSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'CanWithdrawSet'>[] }
    VaultOpsFrozenSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'VaultOpsFrozenSet'>[] }
    ShouldAutoDepositSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ShouldAutoDepositSet'>[] }
    ShouldEnforceAllowlistSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ShouldEnforceAllowlistSet'>[]
    }
    AllowlistUserSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AllowlistUserSet'>[] }
    AllowlistBatchSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AllowlistBatchSet'>[] }
    PendingCollateralVaultChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingCollateralVaultChange'>[]
    }
    CollateralVaultSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'CollateralVaultSet'>[] }
    PendingLeverageVaultChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingLeverageVaultChange'>[]
    }
    LeverageVaultSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'LeverageVaultSet'>[] }
    PendingSlippagesChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingSlippagesChange'>[]
    }
    SlippagesSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'SlippagesSet'>[] }
    PendingLevgVaultHelperChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingLevgVaultHelperChange'>[]
    }
    LevgVaultHelperSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'LevgVaultHelperSet'>[] }
    PendingMaxDebtRatioChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingMaxDebtRatioChange'>[]
    }
    MaxDebtRatioSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'MaxDebtRatioSet'>[] }
    PendingAddManagerChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingAddManagerChange'>[]
    }
    ManagerAdded: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ManagerAdded'>[] }
    PendingRemoveManagerChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingRemoveManagerChange'>[]
    }
    ManagerRemoved: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ManagerRemoved'>[] }
    PriceSnapshotAdded: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PriceSnapshotAdded'>[] }
    YieldPositionUpdated: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'YieldPositionUpdated'>[] }
    PerformanceFeesClaimed: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PerformanceFeesClaimed'>[]
    }
    PendingRegisterVaultTokenOnLegoChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingRegisterVaultTokenOnLegoChange'>[]
    }
    VaultTokenRegisteredOnLego: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'VaultTokenRegisteredOnLego'>[]
    }
    VaultTokenDeregisteredOnLego: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'VaultTokenDeregisteredOnLego'>[]
    }
    PendingMorphoRewardsAddrChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingMorphoRewardsAddrChange'>[]
    }
    MorphoRewardsAddrSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'MorphoRewardsAddrSet'>[] }
    PendingEulerRewardsAddrChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingEulerRewardsAddrChange'>[]
    }
    EulerRewardsAddrSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'EulerRewardsAddrSet'>[] }
    PendingCompRewardsAddrChange: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PendingCompRewardsAddrChange'>[]
    }
    CompRewardsAddrSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'CompRewardsAddrSet'>[] }
    LeftoversSwept: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'LeftoversSwept'>[] }
    GovChangeTimeLockModified: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovChangeTimeLockModified'>[]
    }
    ExpirationSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ExpirationSet'>[] }
    ActionTimeLockSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ActionTimeLockSet'>[] }
    GovChangeStarted: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovChangeStarted'>[] }
    GovChangeConfirmed: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovChangeConfirmed'>[] }
    GovChangeCancelled: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovChangeCancelled'>[] }
    GovRelinquished: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'GovRelinquished'>[] }
    UndyHqSetupFinished: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'UndyHqSetupFinished'>[] }
  }
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => Promise<CallReturn<'getAddys'>>
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => Promise<CallReturn<'getUndyHq'>>
  getUndyHqFromGov: (
    ...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>
  ) => Promise<CallReturn<'getUndyHqFromGov'>>
  canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) => Promise<CallReturn<'canGovern'>>
  getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) => Promise<CallReturn<'getGovernors'>>
  hasPendingGovChange: (
    ...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>
  ) => Promise<CallReturn<'hasPendingGovChange'>>
  isValidGovTimeLock: (
    ...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>
  ) => Promise<CallReturn<'isValidGovTimeLock'>>
  minGovChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>
  ) => Promise<CallReturn<'minGovChangeTimeLock'>>
  maxGovChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>
  ) => Promise<CallReturn<'maxGovChangeTimeLock'>>
  governance: (...args: ExtractArgs<Contract['calls']['governance']>) => Promise<CallReturn<'governance'>>
  pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) => Promise<CallReturn<'pendingGov'>>
  numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) => Promise<CallReturn<'numGovChanges'>>
  govChangeTimeLock: (
    ...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>
  ) => Promise<CallReturn<'govChangeTimeLock'>>
  canConfirmAction: (
    ...args: ExtractArgs<Contract['calls']['canConfirmAction']>
  ) => Promise<CallReturn<'canConfirmAction'>>
  isExpired: (...args: ExtractArgs<Contract['calls']['isExpired']>) => Promise<CallReturn<'isExpired'>>
  hasPendingAction: (
    ...args: ExtractArgs<Contract['calls']['hasPendingAction']>
  ) => Promise<CallReturn<'hasPendingAction'>>
  getActionConfirmationBlock: (
    ...args: ExtractArgs<Contract['calls']['getActionConfirmationBlock']>
  ) => Promise<CallReturn<'getActionConfirmationBlock'>>
  isValidActionTimeLock: (
    ...args: ExtractArgs<Contract['calls']['isValidActionTimeLock']>
  ) => Promise<CallReturn<'isValidActionTimeLock'>>
  minActionTimeLock: (
    ...args: ExtractArgs<Contract['calls']['minActionTimeLock']>
  ) => Promise<CallReturn<'minActionTimeLock'>>
  maxActionTimeLock: (
    ...args: ExtractArgs<Contract['calls']['maxActionTimeLock']>
  ) => Promise<CallReturn<'maxActionTimeLock'>>
  pendingActions: (...args: ExtractArgs<Contract['calls']['pendingActions']>) => Promise<CallReturn<'pendingActions'>>
  actionId: (...args: ExtractArgs<Contract['calls']['actionId']>) => Promise<CallReturn<'actionId'>>
  actionTimeLock: (...args: ExtractArgs<Contract['calls']['actionTimeLock']>) => Promise<CallReturn<'actionTimeLock'>>
  expiration: (...args: ExtractArgs<Contract['calls']['expiration']>) => Promise<CallReturn<'expiration'>>
  actionType: (...args: ExtractArgs<Contract['calls']['actionType']>) => Promise<CallReturn<'actionType'>>
  pendingRedemptionBuffer: (
    ...args: ExtractArgs<Contract['calls']['pendingRedemptionBuffer']>
  ) => Promise<CallReturn<'pendingRedemptionBuffer'>>
  pendingMinYieldWithdrawAmount: (
    ...args: ExtractArgs<Contract['calls']['pendingMinYieldWithdrawAmount']>
  ) => Promise<CallReturn<'pendingMinYieldWithdrawAmount'>>
  pendingSnapShotPriceConfig: (
    ...args: ExtractArgs<Contract['calls']['pendingSnapShotPriceConfig']>
  ) => Promise<CallReturn<'pendingSnapShotPriceConfig'>>
  pendingApprovedVaultToken: (
    ...args: ExtractArgs<Contract['calls']['pendingApprovedVaultToken']>
  ) => Promise<CallReturn<'pendingApprovedVaultToken'>>
  pendingApprovedVaultTokens: (
    ...args: ExtractArgs<Contract['calls']['pendingApprovedVaultTokens']>
  ) => Promise<CallReturn<'pendingApprovedVaultTokens'>>
  pendingPerformanceFee: (
    ...args: ExtractArgs<Contract['calls']['pendingPerformanceFee']>
  ) => Promise<CallReturn<'pendingPerformanceFee'>>
  pendingDefaultTargetVaultToken: (
    ...args: ExtractArgs<Contract['calls']['pendingDefaultTargetVaultToken']>
  ) => Promise<CallReturn<'pendingDefaultTargetVaultToken'>>
  pendingMaxDepositAmount: (
    ...args: ExtractArgs<Contract['calls']['pendingMaxDepositAmount']>
  ) => Promise<CallReturn<'pendingMaxDepositAmount'>>
  pendingIsLeveragedVault: (
    ...args: ExtractArgs<Contract['calls']['pendingIsLeveragedVault']>
  ) => Promise<CallReturn<'pendingIsLeveragedVault'>>
  pendingCollateralVault: (
    ...args: ExtractArgs<Contract['calls']['pendingCollateralVault']>
  ) => Promise<CallReturn<'pendingCollateralVault'>>
  pendingLeverageVault: (
    ...args: ExtractArgs<Contract['calls']['pendingLeverageVault']>
  ) => Promise<CallReturn<'pendingLeverageVault'>>
  pendingSlippages: (
    ...args: ExtractArgs<Contract['calls']['pendingSlippages']>
  ) => Promise<CallReturn<'pendingSlippages'>>
  pendingLevgVaultHelper: (
    ...args: ExtractArgs<Contract['calls']['pendingLevgVaultHelper']>
  ) => Promise<CallReturn<'pendingLevgVaultHelper'>>
  pendingMaxDebtRatio: (
    ...args: ExtractArgs<Contract['calls']['pendingMaxDebtRatio']>
  ) => Promise<CallReturn<'pendingMaxDebtRatio'>>
  pendingAddManager: (
    ...args: ExtractArgs<Contract['calls']['pendingAddManager']>
  ) => Promise<CallReturn<'pendingAddManager'>>
  pendingRemoveManager: (
    ...args: ExtractArgs<Contract['calls']['pendingRemoveManager']>
  ) => Promise<CallReturn<'pendingRemoveManager'>>
  pendingRegisterVaultTokenOnLego: (
    ...args: ExtractArgs<Contract['calls']['pendingRegisterVaultTokenOnLego']>
  ) => Promise<CallReturn<'pendingRegisterVaultTokenOnLego'>>
  pendingMorphoRewardsAddr: (
    ...args: ExtractArgs<Contract['calls']['pendingMorphoRewardsAddr']>
  ) => Promise<CallReturn<'pendingMorphoRewardsAddr'>>
  pendingEulerRewardsAddr: (
    ...args: ExtractArgs<Contract['calls']['pendingEulerRewardsAddr']>
  ) => Promise<CallReturn<'pendingEulerRewardsAddr'>>
  pendingCompRewardsAddr: (
    ...args: ExtractArgs<Contract['calls']['pendingCompRewardsAddr']>
  ) => Promise<CallReturn<'pendingCompRewardsAddr'>>
  startGovernanceChange: (...args: ExtractArgs<Contract['mutations']['startGovernanceChange']>) => Promise<Address>
  confirmGovernanceChange: (...args: ExtractArgs<Contract['mutations']['confirmGovernanceChange']>) => Promise<Address>
  cancelGovernanceChange: (...args: ExtractArgs<Contract['mutations']['cancelGovernanceChange']>) => Promise<Address>
  relinquishGov: (...args: ExtractArgs<Contract['mutations']['relinquishGov']>) => Promise<Address>
  setGovTimeLock: (...args: ExtractArgs<Contract['mutations']['setGovTimeLock']>) => Promise<Address>
  finishUndyHqSetup: (...args: ExtractArgs<Contract['mutations']['finishUndyHqSetup']>) => Promise<Address>
  setActionTimeLock: (...args: ExtractArgs<Contract['mutations']['setActionTimeLock']>) => Promise<Address>
  setExpiration: (...args: ExtractArgs<Contract['mutations']['setExpiration']>) => Promise<Address>
  setActionTimeLockAfterSetup: (
    ...args: ExtractArgs<Contract['mutations']['setActionTimeLockAfterSetup']>
  ) => Promise<Address>
  setCanDeposit: (...args: ExtractArgs<Contract['mutations']['setCanDeposit']>) => Promise<Address>
  setCanWithdraw: (...args: ExtractArgs<Contract['mutations']['setCanWithdraw']>) => Promise<Address>
  setVaultOpsFrozen: (...args: ExtractArgs<Contract['mutations']['setVaultOpsFrozen']>) => Promise<Address>
  setShouldAutoDeposit: (...args: ExtractArgs<Contract['mutations']['setShouldAutoDeposit']>) => Promise<Address>
  setShouldEnforceAllowlist: (
    ...args: ExtractArgs<Contract['mutations']['setShouldEnforceAllowlist']>
  ) => Promise<Address>
  setAllowed: (...args: ExtractArgs<Contract['mutations']['setAllowed']>) => Promise<Address>
  setAllowedBatch: (...args: ExtractArgs<Contract['mutations']['setAllowedBatch']>) => Promise<Address>
  addPriceSnapshot: (...args: ExtractArgs<Contract['mutations']['addPriceSnapshot']>) => Promise<Address>
  deregisterVaultTokenOnLego: (
    ...args: ExtractArgs<Contract['mutations']['deregisterVaultTokenOnLego']>
  ) => Promise<Address>
  updateYieldPosition: (...args: ExtractArgs<Contract['mutations']['updateYieldPosition']>) => Promise<Address>
  claimPerformanceFees: (...args: ExtractArgs<Contract['mutations']['claimPerformanceFees']>) => Promise<Address>
  sweepLeftovers: (...args: ExtractArgs<Contract['mutations']['sweepLeftovers']>) => Promise<Address>
  setRedemptionBuffer: (...args: ExtractArgs<Contract['mutations']['setRedemptionBuffer']>) => Promise<Address>
  setMinYieldWithdrawAmount: (
    ...args: ExtractArgs<Contract['mutations']['setMinYieldWithdrawAmount']>
  ) => Promise<Address>
  setSnapShotPriceConfig: (...args: ExtractArgs<Contract['mutations']['setSnapShotPriceConfig']>) => Promise<Address>
  setApprovedVaultToken: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultToken']>) => Promise<Address>
  setApprovedVaultTokens: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultTokens']>) => Promise<Address>
  setPerformanceFee: (...args: ExtractArgs<Contract['mutations']['setPerformanceFee']>) => Promise<Address>
  setDefaultTargetVaultToken: (
    ...args: ExtractArgs<Contract['mutations']['setDefaultTargetVaultToken']>
  ) => Promise<Address>
  setMaxDepositAmount: (...args: ExtractArgs<Contract['mutations']['setMaxDepositAmount']>) => Promise<Address>
  setIsLeveragedVault: (...args: ExtractArgs<Contract['mutations']['setIsLeveragedVault']>) => Promise<Address>
  setCollateralVault: (...args: ExtractArgs<Contract['mutations']['setCollateralVault']>) => Promise<Address>
  setLeverageVault: (...args: ExtractArgs<Contract['mutations']['setLeverageVault']>) => Promise<Address>
  setSlippagesAllowed: (...args: ExtractArgs<Contract['mutations']['setSlippagesAllowed']>) => Promise<Address>
  setLevgVaultHelper: (...args: ExtractArgs<Contract['mutations']['setLevgVaultHelper']>) => Promise<Address>
  setMaxDebtRatio: (...args: ExtractArgs<Contract['mutations']['setMaxDebtRatio']>) => Promise<Address>
  addVaultManager: (...args: ExtractArgs<Contract['mutations']['addVaultManager']>) => Promise<Address>
  removeVaultManager: (...args: ExtractArgs<Contract['mutations']['removeVaultManager']>) => Promise<Address>
  registerVaultTokenOnLego: (
    ...args: ExtractArgs<Contract['mutations']['registerVaultTokenOnLego']>
  ) => Promise<Address>
  setMorphoRewardsAddr: (...args: ExtractArgs<Contract['mutations']['setMorphoRewardsAddr']>) => Promise<Address>
  setEulerRewardsAddr: (...args: ExtractArgs<Contract['mutations']['setEulerRewardsAddr']>) => Promise<Address>
  setCompRewardsAddr: (...args: ExtractArgs<Contract['mutations']['setCompRewardsAddr']>) => Promise<Address>
  executePendingAction: (...args: ExtractArgs<Contract['mutations']['executePendingAction']>) => Promise<Address>
  cancelPendingAction: (...args: ExtractArgs<Contract['mutations']['cancelPendingAction']>) => Promise<Address>
}

export function toSdk(
  publicClient?: PublicClient,
  walletClient?: WalletClient,
  addressResolver?: AddressResolverFunction,
): SDK {
  return {
    deployAddress,
    abi,

    events: {
      PendingRedemptionBufferChange: {
        topic: getEventTopic('PendingRedemptionBufferChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingRedemptionBufferChange', events),
      },
      RedemptionBufferSet: {
        topic: getEventTopic('RedemptionBufferSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('RedemptionBufferSet', events),
      },
      PendingMinYieldWithdrawAmountChange: {
        topic: getEventTopic('PendingMinYieldWithdrawAmountChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingMinYieldWithdrawAmountChange', events),
      },
      MinYieldWithdrawAmountSet: {
        topic: getEventTopic('MinYieldWithdrawAmountSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('MinYieldWithdrawAmountSet', events),
      },
      PendingSnapShotPriceConfigChange: {
        topic: getEventTopic('PendingSnapShotPriceConfigChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingSnapShotPriceConfigChange', events),
      },
      SnapShotPriceConfigSet: {
        topic: getEventTopic('SnapShotPriceConfigSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('SnapShotPriceConfigSet', events),
      },
      PendingApprovedVaultTokenChange: {
        topic: getEventTopic('PendingApprovedVaultTokenChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingApprovedVaultTokenChange', events),
      },
      ApprovedVaultTokenSet: {
        topic: getEventTopic('ApprovedVaultTokenSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ApprovedVaultTokenSet', events),
      },
      PendingApprovedVaultTokensChange: {
        topic: getEventTopic('PendingApprovedVaultTokensChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingApprovedVaultTokensChange', events),
      },
      ApprovedVaultTokensSet: {
        topic: getEventTopic('ApprovedVaultTokensSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ApprovedVaultTokensSet', events),
      },
      PendingPerformanceFeeChange: {
        topic: getEventTopic('PendingPerformanceFeeChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingPerformanceFeeChange', events),
      },
      PerformanceFeeSet: {
        topic: getEventTopic('PerformanceFeeSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PerformanceFeeSet', events),
      },
      PendingDefaultTargetVaultTokenChange: {
        topic: getEventTopic('PendingDefaultTargetVaultTokenChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingDefaultTargetVaultTokenChange', events),
      },
      DefaultTargetVaultTokenSet: {
        topic: getEventTopic('DefaultTargetVaultTokenSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('DefaultTargetVaultTokenSet', events),
      },
      PendingMaxDepositAmountChange: {
        topic: getEventTopic('PendingMaxDepositAmountChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingMaxDepositAmountChange', events),
      },
      MaxDepositAmountSet: {
        topic: getEventTopic('MaxDepositAmountSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('MaxDepositAmountSet', events),
      },
      PendingIsLeveragedVaultChange: {
        topic: getEventTopic('PendingIsLeveragedVaultChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingIsLeveragedVaultChange', events),
      },
      IsLeveragedVaultSet: {
        topic: getEventTopic('IsLeveragedVaultSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('IsLeveragedVaultSet', events),
      },
      CanDepositSet: {
        topic: getEventTopic('CanDepositSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('CanDepositSet', events),
      },
      CanWithdrawSet: {
        topic: getEventTopic('CanWithdrawSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('CanWithdrawSet', events),
      },
      VaultOpsFrozenSet: {
        topic: getEventTopic('VaultOpsFrozenSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('VaultOpsFrozenSet', events),
      },
      ShouldAutoDepositSet: {
        topic: getEventTopic('ShouldAutoDepositSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ShouldAutoDepositSet', events),
      },
      ShouldEnforceAllowlistSet: {
        topic: getEventTopic('ShouldEnforceAllowlistSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ShouldEnforceAllowlistSet', events),
      },
      AllowlistUserSet: {
        topic: getEventTopic('AllowlistUserSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AllowlistUserSet', events),
      },
      AllowlistBatchSet: {
        topic: getEventTopic('AllowlistBatchSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AllowlistBatchSet', events),
      },
      PendingCollateralVaultChange: {
        topic: getEventTopic('PendingCollateralVaultChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingCollateralVaultChange', events),
      },
      CollateralVaultSet: {
        topic: getEventTopic('CollateralVaultSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('CollateralVaultSet', events),
      },
      PendingLeverageVaultChange: {
        topic: getEventTopic('PendingLeverageVaultChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingLeverageVaultChange', events),
      },
      LeverageVaultSet: {
        topic: getEventTopic('LeverageVaultSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('LeverageVaultSet', events),
      },
      PendingSlippagesChange: {
        topic: getEventTopic('PendingSlippagesChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingSlippagesChange', events),
      },
      SlippagesSet: {
        topic: getEventTopic('SlippagesSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('SlippagesSet', events),
      },
      PendingLevgVaultHelperChange: {
        topic: getEventTopic('PendingLevgVaultHelperChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingLevgVaultHelperChange', events),
      },
      LevgVaultHelperSet: {
        topic: getEventTopic('LevgVaultHelperSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('LevgVaultHelperSet', events),
      },
      PendingMaxDebtRatioChange: {
        topic: getEventTopic('PendingMaxDebtRatioChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingMaxDebtRatioChange', events),
      },
      MaxDebtRatioSet: {
        topic: getEventTopic('MaxDebtRatioSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('MaxDebtRatioSet', events),
      },
      PendingAddManagerChange: {
        topic: getEventTopic('PendingAddManagerChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingAddManagerChange', events),
      },
      ManagerAdded: {
        topic: getEventTopic('ManagerAdded'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ManagerAdded', events),
      },
      PendingRemoveManagerChange: {
        topic: getEventTopic('PendingRemoveManagerChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingRemoveManagerChange', events),
      },
      ManagerRemoved: {
        topic: getEventTopic('ManagerRemoved'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ManagerRemoved', events),
      },
      PriceSnapshotAdded: {
        topic: getEventTopic('PriceSnapshotAdded'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PriceSnapshotAdded', events),
      },
      YieldPositionUpdated: {
        topic: getEventTopic('YieldPositionUpdated'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('YieldPositionUpdated', events),
      },
      PerformanceFeesClaimed: {
        topic: getEventTopic('PerformanceFeesClaimed'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PerformanceFeesClaimed', events),
      },
      PendingRegisterVaultTokenOnLegoChange: {
        topic: getEventTopic('PendingRegisterVaultTokenOnLegoChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingRegisterVaultTokenOnLegoChange', events),
      },
      VaultTokenRegisteredOnLego: {
        topic: getEventTopic('VaultTokenRegisteredOnLego'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('VaultTokenRegisteredOnLego', events),
      },
      VaultTokenDeregisteredOnLego: {
        topic: getEventTopic('VaultTokenDeregisteredOnLego'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('VaultTokenDeregisteredOnLego', events),
      },
      PendingMorphoRewardsAddrChange: {
        topic: getEventTopic('PendingMorphoRewardsAddrChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingMorphoRewardsAddrChange', events),
      },
      MorphoRewardsAddrSet: {
        topic: getEventTopic('MorphoRewardsAddrSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('MorphoRewardsAddrSet', events),
      },
      PendingEulerRewardsAddrChange: {
        topic: getEventTopic('PendingEulerRewardsAddrChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingEulerRewardsAddrChange', events),
      },
      EulerRewardsAddrSet: {
        topic: getEventTopic('EulerRewardsAddrSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('EulerRewardsAddrSet', events),
      },
      PendingCompRewardsAddrChange: {
        topic: getEventTopic('PendingCompRewardsAddrChange'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PendingCompRewardsAddrChange', events),
      },
      CompRewardsAddrSet: {
        topic: getEventTopic('CompRewardsAddrSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('CompRewardsAddrSet', events),
      },
      LeftoversSwept: {
        topic: getEventTopic('LeftoversSwept'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('LeftoversSwept', events),
      },
      GovChangeTimeLockModified: {
        topic: getEventTopic('GovChangeTimeLockModified'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovChangeTimeLockModified', events),
      },
      ExpirationSet: {
        topic: getEventTopic('ExpirationSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ExpirationSet', events),
      },
      ActionTimeLockSet: {
        topic: getEventTopic('ActionTimeLockSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ActionTimeLockSet', events),
      },
      GovChangeStarted: {
        topic: getEventTopic('GovChangeStarted'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovChangeStarted', events),
      },
      GovChangeConfirmed: {
        topic: getEventTopic('GovChangeConfirmed'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovChangeConfirmed', events),
      },
      GovChangeCancelled: {
        topic: getEventTopic('GovChangeCancelled'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovChangeCancelled', events),
      },
      GovRelinquished: {
        topic: getEventTopic('GovRelinquished'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('GovRelinquished', events),
      },
      UndyHqSetupFinished: {
        topic: getEventTopic('UndyHqSetupFinished'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('UndyHqSetupFinished', events),
      },
    },
    // Queries
    getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) =>
      singleQuery(publicClient!, call.getAddys(...args), {}, addressResolver) as Promise<CallReturn<'getAddys'>>,
    getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) =>
      singleQuery(publicClient!, call.getUndyHq(...args), {}, addressResolver) as Promise<CallReturn<'getUndyHq'>>,
    getUndyHqFromGov: (...args: ExtractArgs<Contract['calls']['getUndyHqFromGov']>) =>
      singleQuery(publicClient!, call.getUndyHqFromGov(...args), {}, addressResolver) as Promise<
        CallReturn<'getUndyHqFromGov'>
      >,
    canGovern: (...args: ExtractArgs<Contract['calls']['canGovern']>) =>
      singleQuery(publicClient!, call.canGovern(...args), {}, addressResolver) as Promise<CallReturn<'canGovern'>>,
    getGovernors: (...args: ExtractArgs<Contract['calls']['getGovernors']>) =>
      singleQuery(publicClient!, call.getGovernors(...args), {}, addressResolver) as Promise<
        CallReturn<'getGovernors'>
      >,
    hasPendingGovChange: (...args: ExtractArgs<Contract['calls']['hasPendingGovChange']>) =>
      singleQuery(publicClient!, call.hasPendingGovChange(...args), {}, addressResolver) as Promise<
        CallReturn<'hasPendingGovChange'>
      >,
    isValidGovTimeLock: (...args: ExtractArgs<Contract['calls']['isValidGovTimeLock']>) =>
      singleQuery(publicClient!, call.isValidGovTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidGovTimeLock'>
      >,
    minGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['minGovChangeTimeLock']>) =>
      singleQuery(publicClient!, call.minGovChangeTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'minGovChangeTimeLock'>
      >,
    maxGovChangeTimeLock: (...args: ExtractArgs<Contract['calls']['maxGovChangeTimeLock']>) =>
      singleQuery(publicClient!, call.maxGovChangeTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'maxGovChangeTimeLock'>
      >,
    governance: (...args: ExtractArgs<Contract['calls']['governance']>) =>
      singleQuery(publicClient!, call.governance(...args), {}, addressResolver) as Promise<CallReturn<'governance'>>,
    pendingGov: (...args: ExtractArgs<Contract['calls']['pendingGov']>) =>
      singleQuery(publicClient!, call.pendingGov(...args), {}, addressResolver) as Promise<CallReturn<'pendingGov'>>,
    numGovChanges: (...args: ExtractArgs<Contract['calls']['numGovChanges']>) =>
      singleQuery(publicClient!, call.numGovChanges(...args), {}, addressResolver) as Promise<
        CallReturn<'numGovChanges'>
      >,
    govChangeTimeLock: (...args: ExtractArgs<Contract['calls']['govChangeTimeLock']>) =>
      singleQuery(publicClient!, call.govChangeTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'govChangeTimeLock'>
      >,
    canConfirmAction: (...args: ExtractArgs<Contract['calls']['canConfirmAction']>) =>
      singleQuery(publicClient!, call.canConfirmAction(...args), {}, addressResolver) as Promise<
        CallReturn<'canConfirmAction'>
      >,
    isExpired: (...args: ExtractArgs<Contract['calls']['isExpired']>) =>
      singleQuery(publicClient!, call.isExpired(...args), {}, addressResolver) as Promise<CallReturn<'isExpired'>>,
    hasPendingAction: (...args: ExtractArgs<Contract['calls']['hasPendingAction']>) =>
      singleQuery(publicClient!, call.hasPendingAction(...args), {}, addressResolver) as Promise<
        CallReturn<'hasPendingAction'>
      >,
    getActionConfirmationBlock: (...args: ExtractArgs<Contract['calls']['getActionConfirmationBlock']>) =>
      singleQuery(publicClient!, call.getActionConfirmationBlock(...args), {}, addressResolver) as Promise<
        CallReturn<'getActionConfirmationBlock'>
      >,
    isValidActionTimeLock: (...args: ExtractArgs<Contract['calls']['isValidActionTimeLock']>) =>
      singleQuery(publicClient!, call.isValidActionTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidActionTimeLock'>
      >,
    minActionTimeLock: (...args: ExtractArgs<Contract['calls']['minActionTimeLock']>) =>
      singleQuery(publicClient!, call.minActionTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'minActionTimeLock'>
      >,
    maxActionTimeLock: (...args: ExtractArgs<Contract['calls']['maxActionTimeLock']>) =>
      singleQuery(publicClient!, call.maxActionTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'maxActionTimeLock'>
      >,
    pendingActions: (...args: ExtractArgs<Contract['calls']['pendingActions']>) =>
      singleQuery(publicClient!, call.pendingActions(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingActions'>
      >,
    actionId: (...args: ExtractArgs<Contract['calls']['actionId']>) =>
      singleQuery(publicClient!, call.actionId(...args), {}, addressResolver) as Promise<CallReturn<'actionId'>>,
    actionTimeLock: (...args: ExtractArgs<Contract['calls']['actionTimeLock']>) =>
      singleQuery(publicClient!, call.actionTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'actionTimeLock'>
      >,
    expiration: (...args: ExtractArgs<Contract['calls']['expiration']>) =>
      singleQuery(publicClient!, call.expiration(...args), {}, addressResolver) as Promise<CallReturn<'expiration'>>,
    actionType: (...args: ExtractArgs<Contract['calls']['actionType']>) =>
      singleQuery(publicClient!, call.actionType(...args), {}, addressResolver) as Promise<CallReturn<'actionType'>>,
    pendingRedemptionBuffer: (...args: ExtractArgs<Contract['calls']['pendingRedemptionBuffer']>) =>
      singleQuery(publicClient!, call.pendingRedemptionBuffer(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingRedemptionBuffer'>
      >,
    pendingMinYieldWithdrawAmount: (...args: ExtractArgs<Contract['calls']['pendingMinYieldWithdrawAmount']>) =>
      singleQuery(publicClient!, call.pendingMinYieldWithdrawAmount(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingMinYieldWithdrawAmount'>
      >,
    pendingSnapShotPriceConfig: (...args: ExtractArgs<Contract['calls']['pendingSnapShotPriceConfig']>) =>
      singleQuery(publicClient!, call.pendingSnapShotPriceConfig(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingSnapShotPriceConfig'>
      >,
    pendingApprovedVaultToken: (...args: ExtractArgs<Contract['calls']['pendingApprovedVaultToken']>) =>
      singleQuery(publicClient!, call.pendingApprovedVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingApprovedVaultToken'>
      >,
    pendingApprovedVaultTokens: (...args: ExtractArgs<Contract['calls']['pendingApprovedVaultTokens']>) =>
      singleQuery(publicClient!, call.pendingApprovedVaultTokens(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingApprovedVaultTokens'>
      >,
    pendingPerformanceFee: (...args: ExtractArgs<Contract['calls']['pendingPerformanceFee']>) =>
      singleQuery(publicClient!, call.pendingPerformanceFee(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingPerformanceFee'>
      >,
    pendingDefaultTargetVaultToken: (...args: ExtractArgs<Contract['calls']['pendingDefaultTargetVaultToken']>) =>
      singleQuery(publicClient!, call.pendingDefaultTargetVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingDefaultTargetVaultToken'>
      >,
    pendingMaxDepositAmount: (...args: ExtractArgs<Contract['calls']['pendingMaxDepositAmount']>) =>
      singleQuery(publicClient!, call.pendingMaxDepositAmount(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingMaxDepositAmount'>
      >,
    pendingIsLeveragedVault: (...args: ExtractArgs<Contract['calls']['pendingIsLeveragedVault']>) =>
      singleQuery(publicClient!, call.pendingIsLeveragedVault(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingIsLeveragedVault'>
      >,
    pendingCollateralVault: (...args: ExtractArgs<Contract['calls']['pendingCollateralVault']>) =>
      singleQuery(publicClient!, call.pendingCollateralVault(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingCollateralVault'>
      >,
    pendingLeverageVault: (...args: ExtractArgs<Contract['calls']['pendingLeverageVault']>) =>
      singleQuery(publicClient!, call.pendingLeverageVault(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingLeverageVault'>
      >,
    pendingSlippages: (...args: ExtractArgs<Contract['calls']['pendingSlippages']>) =>
      singleQuery(publicClient!, call.pendingSlippages(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingSlippages'>
      >,
    pendingLevgVaultHelper: (...args: ExtractArgs<Contract['calls']['pendingLevgVaultHelper']>) =>
      singleQuery(publicClient!, call.pendingLevgVaultHelper(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingLevgVaultHelper'>
      >,
    pendingMaxDebtRatio: (...args: ExtractArgs<Contract['calls']['pendingMaxDebtRatio']>) =>
      singleQuery(publicClient!, call.pendingMaxDebtRatio(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingMaxDebtRatio'>
      >,
    pendingAddManager: (...args: ExtractArgs<Contract['calls']['pendingAddManager']>) =>
      singleQuery(publicClient!, call.pendingAddManager(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingAddManager'>
      >,
    pendingRemoveManager: (...args: ExtractArgs<Contract['calls']['pendingRemoveManager']>) =>
      singleQuery(publicClient!, call.pendingRemoveManager(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingRemoveManager'>
      >,
    pendingRegisterVaultTokenOnLego: (...args: ExtractArgs<Contract['calls']['pendingRegisterVaultTokenOnLego']>) =>
      singleQuery(publicClient!, call.pendingRegisterVaultTokenOnLego(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingRegisterVaultTokenOnLego'>
      >,
    pendingMorphoRewardsAddr: (...args: ExtractArgs<Contract['calls']['pendingMorphoRewardsAddr']>) =>
      singleQuery(publicClient!, call.pendingMorphoRewardsAddr(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingMorphoRewardsAddr'>
      >,
    pendingEulerRewardsAddr: (...args: ExtractArgs<Contract['calls']['pendingEulerRewardsAddr']>) =>
      singleQuery(publicClient!, call.pendingEulerRewardsAddr(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingEulerRewardsAddr'>
      >,
    pendingCompRewardsAddr: (...args: ExtractArgs<Contract['calls']['pendingCompRewardsAddr']>) =>
      singleQuery(publicClient!, call.pendingCompRewardsAddr(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingCompRewardsAddr'>
      >,

    // Mutations
    startGovernanceChange: (...args: ExtractArgs<Contract['mutations']['startGovernanceChange']>) =>
      mutate(walletClient!, mutation.startGovernanceChange, { addressResolver })(...args),
    confirmGovernanceChange: (...args: ExtractArgs<Contract['mutations']['confirmGovernanceChange']>) =>
      mutate(walletClient!, mutation.confirmGovernanceChange, { addressResolver })(...args),
    cancelGovernanceChange: (...args: ExtractArgs<Contract['mutations']['cancelGovernanceChange']>) =>
      mutate(walletClient!, mutation.cancelGovernanceChange, { addressResolver })(...args),
    relinquishGov: (...args: ExtractArgs<Contract['mutations']['relinquishGov']>) =>
      mutate(walletClient!, mutation.relinquishGov, { addressResolver })(...args),
    setGovTimeLock: (...args: ExtractArgs<Contract['mutations']['setGovTimeLock']>) =>
      mutate(walletClient!, mutation.setGovTimeLock, { addressResolver })(...args),
    finishUndyHqSetup: (...args: ExtractArgs<Contract['mutations']['finishUndyHqSetup']>) =>
      mutate(walletClient!, mutation.finishUndyHqSetup, { addressResolver })(...args),
    setActionTimeLock: (...args: ExtractArgs<Contract['mutations']['setActionTimeLock']>) =>
      mutate(walletClient!, mutation.setActionTimeLock, { addressResolver })(...args),
    setExpiration: (...args: ExtractArgs<Contract['mutations']['setExpiration']>) =>
      mutate(walletClient!, mutation.setExpiration, { addressResolver })(...args),
    setActionTimeLockAfterSetup: (...args: ExtractArgs<Contract['mutations']['setActionTimeLockAfterSetup']>) =>
      mutate(walletClient!, mutation.setActionTimeLockAfterSetup, { addressResolver })(...args),
    setCanDeposit: (...args: ExtractArgs<Contract['mutations']['setCanDeposit']>) =>
      mutate(walletClient!, mutation.setCanDeposit, { addressResolver })(...args),
    setCanWithdraw: (...args: ExtractArgs<Contract['mutations']['setCanWithdraw']>) =>
      mutate(walletClient!, mutation.setCanWithdraw, { addressResolver })(...args),
    setVaultOpsFrozen: (...args: ExtractArgs<Contract['mutations']['setVaultOpsFrozen']>) =>
      mutate(walletClient!, mutation.setVaultOpsFrozen, { addressResolver })(...args),
    setShouldAutoDeposit: (...args: ExtractArgs<Contract['mutations']['setShouldAutoDeposit']>) =>
      mutate(walletClient!, mutation.setShouldAutoDeposit, { addressResolver })(...args),
    setShouldEnforceAllowlist: (...args: ExtractArgs<Contract['mutations']['setShouldEnforceAllowlist']>) =>
      mutate(walletClient!, mutation.setShouldEnforceAllowlist, { addressResolver })(...args),
    setAllowed: (...args: ExtractArgs<Contract['mutations']['setAllowed']>) =>
      mutate(walletClient!, mutation.setAllowed, { addressResolver })(...args),
    setAllowedBatch: (...args: ExtractArgs<Contract['mutations']['setAllowedBatch']>) =>
      mutate(walletClient!, mutation.setAllowedBatch, { addressResolver })(...args),
    addPriceSnapshot: (...args: ExtractArgs<Contract['mutations']['addPriceSnapshot']>) =>
      mutate(walletClient!, mutation.addPriceSnapshot, { addressResolver })(...args),
    deregisterVaultTokenOnLego: (...args: ExtractArgs<Contract['mutations']['deregisterVaultTokenOnLego']>) =>
      mutate(walletClient!, mutation.deregisterVaultTokenOnLego, { addressResolver })(...args),
    updateYieldPosition: (...args: ExtractArgs<Contract['mutations']['updateYieldPosition']>) =>
      mutate(walletClient!, mutation.updateYieldPosition, { addressResolver })(...args),
    claimPerformanceFees: (...args: ExtractArgs<Contract['mutations']['claimPerformanceFees']>) =>
      mutate(walletClient!, mutation.claimPerformanceFees, { addressResolver })(...args),
    sweepLeftovers: (...args: ExtractArgs<Contract['mutations']['sweepLeftovers']>) =>
      mutate(walletClient!, mutation.sweepLeftovers, { addressResolver })(...args),
    setRedemptionBuffer: (...args: ExtractArgs<Contract['mutations']['setRedemptionBuffer']>) =>
      mutate(walletClient!, mutation.setRedemptionBuffer, { addressResolver })(...args),
    setMinYieldWithdrawAmount: (...args: ExtractArgs<Contract['mutations']['setMinYieldWithdrawAmount']>) =>
      mutate(walletClient!, mutation.setMinYieldWithdrawAmount, { addressResolver })(...args),
    setSnapShotPriceConfig: (...args: ExtractArgs<Contract['mutations']['setSnapShotPriceConfig']>) =>
      mutate(walletClient!, mutation.setSnapShotPriceConfig, { addressResolver })(...args),
    setApprovedVaultToken: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultToken']>) =>
      mutate(walletClient!, mutation.setApprovedVaultToken, { addressResolver })(...args),
    setApprovedVaultTokens: (...args: ExtractArgs<Contract['mutations']['setApprovedVaultTokens']>) =>
      mutate(walletClient!, mutation.setApprovedVaultTokens, { addressResolver })(...args),
    setPerformanceFee: (...args: ExtractArgs<Contract['mutations']['setPerformanceFee']>) =>
      mutate(walletClient!, mutation.setPerformanceFee, { addressResolver })(...args),
    setDefaultTargetVaultToken: (...args: ExtractArgs<Contract['mutations']['setDefaultTargetVaultToken']>) =>
      mutate(walletClient!, mutation.setDefaultTargetVaultToken, { addressResolver })(...args),
    setMaxDepositAmount: (...args: ExtractArgs<Contract['mutations']['setMaxDepositAmount']>) =>
      mutate(walletClient!, mutation.setMaxDepositAmount, { addressResolver })(...args),
    setIsLeveragedVault: (...args: ExtractArgs<Contract['mutations']['setIsLeveragedVault']>) =>
      mutate(walletClient!, mutation.setIsLeveragedVault, { addressResolver })(...args),
    setCollateralVault: (...args: ExtractArgs<Contract['mutations']['setCollateralVault']>) =>
      mutate(walletClient!, mutation.setCollateralVault, { addressResolver })(...args),
    setLeverageVault: (...args: ExtractArgs<Contract['mutations']['setLeverageVault']>) =>
      mutate(walletClient!, mutation.setLeverageVault, { addressResolver })(...args),
    setSlippagesAllowed: (...args: ExtractArgs<Contract['mutations']['setSlippagesAllowed']>) =>
      mutate(walletClient!, mutation.setSlippagesAllowed, { addressResolver })(...args),
    setLevgVaultHelper: (...args: ExtractArgs<Contract['mutations']['setLevgVaultHelper']>) =>
      mutate(walletClient!, mutation.setLevgVaultHelper, { addressResolver })(...args),
    setMaxDebtRatio: (...args: ExtractArgs<Contract['mutations']['setMaxDebtRatio']>) =>
      mutate(walletClient!, mutation.setMaxDebtRatio, { addressResolver })(...args),
    addVaultManager: (...args: ExtractArgs<Contract['mutations']['addVaultManager']>) =>
      mutate(walletClient!, mutation.addVaultManager, { addressResolver })(...args),
    removeVaultManager: (...args: ExtractArgs<Contract['mutations']['removeVaultManager']>) =>
      mutate(walletClient!, mutation.removeVaultManager, { addressResolver })(...args),
    registerVaultTokenOnLego: (...args: ExtractArgs<Contract['mutations']['registerVaultTokenOnLego']>) =>
      mutate(walletClient!, mutation.registerVaultTokenOnLego, { addressResolver })(...args),
    setMorphoRewardsAddr: (...args: ExtractArgs<Contract['mutations']['setMorphoRewardsAddr']>) =>
      mutate(walletClient!, mutation.setMorphoRewardsAddr, { addressResolver })(...args),
    setEulerRewardsAddr: (...args: ExtractArgs<Contract['mutations']['setEulerRewardsAddr']>) =>
      mutate(walletClient!, mutation.setEulerRewardsAddr, { addressResolver })(...args),
    setCompRewardsAddr: (...args: ExtractArgs<Contract['mutations']['setCompRewardsAddr']>) =>
      mutate(walletClient!, mutation.setCompRewardsAddr, { addressResolver })(...args),
    executePendingAction: (...args: ExtractArgs<Contract['mutations']['executePendingAction']>) =>
      mutate(walletClient!, mutation.executePendingAction, { addressResolver })(...args),
    cancelPendingAction: (...args: ExtractArgs<Contract['mutations']['cancelPendingAction']>) =>
      mutate(walletClient!, mutation.cancelPendingAction, { addressResolver })(...args),
  }
}
