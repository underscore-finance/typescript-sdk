/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate, AddressResolverFunction } from '@dappql/async'
import {
  encodeEventTopics,
  parseEventLogs,
  ParseEventLogsReturnType,
  Log,
  RpcLog,
  PublicClient,
  WalletClient,
} from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      {
        name: 'sender',
        type: 'address',
        indexed: true,
      },
      {
        name: 'receiver',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: 'event',
    name: 'Approval',
    inputs: [
      {
        name: 'owner',
        type: 'address',
        indexed: true,
      },
      {
        name: 'spender',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: 'function',
    name: 'name',
    stateMutability: 'pure',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'string',
      },
    ],
  },
  {
    type: 'function',
    name: 'symbol',
    stateMutability: 'pure',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'string',
      },
    ],
  },
  {
    type: 'function',
    name: 'decimals',
    stateMutability: 'pure',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint8',
      },
    ],
  },
  {
    type: 'function',
    name: 'transfer',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    type: 'function',
    name: 'transferFrom',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: '_sender',
        type: 'address',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    type: 'function',
    name: 'approve',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: '_spender',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    type: 'function',
    name: 'permit',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: '_owner',
        type: 'address',
      },
      {
        name: '_spender',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_expiry',
        type: 'uint256',
      },
      {
        name: '_signature',
        type: 'bytes',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    type: 'function',
    name: 'totalSupply',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    type: 'function',
    name: 'allowance',
    stateMutability: 'view',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    type: 'function',
    name: 'nonces',
    stateMutability: 'view',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    type: 'function',
    name: 'DOMAIN_SEPARATOR',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bytes32',
      },
    ],
  },
] as const

export const deployAddress: Address | undefined = undefined

export type Contract = {
  calls: {
    name: () => Promise<string>
    symbol: () => Promise<string>
    decimals: () => Promise<number>
    totalSupply: () => Promise<bigint>
    balanceOf: (arg0: `0x${string}`) => Promise<bigint>
    allowance: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<bigint>
    nonces: (arg0: `0x${string}`) => Promise<bigint>
    DOMAIN_SEPARATOR: () => Promise<`0x${string}`>
  }
  mutations: {
    transfer: (recipient: `0x${string}`, amount: bigint) => Promise<boolean>
    transferFrom: (sender: `0x${string}`, recipient: `0x${string}`, amount: bigint) => Promise<boolean>
    approve: (spender: `0x${string}`, amount: bigint) => Promise<boolean>
    permit: (
      owner: `0x${string}`,
      spender: `0x${string}`,
      amount: bigint,
      expiry: bigint,
      signature: `0x${string}`,
    ) => Promise<boolean>
  }
  events: {
    Transfer: (sender: `0x${string}`, receiver: `0x${string}`, amount: bigint) => Promise<void>
    Approval: (owner: `0x${string}`, spender: `0x${string}`, amount: bigint) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'ERC20'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'ERC20' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  name: (...args: ExtractArgs<Contract['calls']['name']>) => getRequest('name', args),
  symbol: (...args: ExtractArgs<Contract['calls']['symbol']>) => getRequest('symbol', args),
  decimals: (...args: ExtractArgs<Contract['calls']['decimals']>) => getRequest('decimals', args),
  totalSupply: (...args: ExtractArgs<Contract['calls']['totalSupply']>) => getRequest('totalSupply', args),
  balanceOf: (...args: ExtractArgs<Contract['calls']['balanceOf']>) => getRequest('balanceOf', args),
  allowance: (...args: ExtractArgs<Contract['calls']['allowance']>) => getRequest('allowance', args),
  nonces: (...args: ExtractArgs<Contract['calls']['nonces']>) => getRequest('nonces', args),
  DOMAIN_SEPARATOR: (...args: ExtractArgs<Contract['calls']['DOMAIN_SEPARATOR']>) =>
    getRequest('DOMAIN_SEPARATOR', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'ERC20' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'ERC20'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  transfer: getMutation('transfer'),
  transferFrom: getMutation('transferFrom'),
  approve: getMutation('approve'),
  permit: getMutation('permit'),
}

export type ParsedEvent<T extends keyof Contract['events']> = {
  event: RpcLog | Log
  parsed: ParseEventLogsReturnType<typeof abi, T>
}

export function parseEvents<T extends keyof Contract['events']>(
  eventName: T,
  events: (RpcLog | Log)[],
): ParsedEvent<T>[] {
  return events.map((event) => {
    return {
      event,
      parsed: parseEventLogs({
        abi,
        eventName,
        logs: [event],
      }),
    }
  })
}

export function getEventTopic<T extends keyof Contract['events']>(eventName: T): Address {
  return encodeEventTopics({ abi, eventName })[0] as Address
}

export type SDK = {
  deployAddress: Address | undefined
  abi: typeof abi
  events: {
    Transfer: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'Transfer'>[] }
    Approval: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'Approval'>[] }
  }
  name: (...args: ExtractArgs<Contract['calls']['name']>) => Promise<CallReturn<'name'>>
  symbol: (...args: ExtractArgs<Contract['calls']['symbol']>) => Promise<CallReturn<'symbol'>>
  decimals: (...args: ExtractArgs<Contract['calls']['decimals']>) => Promise<CallReturn<'decimals'>>
  totalSupply: (...args: ExtractArgs<Contract['calls']['totalSupply']>) => Promise<CallReturn<'totalSupply'>>
  balanceOf: (...args: ExtractArgs<Contract['calls']['balanceOf']>) => Promise<CallReturn<'balanceOf'>>
  allowance: (...args: ExtractArgs<Contract['calls']['allowance']>) => Promise<CallReturn<'allowance'>>
  nonces: (...args: ExtractArgs<Contract['calls']['nonces']>) => Promise<CallReturn<'nonces'>>
  DOMAIN_SEPARATOR: (
    ...args: ExtractArgs<Contract['calls']['DOMAIN_SEPARATOR']>
  ) => Promise<CallReturn<'DOMAIN_SEPARATOR'>>
  transfer: (...args: ExtractArgs<Contract['mutations']['transfer']>) => Promise<Address>
  transferFrom: (...args: ExtractArgs<Contract['mutations']['transferFrom']>) => Promise<Address>
  approve: (...args: ExtractArgs<Contract['mutations']['approve']>) => Promise<Address>
  permit: (...args: ExtractArgs<Contract['mutations']['permit']>) => Promise<Address>
}

export function toSdk(
  deployAddress: Address,
  publicClient?: PublicClient,
  walletClient?: WalletClient,
  addressResolver?: AddressResolverFunction,
): SDK {
  return {
    deployAddress,
    abi,

    events: {
      Transfer: {
        topic: getEventTopic('Transfer'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('Transfer', events),
      },
      Approval: {
        topic: getEventTopic('Approval'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('Approval', events),
      },
    },
    // Queries
    name: (...args: ExtractArgs<Contract['calls']['name']>) =>
      singleQuery(publicClient!, call.name(...args).at(deployAddress), {}, addressResolver) as Promise<
        CallReturn<'name'>
      >,
    symbol: (...args: ExtractArgs<Contract['calls']['symbol']>) =>
      singleQuery(publicClient!, call.symbol(...args).at(deployAddress), {}, addressResolver) as Promise<
        CallReturn<'symbol'>
      >,
    decimals: (...args: ExtractArgs<Contract['calls']['decimals']>) =>
      singleQuery(publicClient!, call.decimals(...args).at(deployAddress), {}, addressResolver) as Promise<
        CallReturn<'decimals'>
      >,
    totalSupply: (...args: ExtractArgs<Contract['calls']['totalSupply']>) =>
      singleQuery(publicClient!, call.totalSupply(...args).at(deployAddress), {}, addressResolver) as Promise<
        CallReturn<'totalSupply'>
      >,
    balanceOf: (...args: ExtractArgs<Contract['calls']['balanceOf']>) =>
      singleQuery(publicClient!, call.balanceOf(...args).at(deployAddress), {}, addressResolver) as Promise<
        CallReturn<'balanceOf'>
      >,
    allowance: (...args: ExtractArgs<Contract['calls']['allowance']>) =>
      singleQuery(publicClient!, call.allowance(...args).at(deployAddress), {}, addressResolver) as Promise<
        CallReturn<'allowance'>
      >,
    nonces: (...args: ExtractArgs<Contract['calls']['nonces']>) =>
      singleQuery(publicClient!, call.nonces(...args).at(deployAddress), {}, addressResolver) as Promise<
        CallReturn<'nonces'>
      >,
    DOMAIN_SEPARATOR: (...args: ExtractArgs<Contract['calls']['DOMAIN_SEPARATOR']>) =>
      singleQuery(publicClient!, call.DOMAIN_SEPARATOR(...args).at(deployAddress), {}, addressResolver) as Promise<
        CallReturn<'DOMAIN_SEPARATOR'>
      >,

    // Mutations
    transfer: (...args: ExtractArgs<Contract['mutations']['transfer']>) =>
      mutate(walletClient!, mutation.transfer, { address: deployAddress, addressResolver })(...args),
    transferFrom: (...args: ExtractArgs<Contract['mutations']['transferFrom']>) =>
      mutate(walletClient!, mutation.transferFrom, { address: deployAddress, addressResolver })(...args),
    approve: (...args: ExtractArgs<Contract['mutations']['approve']>) =>
      mutate(walletClient!, mutation.approve, { address: deployAddress, addressResolver })(...args),
    permit: (...args: ExtractArgs<Contract['mutations']['permit']>) =>
      mutate(walletClient!, mutation.permit, { address: deployAddress, addressResolver })(...args),
  }
}
