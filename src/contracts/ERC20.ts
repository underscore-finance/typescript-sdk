/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate } from '@dappql/async'
import { PublicClient, WalletClient } from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    type: 'event',
    name: 'Transfer',
    inputs: [
      {
        name: 'sender',
        type: 'address',
        indexed: true,
      },
      {
        name: 'receiver',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: 'event',
    name: 'Approval',
    inputs: [
      {
        name: 'owner',
        type: 'address',
        indexed: true,
      },
      {
        name: 'spender',
        type: 'address',
        indexed: true,
      },
      {
        name: 'amount',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
  },
  {
    type: 'function',
    name: 'name',
    stateMutability: 'pure',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'string',
      },
    ],
  },
  {
    type: 'function',
    name: 'symbol',
    stateMutability: 'pure',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'string',
      },
    ],
  },
  {
    type: 'function',
    name: 'decimals',
    stateMutability: 'pure',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint8',
      },
    ],
  },
  {
    type: 'function',
    name: 'transfer',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    type: 'function',
    name: 'transferFrom',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: '_sender',
        type: 'address',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    type: 'function',
    name: 'approve',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: '_spender',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    type: 'function',
    name: 'permit',
    stateMutability: 'nonpayable',
    inputs: [
      {
        name: '_owner',
        type: 'address',
      },
      {
        name: '_spender',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_expiry',
        type: 'uint256',
      },
      {
        name: '_signature',
        type: 'bytes',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    type: 'function',
    name: 'totalSupply',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    type: 'function',
    name: 'balanceOf',
    stateMutability: 'view',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    type: 'function',
    name: 'allowance',
    stateMutability: 'view',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    type: 'function',
    name: 'nonces',
    stateMutability: 'view',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    type: 'function',
    name: 'DOMAIN_SEPARATOR',
    stateMutability: 'view',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bytes32',
      },
    ],
  },
] as const

export const deployAddress: Address | undefined = undefined

export type Contract = {
  calls: {
    name: () => Promise<string>
    symbol: () => Promise<string>
    decimals: () => Promise<number>
    totalSupply: () => Promise<bigint>
    balanceOf: (arg0: `0x${string}`) => Promise<bigint>
    allowance: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<bigint>
    nonces: (arg0: `0x${string}`) => Promise<bigint>
    DOMAIN_SEPARATOR: () => Promise<`0x${string}`>
  }
  mutations: {
    transfer: (recipient: `0x${string}`, amount: bigint) => Promise<boolean>
    transferFrom: (sender: `0x${string}`, recipient: `0x${string}`, amount: bigint) => Promise<boolean>
    approve: (spender: `0x${string}`, amount: bigint) => Promise<boolean>
    permit: (
      owner: `0x${string}`,
      spender: `0x${string}`,
      amount: bigint,
      expiry: bigint,
      signature: `0x${string}`,
    ) => Promise<boolean>
  }
  events: {
    Transfer: (sender: `0x${string}`, receiver: `0x${string}`, amount: bigint) => Promise<void>
    Approval: (owner: `0x${string}`, spender: `0x${string}`, amount: bigint) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'ERC20'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'ERC20' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  name: (...args: ExtractArgs<Contract['calls']['name']>) => getRequest('name', args),
  symbol: (...args: ExtractArgs<Contract['calls']['symbol']>) => getRequest('symbol', args),
  decimals: (...args: ExtractArgs<Contract['calls']['decimals']>) => getRequest('decimals', args),
  totalSupply: (...args: ExtractArgs<Contract['calls']['totalSupply']>) => getRequest('totalSupply', args),
  balanceOf: (...args: ExtractArgs<Contract['calls']['balanceOf']>) => getRequest('balanceOf', args),
  allowance: (...args: ExtractArgs<Contract['calls']['allowance']>) => getRequest('allowance', args),
  nonces: (...args: ExtractArgs<Contract['calls']['nonces']>) => getRequest('nonces', args),
  DOMAIN_SEPARATOR: (...args: ExtractArgs<Contract['calls']['DOMAIN_SEPARATOR']>) =>
    getRequest('DOMAIN_SEPARATOR', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'ERC20' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'ERC20'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  transfer: getMutation('transfer'),
  transferFrom: getMutation('transferFrom'),
  approve: getMutation('approve'),
  permit: getMutation('permit'),
}

export type SDK = {
  name: (...args: ExtractArgs<Contract['calls']['name']>) => Promise<CallReturn<'name'>>
  symbol: (...args: ExtractArgs<Contract['calls']['symbol']>) => Promise<CallReturn<'symbol'>>
  decimals: (...args: ExtractArgs<Contract['calls']['decimals']>) => Promise<CallReturn<'decimals'>>
  totalSupply: (...args: ExtractArgs<Contract['calls']['totalSupply']>) => Promise<CallReturn<'totalSupply'>>
  balanceOf: (...args: ExtractArgs<Contract['calls']['balanceOf']>) => Promise<CallReturn<'balanceOf'>>
  allowance: (...args: ExtractArgs<Contract['calls']['allowance']>) => Promise<CallReturn<'allowance'>>
  nonces: (...args: ExtractArgs<Contract['calls']['nonces']>) => Promise<CallReturn<'nonces'>>
  DOMAIN_SEPARATOR: (
    ...args: ExtractArgs<Contract['calls']['DOMAIN_SEPARATOR']>
  ) => Promise<CallReturn<'DOMAIN_SEPARATOR'>>
  transfer: (...args: ExtractArgs<Contract['mutations']['transfer']>) => Promise<Address>
  transferFrom: (...args: ExtractArgs<Contract['mutations']['transferFrom']>) => Promise<Address>
  approve: (...args: ExtractArgs<Contract['mutations']['approve']>) => Promise<Address>
  permit: (...args: ExtractArgs<Contract['mutations']['permit']>) => Promise<Address>
}

export function toSdk(address: Address, publicClient?: PublicClient, walletClient?: WalletClient): SDK {
  return {
    // Queries
    name: (...args: ExtractArgs<Contract['calls']['name']>) =>
      singleQuery(publicClient!, call.name(...args).at(address)) as Promise<CallReturn<'name'>>,
    symbol: (...args: ExtractArgs<Contract['calls']['symbol']>) =>
      singleQuery(publicClient!, call.symbol(...args).at(address)) as Promise<CallReturn<'symbol'>>,
    decimals: (...args: ExtractArgs<Contract['calls']['decimals']>) =>
      singleQuery(publicClient!, call.decimals(...args).at(address)) as Promise<CallReturn<'decimals'>>,
    totalSupply: (...args: ExtractArgs<Contract['calls']['totalSupply']>) =>
      singleQuery(publicClient!, call.totalSupply(...args).at(address)) as Promise<CallReturn<'totalSupply'>>,
    balanceOf: (...args: ExtractArgs<Contract['calls']['balanceOf']>) =>
      singleQuery(publicClient!, call.balanceOf(...args).at(address)) as Promise<CallReturn<'balanceOf'>>,
    allowance: (...args: ExtractArgs<Contract['calls']['allowance']>) =>
      singleQuery(publicClient!, call.allowance(...args).at(address)) as Promise<CallReturn<'allowance'>>,
    nonces: (...args: ExtractArgs<Contract['calls']['nonces']>) =>
      singleQuery(publicClient!, call.nonces(...args).at(address)) as Promise<CallReturn<'nonces'>>,
    DOMAIN_SEPARATOR: (...args: ExtractArgs<Contract['calls']['DOMAIN_SEPARATOR']>) =>
      singleQuery(publicClient!, call.DOMAIN_SEPARATOR(...args).at(address)) as Promise<CallReturn<'DOMAIN_SEPARATOR'>>,

    // Mutations
    transfer: (...args: ExtractArgs<Contract['mutations']['transfer']>) =>
      mutate(walletClient!, mutation.transfer, { address })(...args),
    transferFrom: (...args: ExtractArgs<Contract['mutations']['transferFrom']>) =>
      mutate(walletClient!, mutation.transferFrom, { address })(...args),
    approve: (...args: ExtractArgs<Contract['mutations']['approve']>) =>
      mutate(walletClient!, mutation.approve, { address })(...args),
    permit: (...args: ExtractArgs<Contract['mutations']['permit']>) =>
      mutate(walletClient!, mutation.permit, { address })(...args),
  }
}
