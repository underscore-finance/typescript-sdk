/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate } from '@dappql/async'
import { PublicClient, WalletClient } from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getRegistries',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAccessForLego',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'string',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimRewards',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_market',
        type: 'address',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_proof',
        type: 'bytes32',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFunds',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'legoId',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setLegoId',
    inputs: [
      {
        name: '_legoId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasClaimableRewards',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
] as const

export const deployAddress: Address | undefined = undefined

export type Contract = {
  calls: {
    getRegistries: () => Promise<`0x${string}`[]>
    getAccessForLego: (user: `0x${string}`) => Promise<[`0x${string}`, string, bigint]>
    legoId: () => Promise<bigint>
    hasClaimableRewards: (user: `0x${string}`) => Promise<boolean>
  }
  mutations: {
    claimRewards: (
      user: `0x${string}`,
      market: `0x${string}`,
      rewardToken: `0x${string}`,
      rewardAmount: bigint,
      proof: `0x${string}`,
    ) => Promise<void>
    recoverFunds: (asset: `0x${string}`, recipient: `0x${string}`) => Promise<boolean>
    setLegoId: (legoId: bigint) => Promise<boolean>
  }
  events: {}
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'LegoCommon'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'LegoCommon' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  getRegistries: (...args: ExtractArgs<Contract['calls']['getRegistries']>) => getRequest('getRegistries', args),
  getAccessForLego: (...args: ExtractArgs<Contract['calls']['getAccessForLego']>) =>
    getRequest('getAccessForLego', args),
  legoId: (...args: ExtractArgs<Contract['calls']['legoId']>) => getRequest('legoId', args),
  hasClaimableRewards: (...args: ExtractArgs<Contract['calls']['hasClaimableRewards']>) =>
    getRequest('hasClaimableRewards', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'LegoCommon' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'LegoCommon'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  claimRewards: getMutation('claimRewards'),
  recoverFunds: getMutation('recoverFunds'),
  setLegoId: getMutation('setLegoId'),
}

export type SDK = {
  getRegistries: (...args: ExtractArgs<Contract['calls']['getRegistries']>) => Promise<CallReturn<'getRegistries'>>
  getAccessForLego: (
    ...args: ExtractArgs<Contract['calls']['getAccessForLego']>
  ) => Promise<CallReturn<'getAccessForLego'>>
  legoId: (...args: ExtractArgs<Contract['calls']['legoId']>) => Promise<CallReturn<'legoId'>>
  hasClaimableRewards: (
    ...args: ExtractArgs<Contract['calls']['hasClaimableRewards']>
  ) => Promise<CallReturn<'hasClaimableRewards'>>
  claimRewards: (...args: ExtractArgs<Contract['mutations']['claimRewards']>) => Promise<Address>
  recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) => Promise<Address>
  setLegoId: (...args: ExtractArgs<Contract['mutations']['setLegoId']>) => Promise<Address>
}

export function toSdk(address: Address, publicClient?: PublicClient, walletClient?: WalletClient): SDK {
  return {
    // Queries
    getRegistries: (...args: ExtractArgs<Contract['calls']['getRegistries']>) =>
      singleQuery(publicClient!, call.getRegistries(...args).at(address)) as Promise<CallReturn<'getRegistries'>>,
    getAccessForLego: (...args: ExtractArgs<Contract['calls']['getAccessForLego']>) =>
      singleQuery(publicClient!, call.getAccessForLego(...args).at(address)) as Promise<CallReturn<'getAccessForLego'>>,
    legoId: (...args: ExtractArgs<Contract['calls']['legoId']>) =>
      singleQuery(publicClient!, call.legoId(...args).at(address)) as Promise<CallReturn<'legoId'>>,
    hasClaimableRewards: (...args: ExtractArgs<Contract['calls']['hasClaimableRewards']>) =>
      singleQuery(publicClient!, call.hasClaimableRewards(...args).at(address)) as Promise<
        CallReturn<'hasClaimableRewards'>
      >,

    // Mutations
    claimRewards: (...args: ExtractArgs<Contract['mutations']['claimRewards']>) =>
      mutate(walletClient!, mutation.claimRewards, { address })(...args),
    recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) =>
      mutate(walletClient!, mutation.recoverFunds, { address })(...args),
    setLegoId: (...args: ExtractArgs<Contract['mutations']['setLegoId']>) =>
      mutate(walletClient!, mutation.setLegoId, { address })(...args),
  }
}
