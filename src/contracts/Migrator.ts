/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate, AddressResolverFunction } from '@dappql/async'
import {
  encodeEventTopics,
  parseEventLogs,
  ParseEventLogsReturnType,
  Log,
  RpcLog,
  PublicClient,
  WalletClient,
} from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    name: 'FundsMigrated',
    inputs: [
      {
        name: 'fromWallet',
        type: 'address',
        indexed: true,
      },
      {
        name: 'toWallet',
        type: 'address',
        indexed: true,
      },
      {
        name: 'numAssetsMigrated',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'totalUsdValue',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ConfigCloned',
    inputs: [
      {
        name: 'fromWallet',
        type: 'address',
        indexed: true,
      },
      {
        name: 'toWallet',
        type: 'address',
        indexed: true,
      },
      {
        name: 'numManagersCopied',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'numPayeesCopied',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'numWhitelistCopied',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'migrateAll',
    inputs: [
      {
        name: '_fromWallet',
        type: 'address',
      },
      {
        name: '_toWallet',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'migrateFunds',
    inputs: [
      {
        name: '_fromWallet',
        type: 'address',
      },
      {
        name: '_toWallet',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canMigrateFundsToNewWallet',
    inputs: [
      {
        name: '_fromWallet',
        type: 'address',
      },
      {
        name: '_toWallet',
        type: 'address',
      },
      {
        name: '_caller',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cloneConfig',
    inputs: [
      {
        name: '_fromWallet',
        type: 'address',
      },
      {
        name: '_toWallet',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canCopyWalletConfig',
    inputs: [
      {
        name: '_fromWallet',
        type: 'address',
      },
      {
        name: '_toWallet',
        type: 'address',
      },
      {
        name: '_caller',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getMigrationConfigBundle',
    inputs: [
      {
        name: '_userWallet',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'owner',
            type: 'address',
          },
          {
            name: 'isFrozen',
            type: 'bool',
          },
          {
            name: 'numPayees',
            type: 'uint256',
          },
          {
            name: 'numWhitelisted',
            type: 'uint256',
          },
          {
            name: 'numManagers',
            type: 'uint256',
          },
          {
            name: 'startingAgent',
            type: 'address',
          },
          {
            name: 'startingAgentIndex',
            type: 'uint256',
          },
          {
            name: 'hasPendingOwnerChange',
            type: 'bool',
          },
          {
            name: 'groupId',
            type: 'uint256',
          },
          {
            name: 'numActiveCheques',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'UNDY_HQ',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'constructor',
    inputs: [
      {
        name: '_undyHq',
        type: 'address',
      },
    ],
    outputs: [],
  },
] as const

export const deployAddress: Address | undefined = '0xe008114992187138a7C341Db0CD900F88BC0169a'

export type Contract = {
  calls: {
    canMigrateFundsToNewWallet: (
      fromWallet: `0x${string}`,
      toWallet: `0x${string}`,
      caller: `0x${string}`,
    ) => Promise<boolean>
    canCopyWalletConfig: (fromWallet: `0x${string}`, toWallet: `0x${string}`, caller: `0x${string}`) => Promise<boolean>
    getMigrationConfigBundle: (
      userWallet: `0x${string}`,
    ) => Promise<{
      owner: `0x${string}`
      isFrozen: boolean
      numPayees: bigint
      numWhitelisted: bigint
      numManagers: bigint
      startingAgent: `0x${string}`
      startingAgentIndex: bigint
      hasPendingOwnerChange: boolean
      groupId: bigint
      numActiveCheques: bigint
    }>
    UNDY_HQ: () => Promise<`0x${string}`>
  }
  mutations: {
    migrateAll: (fromWallet: `0x${string}`, toWallet: `0x${string}`) => Promise<[bigint, boolean]>
    migrateFunds: (fromWallet: `0x${string}`, toWallet: `0x${string}`) => Promise<bigint>
    cloneConfig: (fromWallet: `0x${string}`, toWallet: `0x${string}`) => Promise<boolean>
  }
  events: {
    FundsMigrated: (
      fromWallet: `0x${string}`,
      toWallet: `0x${string}`,
      numAssetsMigrated: bigint,
      totalUsdValue: bigint,
    ) => Promise<void>
    ConfigCloned: (
      fromWallet: `0x${string}`,
      toWallet: `0x${string}`,
      numManagersCopied: bigint,
      numPayeesCopied: bigint,
      numWhitelistCopied: bigint,
    ) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'Migrator'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'Migrator' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  canMigrateFundsToNewWallet: (...args: ExtractArgs<Contract['calls']['canMigrateFundsToNewWallet']>) =>
    getRequest('canMigrateFundsToNewWallet', args),
  canCopyWalletConfig: (...args: ExtractArgs<Contract['calls']['canCopyWalletConfig']>) =>
    getRequest('canCopyWalletConfig', args),
  getMigrationConfigBundle: (...args: ExtractArgs<Contract['calls']['getMigrationConfigBundle']>) =>
    getRequest('getMigrationConfigBundle', args),
  UNDY_HQ: (...args: ExtractArgs<Contract['calls']['UNDY_HQ']>) => getRequest('UNDY_HQ', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'Migrator' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'Migrator'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  migrateAll: getMutation('migrateAll'),
  migrateFunds: getMutation('migrateFunds'),
  cloneConfig: getMutation('cloneConfig'),
}

export type ParsedEvent<T extends keyof Contract['events']> = {
  event: RpcLog | Log
  parsed: ParseEventLogsReturnType<typeof abi, T>
}

export function parseEvents<T extends keyof Contract['events']>(
  eventName: T,
  events: (RpcLog | Log)[],
): ParsedEvent<T>[] {
  return events.map((event) => {
    return {
      event,
      parsed: parseEventLogs({
        abi,
        eventName,
        logs: [event],
      }),
    }
  })
}

export function getEventTopic<T extends keyof Contract['events']>(eventName: T): Address {
  return encodeEventTopics({ abi, eventName })[0] as Address
}

export type SDK = {
  deployAddress: Address | undefined
  abi: typeof abi
  events: {
    FundsMigrated: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'FundsMigrated'>[] }
    ConfigCloned: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ConfigCloned'>[] }
  }
  canMigrateFundsToNewWallet: (
    ...args: ExtractArgs<Contract['calls']['canMigrateFundsToNewWallet']>
  ) => Promise<CallReturn<'canMigrateFundsToNewWallet'>>
  canCopyWalletConfig: (
    ...args: ExtractArgs<Contract['calls']['canCopyWalletConfig']>
  ) => Promise<CallReturn<'canCopyWalletConfig'>>
  getMigrationConfigBundle: (
    ...args: ExtractArgs<Contract['calls']['getMigrationConfigBundle']>
  ) => Promise<CallReturn<'getMigrationConfigBundle'>>
  UNDY_HQ: (...args: ExtractArgs<Contract['calls']['UNDY_HQ']>) => Promise<CallReturn<'UNDY_HQ'>>
  migrateAll: (...args: ExtractArgs<Contract['mutations']['migrateAll']>) => Promise<Address>
  migrateFunds: (...args: ExtractArgs<Contract['mutations']['migrateFunds']>) => Promise<Address>
  cloneConfig: (...args: ExtractArgs<Contract['mutations']['cloneConfig']>) => Promise<Address>
}

export function toSdk(
  publicClient?: PublicClient,
  walletClient?: WalletClient,
  addressResolver?: AddressResolverFunction,
): SDK {
  return {
    deployAddress,
    abi,

    events: {
      FundsMigrated: {
        topic: getEventTopic('FundsMigrated'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('FundsMigrated', events),
      },
      ConfigCloned: {
        topic: getEventTopic('ConfigCloned'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ConfigCloned', events),
      },
    },
    // Queries
    canMigrateFundsToNewWallet: (...args: ExtractArgs<Contract['calls']['canMigrateFundsToNewWallet']>) =>
      singleQuery(publicClient!, call.canMigrateFundsToNewWallet(...args), {}, addressResolver) as Promise<
        CallReturn<'canMigrateFundsToNewWallet'>
      >,
    canCopyWalletConfig: (...args: ExtractArgs<Contract['calls']['canCopyWalletConfig']>) =>
      singleQuery(publicClient!, call.canCopyWalletConfig(...args), {}, addressResolver) as Promise<
        CallReturn<'canCopyWalletConfig'>
      >,
    getMigrationConfigBundle: (...args: ExtractArgs<Contract['calls']['getMigrationConfigBundle']>) =>
      singleQuery(publicClient!, call.getMigrationConfigBundle(...args), {}, addressResolver) as Promise<
        CallReturn<'getMigrationConfigBundle'>
      >,
    UNDY_HQ: (...args: ExtractArgs<Contract['calls']['UNDY_HQ']>) =>
      singleQuery(publicClient!, call.UNDY_HQ(...args), {}, addressResolver) as Promise<CallReturn<'UNDY_HQ'>>,

    // Mutations
    migrateAll: (...args: ExtractArgs<Contract['mutations']['migrateAll']>) =>
      mutate(walletClient!, mutation.migrateAll, { addressResolver })(...args),
    migrateFunds: (...args: ExtractArgs<Contract['mutations']['migrateFunds']>) =>
      mutate(walletClient!, mutation.migrateFunds, { addressResolver })(...args),
    cloneConfig: (...args: ExtractArgs<Contract['mutations']['cloneConfig']>) =>
      mutate(walletClient!, mutation.cloneConfig, { addressResolver })(...args),
  }
}
