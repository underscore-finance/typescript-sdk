/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate, AddressResolverFunction } from '@dappql/async'
import {
  encodeEventTopics,
  parseEventLogs,
  ParseEventLogsReturnType,
  Log,
  RpcLog,
  PublicClient,
  WalletClient,
} from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    name: 'NonceIncremented',
    inputs: [
      {
        name: 'userWallet',
        type: 'address',
        indexed: false,
      },
      {
        name: 'oldNonce',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'newNonce',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'OwnershipChangeInitiated',
    inputs: [
      {
        name: 'prevOwner',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newOwner',
        type: 'address',
        indexed: true,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'OwnershipChangeConfirmed',
    inputs: [
      {
        name: 'prevOwner',
        type: 'address',
        indexed: true,
      },
      {
        name: 'newOwner',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'OwnershipChangeCancelled',
    inputs: [
      {
        name: 'cancelledOwner',
        type: 'address',
        indexed: true,
      },
      {
        name: 'cancelledBy',
        type: 'address',
        indexed: true,
      },
      {
        name: 'initiatedBlock',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'confirmBlock',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'OwnershipTimeLockSet',
    inputs: [
      {
        name: 'numBlocks',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'changeOwnership',
    inputs: [
      {
        name: '_newOwner',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmOwnershipChange',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'cancelOwnershipChange',
    inputs: [],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasPendingOwnerChange',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setOwnershipTimeLock',
    inputs: [
      {
        name: '_numBlocks',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'owner',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'ownershipTimeLock',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'pendingOwner',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'newOwner',
            type: 'address',
          },
          {
            name: 'initiatedBlock',
            type: 'uint256',
          },
          {
            name: 'confirmBlock',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'MIN_OWNERSHIP_TIMELOCK',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'MAX_OWNERSHIP_TIMELOCK',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateralAndBorrow',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateralAndBorrow',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateralAndBorrow',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_greenBorrowAmount',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateralAndBorrow',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_greenBorrowAmount',
        type: 'uint256',
      },
      {
        name: '_wantsSavingsGreen',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateralAndBorrow',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_greenBorrowAmount',
        type: 'uint256',
      },
      {
        name: '_wantsSavingsGreen',
        type: 'bool',
      },
      {
        name: '_shouldEnterStabPool',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateralAndBorrow',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_greenBorrowAmount',
        type: 'uint256',
      },
      {
        name: '_wantsSavingsGreen',
        type: 'bool',
      },
      {
        name: '_shouldEnterStabPool',
        type: 'bool',
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateralAndBorrow',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_greenBorrowAmount',
        type: 'uint256',
      },
      {
        name: '_wantsSavingsGreen',
        type: 'bool',
      },
      {
        name: '_shouldEnterStabPool',
        type: 'bool',
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_yieldPosition',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateralAndBorrow',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_greenBorrowAmount',
        type: 'uint256',
      },
      {
        name: '_wantsSavingsGreen',
        type: 'bool',
      },
      {
        name: '_shouldEnterStabPool',
        type: 'bool',
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_yieldPosition',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
      {
        name: '_sig',
        type: 'tuple',
        components: [
          {
            name: 'signature',
            type: 'bytes',
          },
          {
            name: 'nonce',
            type: 'uint256',
          },
          {
            name: 'expiration',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayAndWithdraw',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayAndWithdraw',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_deleverageAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'targetRepayAmount',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayAndWithdraw',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_deleverageAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'targetRepayAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_yieldPosition',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayAndWithdraw',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_deleverageAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'targetRepayAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_yieldPosition',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayAndWithdraw',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_deleverageAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'targetRepayAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_yieldPosition',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_repayAsset',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayAndWithdraw',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_deleverageAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'targetRepayAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_yieldPosition',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_repayAsset',
        type: 'address',
      },
      {
        name: '_repayAmount',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayAndWithdraw',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_deleverageAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'targetRepayAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_yieldPosition',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_repayAsset',
        type: 'address',
      },
      {
        name: '_repayAmount',
        type: 'uint256',
      },
      {
        name: '_removeCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayAndWithdraw',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_deleverageAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'targetRepayAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_yieldPosition',
        type: 'tuple',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_repayAsset',
        type: 'address',
      },
      {
        name: '_repayAmount',
        type: 'uint256',
      },
      {
        name: '_removeCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_sig',
        type: 'tuple',
        components: [
          {
            name: 'signature',
            type: 'bytes',
          },
          {
            name: 'nonce',
            type: 'uint256',
          },
          {
            name: 'expiration',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'rebalanceYieldPositionsWithSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'rebalanceYieldPositionsWithSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_withdrawFrom',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'rebalanceYieldPositionsWithSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_withdrawFrom',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'rebalanceYieldPositionsWithSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_withdrawFrom',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_depositTo',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'rebalanceYieldPositionsWithSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_withdrawFrom',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_depositTo',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
      {
        name: '_transferTo',
        type: 'tuple[]',
        components: [
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'recipient',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'rebalanceYieldPositionsWithSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_withdrawFrom',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'vaultToken',
            type: 'address',
          },
          {
            name: 'vaultTokenAmount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_depositTo',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
      {
        name: '_transferTo',
        type: 'tuple[]',
        components: [
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'recipient',
            type: 'address',
          },
        ],
      },
      {
        name: '_sig',
        type: 'tuple',
        components: [
          {
            name: 'signature',
            type: 'bytes',
          },
          {
            name: 'nonce',
            type: 'uint256',
          },
          {
            name: 'expiration',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_rewardProofs',
        type: 'bytes32[]',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_rewardProofs',
        type: 'bytes32[]',
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_rewardProofs',
        type: 'bytes32[]',
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_depositTo',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_rewardProofs',
        type: 'bytes32[]',
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_depositTo',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_rewardProofs',
        type: 'bytes32[]',
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_depositTo',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentivesAndSwap',
    inputs: [
      {
        name: '_agentWrapper',
        type: 'address',
      },
      {
        name: '_userWallet',
        type: 'address',
      },
      {
        name: '_rewardLegoId',
        type: 'uint256',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_rewardProofs',
        type: 'bytes32[]',
      },
      {
        name: '_swapInstructions',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'amountIn',
            type: 'uint256',
          },
          {
            name: 'minAmountOut',
            type: 'uint256',
          },
          {
            name: 'tokenPath',
            type: 'address[]',
          },
          {
            name: 'poolPath',
            type: 'address[]',
          },
        ],
      },
      {
        name: '_depositTo',
        type: 'tuple[]',
        components: [
          {
            name: 'legoId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
          {
            name: 'vaultAddr',
            type: 'address',
          },
        ],
      },
      {
        name: '_debtLegoId',
        type: 'uint256',
      },
      {
        name: '_addCollateralAssets',
        type: 'tuple[]',
        components: [
          {
            name: 'vaultId',
            type: 'uint256',
          },
          {
            name: 'asset',
            type: 'address',
          },
          {
            name: 'amount',
            type: 'uint256',
          },
        ],
      },
      {
        name: '_sig',
        type: 'tuple',
        components: [
          {
            name: 'signature',
            type: 'bytes',
          },
          {
            name: 'nonce',
            type: 'uint256',
          },
          {
            name: 'expiration',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'incrementNonce',
    inputs: [
      {
        name: '_userWallet',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getNonce',
    inputs: [
      {
        name: '_userWallet',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'currentNonce',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'UNDY_HQ',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'RIPE_GREEN_TOKEN',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'RIPE_SAVINGS_GREEN',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'constructor',
    inputs: [
      {
        name: '_undyHq',
        type: 'address',
      },
      {
        name: '_owner',
        type: 'address',
      },
      {
        name: '_minTimeLock',
        type: 'uint256',
      },
      {
        name: '_maxTimeLock',
        type: 'uint256',
      },
      {
        name: '_greenToken',
        type: 'address',
      },
      {
        name: '_savingsGreen',
        type: 'address',
      },
    ],
    outputs: [],
  },
] as const

export const deployAddress: Address | undefined = '0xF02Bc5c9a1A57015C09c4e1B89A273a2849874D3'

export type Contract = {
  calls: {
    hasPendingOwnerChange: () => Promise<boolean>
    owner: () => Promise<`0x${string}`>
    ownershipTimeLock: () => Promise<bigint>
    pendingOwner: () => Promise<{ newOwner: `0x${string}`; initiatedBlock: bigint; confirmBlock: bigint }>
    MIN_OWNERSHIP_TIMELOCK: () => Promise<bigint>
    MAX_OWNERSHIP_TIMELOCK: () => Promise<bigint>
    getNonce: (userWallet: `0x${string}`) => Promise<bigint>
    currentNonce: (arg0: `0x${string}`) => Promise<bigint>
    UNDY_HQ: () => Promise<`0x${string}`>
    RIPE_GREEN_TOKEN: () => Promise<`0x${string}`>
    RIPE_SAVINGS_GREEN: () => Promise<`0x${string}`>
  }
  mutations: {
    changeOwnership: (newOwner: `0x${string}`) => Promise<void>
    confirmOwnershipChange: () => Promise<void>
    cancelOwnershipChange: () => Promise<void>
    setOwnershipTimeLock: (numBlocks: bigint) => Promise<void>
    addCollateralAndBorrow: (
      agentWrapper: `0x${string}`,
      userWallet: `0x${string}`,
      debtLegoId: bigint,
      addCollateralAssets?: { vaultId: bigint; asset: `0x${string}`; amount: bigint }[],
      greenBorrowAmount?: bigint,
      wantsSavingsGreen?: boolean,
      shouldEnterStabPool?: boolean,
      swapInstructions?: {
        legoId: bigint
        amountIn: bigint
        minAmountOut: bigint
        tokenPath: `0x${string}`[]
        poolPath: `0x${string}`[]
      }[],
      yieldPosition?: { legoId: bigint; asset: `0x${string}`; amount: bigint; vaultAddr: `0x${string}` },
      sig?: { signature: `0x${string}`; nonce: bigint; expiration: bigint },
    ) => Promise<void>
    repayAndWithdraw: (
      agentWrapper: `0x${string}`,
      userWallet: `0x${string}`,
      debtLegoId: bigint,
      deleverageAssets?: { vaultId: bigint; asset: `0x${string}`; targetRepayAmount: bigint }[],
      yieldPosition?: { legoId: bigint; vaultToken: `0x${string}`; vaultTokenAmount: bigint },
      swapInstructions?: {
        legoId: bigint
        amountIn: bigint
        minAmountOut: bigint
        tokenPath: `0x${string}`[]
        poolPath: `0x${string}`[]
      }[],
      repayAsset?: `0x${string}`,
      repayAmount?: bigint,
      removeCollateralAssets?: { vaultId: bigint; asset: `0x${string}`; amount: bigint }[],
      sig?: { signature: `0x${string}`; nonce: bigint; expiration: bigint },
    ) => Promise<void>
    rebalanceYieldPositionsWithSwap: (
      agentWrapper: `0x${string}`,
      userWallet: `0x${string}`,
      withdrawFrom?: { legoId: bigint; vaultToken: `0x${string}`; vaultTokenAmount: bigint }[],
      swapInstructions?: {
        legoId: bigint
        amountIn: bigint
        minAmountOut: bigint
        tokenPath: `0x${string}`[]
        poolPath: `0x${string}`[]
      }[],
      depositTo?: { legoId: bigint; asset: `0x${string}`; amount: bigint; vaultAddr: `0x${string}` }[],
      transferTo?: { asset: `0x${string}`; amount: bigint; recipient: `0x${string}` }[],
      sig?: { signature: `0x${string}`; nonce: bigint; expiration: bigint },
    ) => Promise<void>
    claimIncentivesAndSwap: (
      agentWrapper: `0x${string}`,
      userWallet: `0x${string}`,
      rewardLegoId?: bigint,
      rewardToken?: `0x${string}`,
      rewardAmount?: bigint,
      rewardProofs?: `0x${string}`[],
      swapInstructions?: {
        legoId: bigint
        amountIn: bigint
        minAmountOut: bigint
        tokenPath: `0x${string}`[]
        poolPath: `0x${string}`[]
      }[],
      depositTo?: { legoId: bigint; asset: `0x${string}`; amount: bigint; vaultAddr: `0x${string}` }[],
      debtLegoId?: bigint,
      addCollateralAssets?: { vaultId: bigint; asset: `0x${string}`; amount: bigint }[],
      sig?: { signature: `0x${string}`; nonce: bigint; expiration: bigint },
    ) => Promise<void>
    incrementNonce: (userWallet: `0x${string}`) => Promise<void>
  }
  events: {
    NonceIncremented: (userWallet: `0x${string}`, oldNonce: bigint, newNonce: bigint) => Promise<void>
    OwnershipChangeInitiated: (prevOwner: `0x${string}`, newOwner: `0x${string}`, confirmBlock: bigint) => Promise<void>
    OwnershipChangeConfirmed: (
      prevOwner: `0x${string}`,
      newOwner: `0x${string}`,
      initiatedBlock: bigint,
      confirmBlock: bigint,
    ) => Promise<void>
    OwnershipChangeCancelled: (
      cancelledOwner: `0x${string}`,
      cancelledBy: `0x${string}`,
      initiatedBlock: bigint,
      confirmBlock: bigint,
    ) => Promise<void>
    OwnershipTimeLockSet: (numBlocks: bigint) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'AgentSenderSpecial'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'AgentSenderSpecial' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  hasPendingOwnerChange: (...args: ExtractArgs<Contract['calls']['hasPendingOwnerChange']>) =>
    getRequest('hasPendingOwnerChange', args),
  owner: (...args: ExtractArgs<Contract['calls']['owner']>) => getRequest('owner', args),
  ownershipTimeLock: (...args: ExtractArgs<Contract['calls']['ownershipTimeLock']>) =>
    getRequest('ownershipTimeLock', args),
  pendingOwner: (...args: ExtractArgs<Contract['calls']['pendingOwner']>) => getRequest('pendingOwner', args),
  MIN_OWNERSHIP_TIMELOCK: (...args: ExtractArgs<Contract['calls']['MIN_OWNERSHIP_TIMELOCK']>) =>
    getRequest('MIN_OWNERSHIP_TIMELOCK', args),
  MAX_OWNERSHIP_TIMELOCK: (...args: ExtractArgs<Contract['calls']['MAX_OWNERSHIP_TIMELOCK']>) =>
    getRequest('MAX_OWNERSHIP_TIMELOCK', args),
  getNonce: (...args: ExtractArgs<Contract['calls']['getNonce']>) => getRequest('getNonce', args),
  currentNonce: (...args: ExtractArgs<Contract['calls']['currentNonce']>) => getRequest('currentNonce', args),
  UNDY_HQ: (...args: ExtractArgs<Contract['calls']['UNDY_HQ']>) => getRequest('UNDY_HQ', args),
  RIPE_GREEN_TOKEN: (...args: ExtractArgs<Contract['calls']['RIPE_GREEN_TOKEN']>) =>
    getRequest('RIPE_GREEN_TOKEN', args),
  RIPE_SAVINGS_GREEN: (...args: ExtractArgs<Contract['calls']['RIPE_SAVINGS_GREEN']>) =>
    getRequest('RIPE_SAVINGS_GREEN', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'AgentSenderSpecial' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'AgentSenderSpecial'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  changeOwnership: getMutation('changeOwnership'),
  confirmOwnershipChange: getMutation('confirmOwnershipChange'),
  cancelOwnershipChange: getMutation('cancelOwnershipChange'),
  setOwnershipTimeLock: getMutation('setOwnershipTimeLock'),
  addCollateralAndBorrow: getMutation('addCollateralAndBorrow'),
  repayAndWithdraw: getMutation('repayAndWithdraw'),
  rebalanceYieldPositionsWithSwap: getMutation('rebalanceYieldPositionsWithSwap'),
  claimIncentivesAndSwap: getMutation('claimIncentivesAndSwap'),
  incrementNonce: getMutation('incrementNonce'),
}

export type ParsedEvent<T extends keyof Contract['events']> = {
  event: RpcLog | Log
  parsed: ParseEventLogsReturnType<typeof abi, T>
}

export function parseEvents<T extends keyof Contract['events']>(
  eventName: T,
  events: (RpcLog | Log)[],
): ParsedEvent<T>[] {
  return events.map((event) => {
    return {
      event,
      parsed: parseEventLogs({
        abi,
        eventName,
        logs: [event],
      }),
    }
  })
}

export function getEventTopic<T extends keyof Contract['events']>(eventName: T): Address {
  return encodeEventTopics({ abi, eventName })[0] as Address
}

export type SDK = {
  deployAddress: Address | undefined
  abi: typeof abi
  events: {
    NonceIncremented: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'NonceIncremented'>[] }
    OwnershipChangeInitiated: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'OwnershipChangeInitiated'>[]
    }
    OwnershipChangeConfirmed: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'OwnershipChangeConfirmed'>[]
    }
    OwnershipChangeCancelled: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'OwnershipChangeCancelled'>[]
    }
    OwnershipTimeLockSet: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'OwnershipTimeLockSet'>[] }
  }
  hasPendingOwnerChange: (
    ...args: ExtractArgs<Contract['calls']['hasPendingOwnerChange']>
  ) => Promise<CallReturn<'hasPendingOwnerChange'>>
  owner: (...args: ExtractArgs<Contract['calls']['owner']>) => Promise<CallReturn<'owner'>>
  ownershipTimeLock: (
    ...args: ExtractArgs<Contract['calls']['ownershipTimeLock']>
  ) => Promise<CallReturn<'ownershipTimeLock'>>
  pendingOwner: (...args: ExtractArgs<Contract['calls']['pendingOwner']>) => Promise<CallReturn<'pendingOwner'>>
  MIN_OWNERSHIP_TIMELOCK: (
    ...args: ExtractArgs<Contract['calls']['MIN_OWNERSHIP_TIMELOCK']>
  ) => Promise<CallReturn<'MIN_OWNERSHIP_TIMELOCK'>>
  MAX_OWNERSHIP_TIMELOCK: (
    ...args: ExtractArgs<Contract['calls']['MAX_OWNERSHIP_TIMELOCK']>
  ) => Promise<CallReturn<'MAX_OWNERSHIP_TIMELOCK'>>
  getNonce: (...args: ExtractArgs<Contract['calls']['getNonce']>) => Promise<CallReturn<'getNonce'>>
  currentNonce: (...args: ExtractArgs<Contract['calls']['currentNonce']>) => Promise<CallReturn<'currentNonce'>>
  UNDY_HQ: (...args: ExtractArgs<Contract['calls']['UNDY_HQ']>) => Promise<CallReturn<'UNDY_HQ'>>
  RIPE_GREEN_TOKEN: (
    ...args: ExtractArgs<Contract['calls']['RIPE_GREEN_TOKEN']>
  ) => Promise<CallReturn<'RIPE_GREEN_TOKEN'>>
  RIPE_SAVINGS_GREEN: (
    ...args: ExtractArgs<Contract['calls']['RIPE_SAVINGS_GREEN']>
  ) => Promise<CallReturn<'RIPE_SAVINGS_GREEN'>>
  changeOwnership: (...args: ExtractArgs<Contract['mutations']['changeOwnership']>) => Promise<Address>
  confirmOwnershipChange: (...args: ExtractArgs<Contract['mutations']['confirmOwnershipChange']>) => Promise<Address>
  cancelOwnershipChange: (...args: ExtractArgs<Contract['mutations']['cancelOwnershipChange']>) => Promise<Address>
  setOwnershipTimeLock: (...args: ExtractArgs<Contract['mutations']['setOwnershipTimeLock']>) => Promise<Address>
  addCollateralAndBorrow: (...args: ExtractArgs<Contract['mutations']['addCollateralAndBorrow']>) => Promise<Address>
  repayAndWithdraw: (...args: ExtractArgs<Contract['mutations']['repayAndWithdraw']>) => Promise<Address>
  rebalanceYieldPositionsWithSwap: (
    ...args: ExtractArgs<Contract['mutations']['rebalanceYieldPositionsWithSwap']>
  ) => Promise<Address>
  claimIncentivesAndSwap: (...args: ExtractArgs<Contract['mutations']['claimIncentivesAndSwap']>) => Promise<Address>
  incrementNonce: (...args: ExtractArgs<Contract['mutations']['incrementNonce']>) => Promise<Address>
}

export function toSdk(
  publicClient?: PublicClient,
  walletClient?: WalletClient,
  addressResolver?: AddressResolverFunction,
): SDK {
  return {
    deployAddress,
    abi,

    events: {
      NonceIncremented: {
        topic: getEventTopic('NonceIncremented'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('NonceIncremented', events),
      },
      OwnershipChangeInitiated: {
        topic: getEventTopic('OwnershipChangeInitiated'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('OwnershipChangeInitiated', events),
      },
      OwnershipChangeConfirmed: {
        topic: getEventTopic('OwnershipChangeConfirmed'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('OwnershipChangeConfirmed', events),
      },
      OwnershipChangeCancelled: {
        topic: getEventTopic('OwnershipChangeCancelled'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('OwnershipChangeCancelled', events),
      },
      OwnershipTimeLockSet: {
        topic: getEventTopic('OwnershipTimeLockSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('OwnershipTimeLockSet', events),
      },
    },
    // Queries
    hasPendingOwnerChange: (...args: ExtractArgs<Contract['calls']['hasPendingOwnerChange']>) =>
      singleQuery(publicClient!, call.hasPendingOwnerChange(...args), {}, addressResolver) as Promise<
        CallReturn<'hasPendingOwnerChange'>
      >,
    owner: (...args: ExtractArgs<Contract['calls']['owner']>) =>
      singleQuery(publicClient!, call.owner(...args), {}, addressResolver) as Promise<CallReturn<'owner'>>,
    ownershipTimeLock: (...args: ExtractArgs<Contract['calls']['ownershipTimeLock']>) =>
      singleQuery(publicClient!, call.ownershipTimeLock(...args), {}, addressResolver) as Promise<
        CallReturn<'ownershipTimeLock'>
      >,
    pendingOwner: (...args: ExtractArgs<Contract['calls']['pendingOwner']>) =>
      singleQuery(publicClient!, call.pendingOwner(...args), {}, addressResolver) as Promise<
        CallReturn<'pendingOwner'>
      >,
    MIN_OWNERSHIP_TIMELOCK: (...args: ExtractArgs<Contract['calls']['MIN_OWNERSHIP_TIMELOCK']>) =>
      singleQuery(publicClient!, call.MIN_OWNERSHIP_TIMELOCK(...args), {}, addressResolver) as Promise<
        CallReturn<'MIN_OWNERSHIP_TIMELOCK'>
      >,
    MAX_OWNERSHIP_TIMELOCK: (...args: ExtractArgs<Contract['calls']['MAX_OWNERSHIP_TIMELOCK']>) =>
      singleQuery(publicClient!, call.MAX_OWNERSHIP_TIMELOCK(...args), {}, addressResolver) as Promise<
        CallReturn<'MAX_OWNERSHIP_TIMELOCK'>
      >,
    getNonce: (...args: ExtractArgs<Contract['calls']['getNonce']>) =>
      singleQuery(publicClient!, call.getNonce(...args), {}, addressResolver) as Promise<CallReturn<'getNonce'>>,
    currentNonce: (...args: ExtractArgs<Contract['calls']['currentNonce']>) =>
      singleQuery(publicClient!, call.currentNonce(...args), {}, addressResolver) as Promise<
        CallReturn<'currentNonce'>
      >,
    UNDY_HQ: (...args: ExtractArgs<Contract['calls']['UNDY_HQ']>) =>
      singleQuery(publicClient!, call.UNDY_HQ(...args), {}, addressResolver) as Promise<CallReturn<'UNDY_HQ'>>,
    RIPE_GREEN_TOKEN: (...args: ExtractArgs<Contract['calls']['RIPE_GREEN_TOKEN']>) =>
      singleQuery(publicClient!, call.RIPE_GREEN_TOKEN(...args), {}, addressResolver) as Promise<
        CallReturn<'RIPE_GREEN_TOKEN'>
      >,
    RIPE_SAVINGS_GREEN: (...args: ExtractArgs<Contract['calls']['RIPE_SAVINGS_GREEN']>) =>
      singleQuery(publicClient!, call.RIPE_SAVINGS_GREEN(...args), {}, addressResolver) as Promise<
        CallReturn<'RIPE_SAVINGS_GREEN'>
      >,

    // Mutations
    changeOwnership: (...args: ExtractArgs<Contract['mutations']['changeOwnership']>) =>
      mutate(walletClient!, mutation.changeOwnership, { addressResolver })(...args),
    confirmOwnershipChange: (...args: ExtractArgs<Contract['mutations']['confirmOwnershipChange']>) =>
      mutate(walletClient!, mutation.confirmOwnershipChange, { addressResolver })(...args),
    cancelOwnershipChange: (...args: ExtractArgs<Contract['mutations']['cancelOwnershipChange']>) =>
      mutate(walletClient!, mutation.cancelOwnershipChange, { addressResolver })(...args),
    setOwnershipTimeLock: (...args: ExtractArgs<Contract['mutations']['setOwnershipTimeLock']>) =>
      mutate(walletClient!, mutation.setOwnershipTimeLock, { addressResolver })(...args),
    addCollateralAndBorrow: (...args: ExtractArgs<Contract['mutations']['addCollateralAndBorrow']>) =>
      mutate(walletClient!, mutation.addCollateralAndBorrow, { addressResolver })(...args),
    repayAndWithdraw: (...args: ExtractArgs<Contract['mutations']['repayAndWithdraw']>) =>
      mutate(walletClient!, mutation.repayAndWithdraw, { addressResolver })(...args),
    rebalanceYieldPositionsWithSwap: (...args: ExtractArgs<Contract['mutations']['rebalanceYieldPositionsWithSwap']>) =>
      mutate(walletClient!, mutation.rebalanceYieldPositionsWithSwap, { addressResolver })(...args),
    claimIncentivesAndSwap: (...args: ExtractArgs<Contract['mutations']['claimIncentivesAndSwap']>) =>
      mutate(walletClient!, mutation.claimIncentivesAndSwap, { addressResolver })(...args),
    incrementNonce: (...args: ExtractArgs<Contract['mutations']['incrementNonce']>) =>
      mutate(walletClient!, mutation.incrementNonce, { addressResolver })(...args),
  }
}
