/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
/* @ts-nocheck */

import { singleQuery, mutate, AddressResolverFunction } from '@dappql/async'
import {
  encodeEventTopics,
  parseEventLogs,
  ParseEventLogsReturnType,
  Log,
  RpcLog,
  PublicClient,
  WalletClient,
} from 'viem'

type ExtractArgs<T> = T extends (...args: infer P) => any ? P : never
type Address = `0x${string}`

export const abi = [
  {
    name: 'ExtraFiDeposit',
    inputs: [
      {
        name: 'sender',
        type: 'address',
        indexed: true,
      },
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'assetAmountDeposited',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'usdValue',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'vaultTokenAmountReceived',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'recipient',
        type: 'address',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'ExtraFiWithdrawal',
    inputs: [
      {
        name: 'sender',
        type: 'address',
        indexed: true,
      },
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'assetAmountReceived',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'usdValue',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'vaultTokenAmountBurned',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'recipient',
        type: 'address',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AssetOpportunityAdded',
    inputs: [
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'LegoPauseModified',
    inputs: [
      {
        name: 'isPaused',
        type: 'bool',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'LegoFundsRecovered',
    inputs: [
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'recipient',
        type: 'address',
        indexed: true,
      },
      {
        name: 'balance',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'SnapShotPriceConfigSet',
    inputs: [
      {
        name: 'minSnapshotDelay',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'maxNumSnapshots',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'maxUpsideDeviation',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'staleTime',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'AssetOpportunityRemoved',
    inputs: [
      {
        name: 'asset',
        type: 'address',
        indexed: true,
      },
      {
        name: 'vaultAddr',
        type: 'address',
        indexed: true,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    name: 'PricePerShareSnapShotAdded',
    inputs: [
      {
        name: 'vaultToken',
        type: 'address',
        indexed: true,
      },
      {
        name: 'totalSupply',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'pricePerShare',
        type: 'uint256',
        indexed: false,
      },
      {
        name: 'lastAveragePricePerShare',
        type: 'uint256',
        indexed: false,
      },
    ],
    anonymous: false,
    type: 'event',
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAddys',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'hq',
            type: 'address',
          },
          {
            name: 'undyToken',
            type: 'address',
          },
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'switchboard',
            type: 'address',
          },
          {
            name: 'hatchery',
            type: 'address',
          },
          {
            name: 'lootDistributor',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
          {
            name: 'walletBackpack',
            type: 'address',
          },
          {
            name: 'billing',
            type: 'address',
          },
          {
            name: 'vaultRegistry',
            type: 'address',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUndyHq',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isLegoAsset',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAssetOpportunities',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAssets',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isAssetOpportunity',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getNumLegoAssets',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'pause',
    inputs: [
      {
        name: '_shouldPause',
        type: 'bool',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFunds',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'recoverFundsMany',
    inputs: [
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_assets',
        type: 'address[]',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getWeightedPricePerShare',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getLatestSnapshot',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_pricePerShare',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'totalSupply',
            type: 'uint256',
          },
          {
            name: 'pricePerShare',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'setSnapShotPriceConfig',
    inputs: [
      {
        name: '_config',
        type: 'tuple',
        components: [
          {
            name: 'minSnapshotDelay',
            type: 'uint256',
          },
          {
            name: 'maxNumSnapshots',
            type: 'uint256',
          },
          {
            name: 'maxUpsideDeviation',
            type: 'uint256',
          },
          {
            name: 'staleTime',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isValidPriceConfig',
    inputs: [
      {
        name: '_config',
        type: 'tuple',
        components: [
          {
            name: 'minSnapshotDelay',
            type: 'uint256',
          },
          {
            name: 'maxNumSnapshots',
            type: 'uint256',
          },
          {
            name: 'maxUpsideDeviation',
            type: 'uint256',
          },
          {
            name: 'staleTime',
            type: 'uint256',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'vaultToAsset',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'underlyingAsset',
            type: 'address',
          },
          {
            name: 'decimals',
            type: 'uint256',
          },
          {
            name: 'lastAveragePricePerShare',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'assetOpportunities',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'indexOfAssetOpportunity',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numAssetOpportunities',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'assets',
    inputs: [
      {
        name: 'arg0',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'indexOfAsset',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'numAssets',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'snapShotData',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'lastSnapShot',
            type: 'tuple',
            components: [
              {
                name: 'totalSupply',
                type: 'uint256',
              },
              {
                name: 'pricePerShare',
                type: 'uint256',
              },
              {
                name: 'lastUpdate',
                type: 'uint256',
              },
            ],
          },
          {
            name: 'nextIndex',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'snapShots',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
      {
        name: 'arg1',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'totalSupply',
            type: 'uint256',
          },
          {
            name: 'pricePerShare',
            type: 'uint256',
          },
          {
            name: 'lastUpdate',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'snapShotPriceConfig',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'minSnapshotDelay',
            type: 'uint256',
          },
          {
            name: 'maxNumSnapshots',
            type: 'uint256',
          },
          {
            name: 'maxUpsideDeviation',
            type: 'uint256',
          },
          {
            name: 'staleTime',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isPaused',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasCapability',
    inputs: [
      {
        name: '_action',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getRegistries',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address[]',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isYieldLego',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isDexLego',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUnderlyingAsset',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUnderlyingBalances',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_vaultTokenBalance',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUnderlyingAmount',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_vaultTokenAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUnderlyingAmountSafe',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_vaultTokenBalance',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUnderlyingData',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_vaultTokenAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUnderlyingData',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_vaultTokenAmount',
        type: 'uint256',
      },
      {
        name: '_appraiser',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUsdValueOfVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_vaultTokenAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUsdValueOfVaultToken',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_vaultTokenAmount',
        type: 'uint256',
      },
      {
        name: '_appraiser',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isRebasing',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getPricePerShare',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getPricePerShare',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_decimals',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getVaultTokenAmount',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_assetAmount',
        type: 'uint256',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'totalAssets',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'totalBorrows',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAvailLiquidity',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getUtilizationRatio',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'isEligibleForYieldBonus',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getWithdrawalFees',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_vaultTokenAmount',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'canRegisterVaultToken',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'registerVaultTokenLocally',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_reserveId',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'tuple',
        components: [
          {
            name: 'underlyingAsset',
            type: 'address',
          },
          {
            name: 'decimals',
            type: 'uint256',
          },
          {
            name: 'lastAveragePricePerShare',
            type: 'uint256',
          },
        ],
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'deregisterVaultTokenLocally',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_vaultAddr',
        type: 'address',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'registerVaultTokensGlobally',
    inputs: [
      {
        name: '_vaultTokens',
        type: 'address[]',
      },
    ],
    outputs: [],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addPriceSnapshot',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'depositForYield',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'depositForYield',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_vaultAddr',
        type: 'address',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'withdrawFromYield',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'withdrawFromYield',
    inputs: [
      {
        name: '_vaultToken',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'getAccessForLego',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_action',
        type: 'uint256',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'string',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimRewards',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimRewards',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentives',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_proofs',
        type: 'bytes32[]',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'claimIncentives',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
      {
        name: '_rewardToken',
        type: 'address',
      },
      {
        name: '_rewardAmount',
        type: 'uint256',
      },
      {
        name: '_proofs',
        type: 'bytes32[]',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'hasClaimableRewards',
    inputs: [
      {
        name: '_user',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'bool',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'swapTokens',
    inputs: [
      {
        name: '_amountIn',
        type: 'uint256',
      },
      {
        name: '_minAmountOut',
        type: 'uint256',
      },
      {
        name: '_tokenPath',
        type: 'address[]',
      },
      {
        name: '_poolPath',
        type: 'address[]',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'swapTokens',
    inputs: [
      {
        name: '_amountIn',
        type: 'uint256',
      },
      {
        name: '_minAmountOut',
        type: 'uint256',
      },
      {
        name: '_tokenPath',
        type: 'address[]',
      },
      {
        name: '_poolPath',
        type: 'address[]',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'mintOrRedeemAsset',
    inputs: [
      {
        name: '_tokenIn',
        type: 'address',
      },
      {
        name: '_tokenOut',
        type: 'address',
      },
      {
        name: '_tokenInAmount',
        type: 'uint256',
      },
      {
        name: '_minAmountOut',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'mintOrRedeemAsset',
    inputs: [
      {
        name: '_tokenIn',
        type: 'address',
      },
      {
        name: '_tokenOut',
        type: 'address',
      },
      {
        name: '_tokenInAmount',
        type: 'uint256',
      },
      {
        name: '_minAmountOut',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmMintOrRedeemAsset',
    inputs: [
      {
        name: '_tokenIn',
        type: 'address',
      },
      {
        name: '_tokenOut',
        type: 'address',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'confirmMintOrRedeemAsset',
    inputs: [
      {
        name: '_tokenIn',
        type: 'address',
      },
      {
        name: '_tokenOut',
        type: 'address',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateral',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addCollateral',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'removeCollateral',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'removeCollateral',
    inputs: [
      {
        name: '_asset',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'borrow',
    inputs: [
      {
        name: '_borrowAsset',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'borrow',
    inputs: [
      {
        name: '_borrowAsset',
        type: 'address',
      },
      {
        name: '_amount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayDebt',
    inputs: [
      {
        name: '_paymentAsset',
        type: 'address',
      },
      {
        name: '_paymentAmount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'repayDebt',
    inputs: [
      {
        name: '_paymentAsset',
        type: 'address',
      },
      {
        name: '_paymentAmount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addLiquidity',
    inputs: [
      {
        name: '_pool',
        type: 'address',
      },
      {
        name: '_tokenA',
        type: 'address',
      },
      {
        name: '_tokenB',
        type: 'address',
      },
      {
        name: '_amountA',
        type: 'uint256',
      },
      {
        name: '_amountB',
        type: 'uint256',
      },
      {
        name: '_minAmountA',
        type: 'uint256',
      },
      {
        name: '_minAmountB',
        type: 'uint256',
      },
      {
        name: '_minLpAmount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addLiquidity',
    inputs: [
      {
        name: '_pool',
        type: 'address',
      },
      {
        name: '_tokenA',
        type: 'address',
      },
      {
        name: '_tokenB',
        type: 'address',
      },
      {
        name: '_amountA',
        type: 'uint256',
      },
      {
        name: '_amountB',
        type: 'uint256',
      },
      {
        name: '_minAmountA',
        type: 'uint256',
      },
      {
        name: '_minAmountB',
        type: 'uint256',
      },
      {
        name: '_minLpAmount',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'address',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'removeLiquidity',
    inputs: [
      {
        name: '_pool',
        type: 'address',
      },
      {
        name: '_tokenA',
        type: 'address',
      },
      {
        name: '_tokenB',
        type: 'address',
      },
      {
        name: '_lpToken',
        type: 'address',
      },
      {
        name: '_lpAmount',
        type: 'uint256',
      },
      {
        name: '_minAmountA',
        type: 'uint256',
      },
      {
        name: '_minAmountB',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'removeLiquidity',
    inputs: [
      {
        name: '_pool',
        type: 'address',
      },
      {
        name: '_tokenA',
        type: 'address',
      },
      {
        name: '_tokenB',
        type: 'address',
      },
      {
        name: '_lpToken',
        type: 'address',
      },
      {
        name: '_lpAmount',
        type: 'uint256',
      },
      {
        name: '_minAmountA',
        type: 'uint256',
      },
      {
        name: '_minAmountB',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addLiquidityConcentrated',
    inputs: [
      {
        name: '_nftTokenId',
        type: 'uint256',
      },
      {
        name: '_pool',
        type: 'address',
      },
      {
        name: '_tokenA',
        type: 'address',
      },
      {
        name: '_tokenB',
        type: 'address',
      },
      {
        name: '_tickLower',
        type: 'int24',
      },
      {
        name: '_tickUpper',
        type: 'int24',
      },
      {
        name: '_amountA',
        type: 'uint256',
      },
      {
        name: '_amountB',
        type: 'uint256',
      },
      {
        name: '_minAmountA',
        type: 'uint256',
      },
      {
        name: '_minAmountB',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'addLiquidityConcentrated',
    inputs: [
      {
        name: '_nftTokenId',
        type: 'uint256',
      },
      {
        name: '_pool',
        type: 'address',
      },
      {
        name: '_tokenA',
        type: 'address',
      },
      {
        name: '_tokenB',
        type: 'address',
      },
      {
        name: '_tickLower',
        type: 'int24',
      },
      {
        name: '_tickUpper',
        type: 'int24',
      },
      {
        name: '_amountA',
        type: 'uint256',
      },
      {
        name: '_amountB',
        type: 'uint256',
      },
      {
        name: '_minAmountA',
        type: 'uint256',
      },
      {
        name: '_minAmountB',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'removeLiquidityConcentrated',
    inputs: [
      {
        name: '_nftTokenId',
        type: 'uint256',
      },
      {
        name: '_pool',
        type: 'address',
      },
      {
        name: '_tokenA',
        type: 'address',
      },
      {
        name: '_tokenB',
        type: 'address',
      },
      {
        name: '_liqToRemove',
        type: 'uint256',
      },
      {
        name: '_minAmountA',
        type: 'uint256',
      },
      {
        name: '_minAmountB',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'function',
    name: 'removeLiquidityConcentrated',
    inputs: [
      {
        name: '_nftTokenId',
        type: 'uint256',
      },
      {
        name: '_pool',
        type: 'address',
      },
      {
        name: '_tokenA',
        type: 'address',
      },
      {
        name: '_tokenB',
        type: 'address',
      },
      {
        name: '_liqToRemove',
        type: 'uint256',
      },
      {
        name: '_minAmountA',
        type: 'uint256',
      },
      {
        name: '_minAmountB',
        type: 'uint256',
      },
      {
        name: '_extraData',
        type: 'bytes32',
      },
      {
        name: '_recipient',
        type: 'address',
      },
      {
        name: '_miniAddys',
        type: 'tuple',
        components: [
          {
            name: 'ledger',
            type: 'address',
          },
          {
            name: 'missionControl',
            type: 'address',
          },
          {
            name: 'legoBook',
            type: 'address',
          },
          {
            name: 'appraiser',
            type: 'address',
          },
        ],
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'uint256',
      },
      {
        name: '',
        type: 'bool',
      },
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'vaultTokenToReserveId',
    inputs: [
      {
        name: 'arg0',
        type: 'address',
      },
    ],
    outputs: [
      {
        name: '',
        type: 'uint256',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'EXTRAFI_POOL',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'view',
    type: 'function',
    name: 'RIPE_REGISTRY',
    inputs: [],
    outputs: [
      {
        name: '',
        type: 'address',
      },
    ],
  },
  {
    stateMutability: 'nonpayable',
    type: 'constructor',
    inputs: [
      {
        name: '_undyHq',
        type: 'address',
      },
      {
        name: '_extraFiPool',
        type: 'address',
      },
      {
        name: '_ripeRegistry',
        type: 'address',
      },
      {
        name: '_reserveIds',
        type: 'uint256[]',
      },
    ],
    outputs: [],
  },
] as const

export const deployAddress: Address | undefined = '0x92D446F251D214c982c4371513355739634D4465'

export type Contract = {
  calls: {
    getAddys: () => Promise<{
      hq: `0x${string}`
      undyToken: `0x${string}`
      ledger: `0x${string}`
      missionControl: `0x${string}`
      legoBook: `0x${string}`
      switchboard: `0x${string}`
      hatchery: `0x${string}`
      lootDistributor: `0x${string}`
      appraiser: `0x${string}`
      walletBackpack: `0x${string}`
      billing: `0x${string}`
      vaultRegistry: `0x${string}`
    }>
    getUndyHq: () => Promise<`0x${string}`>
    isLegoAsset: (asset: `0x${string}`) => Promise<boolean>
    getAssetOpportunities: (asset: `0x${string}`) => Promise<`0x${string}`[]>
    getAssets: () => Promise<`0x${string}`[]>
    isAssetOpportunity: (asset: `0x${string}`, vaultAddr: `0x${string}`) => Promise<boolean>
    getNumLegoAssets: () => Promise<bigint>
    getWeightedPricePerShare: (vaultToken: `0x${string}`) => Promise<bigint>
    getLatestSnapshot: (
      vaultToken: `0x${string}`,
      pricePerShare: bigint,
    ) => Promise<{ totalSupply: bigint; pricePerShare: bigint; lastUpdate: bigint }>
    isValidPriceConfig: (config: {
      minSnapshotDelay: bigint
      maxNumSnapshots: bigint
      maxUpsideDeviation: bigint
      staleTime: bigint
    }) => Promise<boolean>
    vaultToAsset: (
      arg0: `0x${string}`,
    ) => Promise<{ underlyingAsset: `0x${string}`; decimals: bigint; lastAveragePricePerShare: bigint }>
    assetOpportunities: (arg0: `0x${string}`, arg1: bigint) => Promise<`0x${string}`>
    indexOfAssetOpportunity: (arg0: `0x${string}`, arg1: `0x${string}`) => Promise<bigint>
    numAssetOpportunities: (arg0: `0x${string}`) => Promise<bigint>
    assets: (arg0: bigint) => Promise<`0x${string}`>
    indexOfAsset: (arg0: `0x${string}`) => Promise<bigint>
    numAssets: () => Promise<bigint>
    snapShotData: (
      arg0: `0x${string}`,
    ) => Promise<{
      lastSnapShot: { totalSupply: bigint; pricePerShare: bigint; lastUpdate: bigint }
      nextIndex: bigint
    }>
    snapShots: (
      arg0: `0x${string}`,
      arg1: bigint,
    ) => Promise<{ totalSupply: bigint; pricePerShare: bigint; lastUpdate: bigint }>
    snapShotPriceConfig: () => Promise<{
      minSnapshotDelay: bigint
      maxNumSnapshots: bigint
      maxUpsideDeviation: bigint
      staleTime: bigint
    }>
    isPaused: () => Promise<boolean>
    hasCapability: (action: bigint) => Promise<boolean>
    getRegistries: () => Promise<`0x${string}`[]>
    isYieldLego: () => Promise<boolean>
    isDexLego: () => Promise<boolean>
    getUnderlyingAsset: (vaultToken: `0x${string}`) => Promise<`0x${string}`>
    getUnderlyingBalances: (vaultToken: `0x${string}`, vaultTokenBalance: bigint) => Promise<[bigint, bigint]>
    getUnderlyingAmount: (vaultToken: `0x${string}`, vaultTokenAmount: bigint) => Promise<bigint>
    getUnderlyingAmountSafe: (vaultToken: `0x${string}`, vaultTokenBalance: bigint) => Promise<bigint>
    getUnderlyingData: (
      vaultToken: `0x${string}`,
      vaultTokenAmount: bigint,
      appraiser?: `0x${string}`,
    ) => Promise<[`0x${string}`, bigint, bigint]>
    getUsdValueOfVaultToken: (
      vaultToken: `0x${string}`,
      vaultTokenAmount: bigint,
      appraiser?: `0x${string}`,
    ) => Promise<bigint>
    isRebasing: () => Promise<boolean>
    getPricePerShare: (vaultToken: `0x${string}`, decimals?: bigint) => Promise<bigint>
    getVaultTokenAmount: (asset: `0x${string}`, assetAmount: bigint, vaultToken: `0x${string}`) => Promise<bigint>
    totalAssets: (vaultToken: `0x${string}`) => Promise<bigint>
    totalBorrows: (vaultToken: `0x${string}`) => Promise<bigint>
    getAvailLiquidity: (vaultToken: `0x${string}`) => Promise<bigint>
    getUtilizationRatio: (vaultToken: `0x${string}`) => Promise<bigint>
    isEligibleForYieldBonus: (asset: `0x${string}`) => Promise<boolean>
    getWithdrawalFees: (vaultToken: `0x${string}`, vaultTokenAmount: bigint) => Promise<bigint>
    canRegisterVaultToken: (asset: `0x${string}`, vaultToken: `0x${string}`) => Promise<boolean>
    getAccessForLego: (user: `0x${string}`, action: bigint) => Promise<[`0x${string}`, string, bigint]>
    hasClaimableRewards: (user: `0x${string}`) => Promise<boolean>
    vaultTokenToReserveId: (arg0: `0x${string}`) => Promise<bigint>
    EXTRAFI_POOL: () => Promise<`0x${string}`>
    RIPE_REGISTRY: () => Promise<`0x${string}`>
  }
  mutations: {
    pause: (shouldPause: boolean) => Promise<void>
    recoverFunds: (recipient: `0x${string}`, asset: `0x${string}`) => Promise<void>
    recoverFundsMany: (recipient: `0x${string}`, assets: `0x${string}`[]) => Promise<void>
    setSnapShotPriceConfig: (config: {
      minSnapshotDelay: bigint
      maxNumSnapshots: bigint
      maxUpsideDeviation: bigint
      staleTime: bigint
    }) => Promise<void>
    registerVaultTokenLocally: (
      asset: `0x${string}`,
      vaultAddr: `0x${string}`,
      reserveId: bigint,
    ) => Promise<{ underlyingAsset: `0x${string}`; decimals: bigint; lastAveragePricePerShare: bigint }>
    deregisterVaultTokenLocally: (asset: `0x${string}`, vaultAddr: `0x${string}`) => Promise<void>
    registerVaultTokensGlobally: (vaultTokens: `0x${string}`[]) => Promise<void>
    addPriceSnapshot: (vaultToken: `0x${string}`) => Promise<boolean>
    depositForYield: (
      asset: `0x${string}`,
      amount: bigint,
      vaultAddr: `0x${string}`,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, `0x${string}`, bigint, bigint]>
    withdrawFromYield: (
      vaultToken: `0x${string}`,
      amount: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, `0x${string}`, bigint, bigint]>
    claimRewards: (
      user: `0x${string}`,
      rewardToken: `0x${string}`,
      rewardAmount: bigint,
      extraData: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint]>
    claimIncentives: (
      user: `0x${string}`,
      rewardToken: `0x${string}`,
      rewardAmount: bigint,
      proofs: `0x${string}`[],
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint]>
    swapTokens: (
      amountIn: bigint,
      minAmountOut: bigint,
      tokenPath: `0x${string}`[],
      poolPath: `0x${string}`[],
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint, bigint]>
    mintOrRedeemAsset: (
      tokenIn: `0x${string}`,
      tokenOut: `0x${string}`,
      tokenInAmount: bigint,
      minAmountOut: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint, boolean, bigint]>
    confirmMintOrRedeemAsset: (
      tokenIn: `0x${string}`,
      tokenOut: `0x${string}`,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint]>
    addCollateral: (
      asset: `0x${string}`,
      amount: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint]>
    removeCollateral: (
      asset: `0x${string}`,
      amount: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint]>
    borrow: (
      borrowAsset: `0x${string}`,
      amount: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint]>
    repayDebt: (
      paymentAsset: `0x${string}`,
      paymentAmount: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint]>
    addLiquidity: (
      pool: `0x${string}`,
      tokenA: `0x${string}`,
      tokenB: `0x${string}`,
      amountA: bigint,
      amountB: bigint,
      minAmountA: bigint,
      minAmountB: bigint,
      minLpAmount: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[`0x${string}`, bigint, bigint, bigint, bigint]>
    removeLiquidity: (
      pool: `0x${string}`,
      tokenA: `0x${string}`,
      tokenB: `0x${string}`,
      lpToken: `0x${string}`,
      lpAmount: bigint,
      minAmountA: bigint,
      minAmountB: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint, bigint, bigint]>
    addLiquidityConcentrated: (
      nftTokenId: bigint,
      pool: `0x${string}`,
      tokenA: `0x${string}`,
      tokenB: `0x${string}`,
      tickLower: unknown,
      tickUpper: unknown,
      amountA: bigint,
      amountB: bigint,
      minAmountA: bigint,
      minAmountB: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint, bigint, bigint, bigint]>
    removeLiquidityConcentrated: (
      nftTokenId: bigint,
      pool: `0x${string}`,
      tokenA: `0x${string}`,
      tokenB: `0x${string}`,
      liqToRemove: bigint,
      minAmountA: bigint,
      minAmountB: bigint,
      extraData: `0x${string}`,
      recipient: `0x${string}`,
      miniAddys?: {
        ledger: `0x${string}`
        missionControl: `0x${string}`
        legoBook: `0x${string}`
        appraiser: `0x${string}`
      },
    ) => Promise<[bigint, bigint, bigint, boolean, bigint]>
  }
  events: {
    ExtraFiDeposit: (
      sender: `0x${string}`,
      asset: `0x${string}`,
      vaultToken: `0x${string}`,
      assetAmountDeposited: bigint,
      usdValue: bigint,
      vaultTokenAmountReceived: bigint,
      recipient: `0x${string}`,
    ) => Promise<void>
    ExtraFiWithdrawal: (
      sender: `0x${string}`,
      asset: `0x${string}`,
      vaultToken: `0x${string}`,
      assetAmountReceived: bigint,
      usdValue: bigint,
      vaultTokenAmountBurned: bigint,
      recipient: `0x${string}`,
    ) => Promise<void>
    AssetOpportunityAdded: (asset: `0x${string}`, vaultAddr: `0x${string}`) => Promise<void>
    LegoPauseModified: (isPaused: boolean) => Promise<void>
    LegoFundsRecovered: (asset: `0x${string}`, recipient: `0x${string}`, balance: bigint) => Promise<void>
    SnapShotPriceConfigSet: (
      minSnapshotDelay: bigint,
      maxNumSnapshots: bigint,
      maxUpsideDeviation: bigint,
      staleTime: bigint,
    ) => Promise<void>
    AssetOpportunityRemoved: (asset: `0x${string}`, vaultAddr: `0x${string}`) => Promise<void>
    PricePerShareSnapShotAdded: (
      vaultToken: `0x${string}`,
      totalSupply: bigint,
      pricePerShare: bigint,
      lastAveragePricePerShare: bigint,
    ) => Promise<void>
  }
}

export type Calls = keyof Contract['calls']
export type Request<M extends Calls> = {
  contractName: 'ExtraFi'
  method: M
  args: ExtractArgs<Contract['calls'][M]>
  address: Address | undefined
  deployAddress: Address | undefined
  defaultValue: Awaited<ReturnType<Contract['calls'][M]>> | undefined
  getAbi: () => typeof abi
  with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => Request<M>
  defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => Request<M>
  at: (address: Address) => Request<M>
}
export type CallReturn<M extends Calls> = NonNullable<Request<M>['defaultValue']>

function getRequest<M extends Calls>(
  method: M,
  args: ExtractArgs<Contract['calls'][M]>,
  contractAddressOrOptions?:
    | Address
    | {
        contractAddress?: Address
        defaultValue?: Awaited<ReturnType<Contract['calls'][M]>>
      },
): Request<M> {
  const address =
    typeof contractAddressOrOptions === 'string' ? contractAddressOrOptions : contractAddressOrOptions?.contractAddress
  const defaultValue = typeof contractAddressOrOptions === 'string' ? undefined : contractAddressOrOptions?.defaultValue

  const call = {
    contractName: 'ExtraFi' as const,
    method,
    args,
    address,
    deployAddress,
    defaultValue,
    getAbi: () => abi,
    with: (options: { contractAddress?: Address; defaultValue?: Awaited<ReturnType<Contract['calls'][M]>> }) => {
      call.address = options.contractAddress
      call.defaultValue = options.defaultValue
      return call as Request<M>
    },
    defaultTo: (defaultValue: Awaited<ReturnType<Contract['calls'][M]>>) => {
      call.defaultValue = defaultValue
      return call as Request<M>
    },
    at: (address: Address) => {
      call.address = address
      return call as Request<M>
    },
  } as Request<M>

  return call
}

type CallType = {
  [K in Calls]: (...args: ExtractArgs<Contract['calls'][K]>) => ReturnType<typeof getRequest<K>>
}

export const call: CallType = {
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => getRequest('getAddys', args),
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => getRequest('getUndyHq', args),
  isLegoAsset: (...args: ExtractArgs<Contract['calls']['isLegoAsset']>) => getRequest('isLegoAsset', args),
  getAssetOpportunities: (...args: ExtractArgs<Contract['calls']['getAssetOpportunities']>) =>
    getRequest('getAssetOpportunities', args),
  getAssets: (...args: ExtractArgs<Contract['calls']['getAssets']>) => getRequest('getAssets', args),
  isAssetOpportunity: (...args: ExtractArgs<Contract['calls']['isAssetOpportunity']>) =>
    getRequest('isAssetOpportunity', args),
  getNumLegoAssets: (...args: ExtractArgs<Contract['calls']['getNumLegoAssets']>) =>
    getRequest('getNumLegoAssets', args),
  getWeightedPricePerShare: (...args: ExtractArgs<Contract['calls']['getWeightedPricePerShare']>) =>
    getRequest('getWeightedPricePerShare', args),
  getLatestSnapshot: (...args: ExtractArgs<Contract['calls']['getLatestSnapshot']>) =>
    getRequest('getLatestSnapshot', args),
  isValidPriceConfig: (...args: ExtractArgs<Contract['calls']['isValidPriceConfig']>) =>
    getRequest('isValidPriceConfig', args),
  vaultToAsset: (...args: ExtractArgs<Contract['calls']['vaultToAsset']>) => getRequest('vaultToAsset', args),
  assetOpportunities: (...args: ExtractArgs<Contract['calls']['assetOpportunities']>) =>
    getRequest('assetOpportunities', args),
  indexOfAssetOpportunity: (...args: ExtractArgs<Contract['calls']['indexOfAssetOpportunity']>) =>
    getRequest('indexOfAssetOpportunity', args),
  numAssetOpportunities: (...args: ExtractArgs<Contract['calls']['numAssetOpportunities']>) =>
    getRequest('numAssetOpportunities', args),
  assets: (...args: ExtractArgs<Contract['calls']['assets']>) => getRequest('assets', args),
  indexOfAsset: (...args: ExtractArgs<Contract['calls']['indexOfAsset']>) => getRequest('indexOfAsset', args),
  numAssets: (...args: ExtractArgs<Contract['calls']['numAssets']>) => getRequest('numAssets', args),
  snapShotData: (...args: ExtractArgs<Contract['calls']['snapShotData']>) => getRequest('snapShotData', args),
  snapShots: (...args: ExtractArgs<Contract['calls']['snapShots']>) => getRequest('snapShots', args),
  snapShotPriceConfig: (...args: ExtractArgs<Contract['calls']['snapShotPriceConfig']>) =>
    getRequest('snapShotPriceConfig', args),
  isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) => getRequest('isPaused', args),
  hasCapability: (...args: ExtractArgs<Contract['calls']['hasCapability']>) => getRequest('hasCapability', args),
  getRegistries: (...args: ExtractArgs<Contract['calls']['getRegistries']>) => getRequest('getRegistries', args),
  isYieldLego: (...args: ExtractArgs<Contract['calls']['isYieldLego']>) => getRequest('isYieldLego', args),
  isDexLego: (...args: ExtractArgs<Contract['calls']['isDexLego']>) => getRequest('isDexLego', args),
  getUnderlyingAsset: (...args: ExtractArgs<Contract['calls']['getUnderlyingAsset']>) =>
    getRequest('getUnderlyingAsset', args),
  getUnderlyingBalances: (...args: ExtractArgs<Contract['calls']['getUnderlyingBalances']>) =>
    getRequest('getUnderlyingBalances', args),
  getUnderlyingAmount: (...args: ExtractArgs<Contract['calls']['getUnderlyingAmount']>) =>
    getRequest('getUnderlyingAmount', args),
  getUnderlyingAmountSafe: (...args: ExtractArgs<Contract['calls']['getUnderlyingAmountSafe']>) =>
    getRequest('getUnderlyingAmountSafe', args),
  getUnderlyingData: (...args: ExtractArgs<Contract['calls']['getUnderlyingData']>) =>
    getRequest('getUnderlyingData', args),
  getUsdValueOfVaultToken: (...args: ExtractArgs<Contract['calls']['getUsdValueOfVaultToken']>) =>
    getRequest('getUsdValueOfVaultToken', args),
  isRebasing: (...args: ExtractArgs<Contract['calls']['isRebasing']>) => getRequest('isRebasing', args),
  getPricePerShare: (...args: ExtractArgs<Contract['calls']['getPricePerShare']>) =>
    getRequest('getPricePerShare', args),
  getVaultTokenAmount: (...args: ExtractArgs<Contract['calls']['getVaultTokenAmount']>) =>
    getRequest('getVaultTokenAmount', args),
  totalAssets: (...args: ExtractArgs<Contract['calls']['totalAssets']>) => getRequest('totalAssets', args),
  totalBorrows: (...args: ExtractArgs<Contract['calls']['totalBorrows']>) => getRequest('totalBorrows', args),
  getAvailLiquidity: (...args: ExtractArgs<Contract['calls']['getAvailLiquidity']>) =>
    getRequest('getAvailLiquidity', args),
  getUtilizationRatio: (...args: ExtractArgs<Contract['calls']['getUtilizationRatio']>) =>
    getRequest('getUtilizationRatio', args),
  isEligibleForYieldBonus: (...args: ExtractArgs<Contract['calls']['isEligibleForYieldBonus']>) =>
    getRequest('isEligibleForYieldBonus', args),
  getWithdrawalFees: (...args: ExtractArgs<Contract['calls']['getWithdrawalFees']>) =>
    getRequest('getWithdrawalFees', args),
  canRegisterVaultToken: (...args: ExtractArgs<Contract['calls']['canRegisterVaultToken']>) =>
    getRequest('canRegisterVaultToken', args),
  getAccessForLego: (...args: ExtractArgs<Contract['calls']['getAccessForLego']>) =>
    getRequest('getAccessForLego', args),
  hasClaimableRewards: (...args: ExtractArgs<Contract['calls']['hasClaimableRewards']>) =>
    getRequest('hasClaimableRewards', args),
  vaultTokenToReserveId: (...args: ExtractArgs<Contract['calls']['vaultTokenToReserveId']>) =>
    getRequest('vaultTokenToReserveId', args),
  EXTRAFI_POOL: (...args: ExtractArgs<Contract['calls']['EXTRAFI_POOL']>) => getRequest('EXTRAFI_POOL', args),
  RIPE_REGISTRY: (...args: ExtractArgs<Contract['calls']['RIPE_REGISTRY']>) => getRequest('RIPE_REGISTRY', args),
}

export type Mutations = keyof Contract['mutations']
function getMutation<M extends Mutations>(functionName: M) {
  return {
    contractName: 'ExtraFi' as const,
    functionName,
    deployAddress,
    argsType: undefined as ExtractArgs<Contract['mutations'][M]> | undefined,
    getAbi: () => abi,
  }
}

export const mutation: {
  [K in Mutations]: {
    contractName: 'ExtraFi'
    deployAddress: Address | undefined
    getAbi: () => typeof abi
    functionName: K
    argsType: ExtractArgs<Contract['mutations'][K]> | undefined
  }
} = {
  pause: getMutation('pause'),
  recoverFunds: getMutation('recoverFunds'),
  recoverFundsMany: getMutation('recoverFundsMany'),
  setSnapShotPriceConfig: getMutation('setSnapShotPriceConfig'),
  registerVaultTokenLocally: getMutation('registerVaultTokenLocally'),
  deregisterVaultTokenLocally: getMutation('deregisterVaultTokenLocally'),
  registerVaultTokensGlobally: getMutation('registerVaultTokensGlobally'),
  addPriceSnapshot: getMutation('addPriceSnapshot'),
  depositForYield: getMutation('depositForYield'),
  withdrawFromYield: getMutation('withdrawFromYield'),
  claimRewards: getMutation('claimRewards'),
  claimIncentives: getMutation('claimIncentives'),
  swapTokens: getMutation('swapTokens'),
  mintOrRedeemAsset: getMutation('mintOrRedeemAsset'),
  confirmMintOrRedeemAsset: getMutation('confirmMintOrRedeemAsset'),
  addCollateral: getMutation('addCollateral'),
  removeCollateral: getMutation('removeCollateral'),
  borrow: getMutation('borrow'),
  repayDebt: getMutation('repayDebt'),
  addLiquidity: getMutation('addLiquidity'),
  removeLiquidity: getMutation('removeLiquidity'),
  addLiquidityConcentrated: getMutation('addLiquidityConcentrated'),
  removeLiquidityConcentrated: getMutation('removeLiquidityConcentrated'),
}

export type ParsedEvent<T extends keyof Contract['events']> = {
  event: RpcLog | Log
  parsed: ParseEventLogsReturnType<typeof abi, T>
}

export function parseEvents<T extends keyof Contract['events']>(
  eventName: T,
  events: (RpcLog | Log)[],
): ParsedEvent<T>[] {
  return events.map((event) => {
    return {
      event,
      parsed: parseEventLogs({
        abi,
        eventName,
        logs: [event],
      }),
    }
  })
}

export function getEventTopic<T extends keyof Contract['events']>(eventName: T): Address {
  return encodeEventTopics({ abi, eventName })[0] as Address
}

export type SDK = {
  deployAddress: Address | undefined
  abi: typeof abi
  events: {
    ExtraFiDeposit: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ExtraFiDeposit'>[] }
    ExtraFiWithdrawal: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'ExtraFiWithdrawal'>[] }
    AssetOpportunityAdded: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AssetOpportunityAdded'>[]
    }
    LegoPauseModified: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'LegoPauseModified'>[] }
    LegoFundsRecovered: { topic: Address; parse: (events: (RpcLog | Log)[]) => ParsedEvent<'LegoFundsRecovered'>[] }
    SnapShotPriceConfigSet: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'SnapShotPriceConfigSet'>[]
    }
    AssetOpportunityRemoved: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'AssetOpportunityRemoved'>[]
    }
    PricePerShareSnapShotAdded: {
      topic: Address
      parse: (events: (RpcLog | Log)[]) => ParsedEvent<'PricePerShareSnapShotAdded'>[]
    }
  }
  getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) => Promise<CallReturn<'getAddys'>>
  getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) => Promise<CallReturn<'getUndyHq'>>
  isLegoAsset: (...args: ExtractArgs<Contract['calls']['isLegoAsset']>) => Promise<CallReturn<'isLegoAsset'>>
  getAssetOpportunities: (
    ...args: ExtractArgs<Contract['calls']['getAssetOpportunities']>
  ) => Promise<CallReturn<'getAssetOpportunities'>>
  getAssets: (...args: ExtractArgs<Contract['calls']['getAssets']>) => Promise<CallReturn<'getAssets'>>
  isAssetOpportunity: (
    ...args: ExtractArgs<Contract['calls']['isAssetOpportunity']>
  ) => Promise<CallReturn<'isAssetOpportunity'>>
  getNumLegoAssets: (
    ...args: ExtractArgs<Contract['calls']['getNumLegoAssets']>
  ) => Promise<CallReturn<'getNumLegoAssets'>>
  getWeightedPricePerShare: (
    ...args: ExtractArgs<Contract['calls']['getWeightedPricePerShare']>
  ) => Promise<CallReturn<'getWeightedPricePerShare'>>
  getLatestSnapshot: (
    ...args: ExtractArgs<Contract['calls']['getLatestSnapshot']>
  ) => Promise<CallReturn<'getLatestSnapshot'>>
  isValidPriceConfig: (
    ...args: ExtractArgs<Contract['calls']['isValidPriceConfig']>
  ) => Promise<CallReturn<'isValidPriceConfig'>>
  vaultToAsset: (...args: ExtractArgs<Contract['calls']['vaultToAsset']>) => Promise<CallReturn<'vaultToAsset'>>
  assetOpportunities: (
    ...args: ExtractArgs<Contract['calls']['assetOpportunities']>
  ) => Promise<CallReturn<'assetOpportunities'>>
  indexOfAssetOpportunity: (
    ...args: ExtractArgs<Contract['calls']['indexOfAssetOpportunity']>
  ) => Promise<CallReturn<'indexOfAssetOpportunity'>>
  numAssetOpportunities: (
    ...args: ExtractArgs<Contract['calls']['numAssetOpportunities']>
  ) => Promise<CallReturn<'numAssetOpportunities'>>
  assets: (...args: ExtractArgs<Contract['calls']['assets']>) => Promise<CallReturn<'assets'>>
  indexOfAsset: (...args: ExtractArgs<Contract['calls']['indexOfAsset']>) => Promise<CallReturn<'indexOfAsset'>>
  numAssets: (...args: ExtractArgs<Contract['calls']['numAssets']>) => Promise<CallReturn<'numAssets'>>
  snapShotData: (...args: ExtractArgs<Contract['calls']['snapShotData']>) => Promise<CallReturn<'snapShotData'>>
  snapShots: (...args: ExtractArgs<Contract['calls']['snapShots']>) => Promise<CallReturn<'snapShots'>>
  snapShotPriceConfig: (
    ...args: ExtractArgs<Contract['calls']['snapShotPriceConfig']>
  ) => Promise<CallReturn<'snapShotPriceConfig'>>
  isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) => Promise<CallReturn<'isPaused'>>
  hasCapability: (...args: ExtractArgs<Contract['calls']['hasCapability']>) => Promise<CallReturn<'hasCapability'>>
  getRegistries: (...args: ExtractArgs<Contract['calls']['getRegistries']>) => Promise<CallReturn<'getRegistries'>>
  isYieldLego: (...args: ExtractArgs<Contract['calls']['isYieldLego']>) => Promise<CallReturn<'isYieldLego'>>
  isDexLego: (...args: ExtractArgs<Contract['calls']['isDexLego']>) => Promise<CallReturn<'isDexLego'>>
  getUnderlyingAsset: (
    ...args: ExtractArgs<Contract['calls']['getUnderlyingAsset']>
  ) => Promise<CallReturn<'getUnderlyingAsset'>>
  getUnderlyingBalances: (
    ...args: ExtractArgs<Contract['calls']['getUnderlyingBalances']>
  ) => Promise<CallReturn<'getUnderlyingBalances'>>
  getUnderlyingAmount: (
    ...args: ExtractArgs<Contract['calls']['getUnderlyingAmount']>
  ) => Promise<CallReturn<'getUnderlyingAmount'>>
  getUnderlyingAmountSafe: (
    ...args: ExtractArgs<Contract['calls']['getUnderlyingAmountSafe']>
  ) => Promise<CallReturn<'getUnderlyingAmountSafe'>>
  getUnderlyingData: (
    ...args: ExtractArgs<Contract['calls']['getUnderlyingData']>
  ) => Promise<CallReturn<'getUnderlyingData'>>
  getUsdValueOfVaultToken: (
    ...args: ExtractArgs<Contract['calls']['getUsdValueOfVaultToken']>
  ) => Promise<CallReturn<'getUsdValueOfVaultToken'>>
  isRebasing: (...args: ExtractArgs<Contract['calls']['isRebasing']>) => Promise<CallReturn<'isRebasing'>>
  getPricePerShare: (
    ...args: ExtractArgs<Contract['calls']['getPricePerShare']>
  ) => Promise<CallReturn<'getPricePerShare'>>
  getVaultTokenAmount: (
    ...args: ExtractArgs<Contract['calls']['getVaultTokenAmount']>
  ) => Promise<CallReturn<'getVaultTokenAmount'>>
  totalAssets: (...args: ExtractArgs<Contract['calls']['totalAssets']>) => Promise<CallReturn<'totalAssets'>>
  totalBorrows: (...args: ExtractArgs<Contract['calls']['totalBorrows']>) => Promise<CallReturn<'totalBorrows'>>
  getAvailLiquidity: (
    ...args: ExtractArgs<Contract['calls']['getAvailLiquidity']>
  ) => Promise<CallReturn<'getAvailLiquidity'>>
  getUtilizationRatio: (
    ...args: ExtractArgs<Contract['calls']['getUtilizationRatio']>
  ) => Promise<CallReturn<'getUtilizationRatio'>>
  isEligibleForYieldBonus: (
    ...args: ExtractArgs<Contract['calls']['isEligibleForYieldBonus']>
  ) => Promise<CallReturn<'isEligibleForYieldBonus'>>
  getWithdrawalFees: (
    ...args: ExtractArgs<Contract['calls']['getWithdrawalFees']>
  ) => Promise<CallReturn<'getWithdrawalFees'>>
  canRegisterVaultToken: (
    ...args: ExtractArgs<Contract['calls']['canRegisterVaultToken']>
  ) => Promise<CallReturn<'canRegisterVaultToken'>>
  getAccessForLego: (
    ...args: ExtractArgs<Contract['calls']['getAccessForLego']>
  ) => Promise<CallReturn<'getAccessForLego'>>
  hasClaimableRewards: (
    ...args: ExtractArgs<Contract['calls']['hasClaimableRewards']>
  ) => Promise<CallReturn<'hasClaimableRewards'>>
  vaultTokenToReserveId: (
    ...args: ExtractArgs<Contract['calls']['vaultTokenToReserveId']>
  ) => Promise<CallReturn<'vaultTokenToReserveId'>>
  EXTRAFI_POOL: (...args: ExtractArgs<Contract['calls']['EXTRAFI_POOL']>) => Promise<CallReturn<'EXTRAFI_POOL'>>
  RIPE_REGISTRY: (...args: ExtractArgs<Contract['calls']['RIPE_REGISTRY']>) => Promise<CallReturn<'RIPE_REGISTRY'>>
  pause: (...args: ExtractArgs<Contract['mutations']['pause']>) => Promise<Address>
  recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) => Promise<Address>
  recoverFundsMany: (...args: ExtractArgs<Contract['mutations']['recoverFundsMany']>) => Promise<Address>
  setSnapShotPriceConfig: (...args: ExtractArgs<Contract['mutations']['setSnapShotPriceConfig']>) => Promise<Address>
  registerVaultTokenLocally: (
    ...args: ExtractArgs<Contract['mutations']['registerVaultTokenLocally']>
  ) => Promise<Address>
  deregisterVaultTokenLocally: (
    ...args: ExtractArgs<Contract['mutations']['deregisterVaultTokenLocally']>
  ) => Promise<Address>
  registerVaultTokensGlobally: (
    ...args: ExtractArgs<Contract['mutations']['registerVaultTokensGlobally']>
  ) => Promise<Address>
  addPriceSnapshot: (...args: ExtractArgs<Contract['mutations']['addPriceSnapshot']>) => Promise<Address>
  depositForYield: (...args: ExtractArgs<Contract['mutations']['depositForYield']>) => Promise<Address>
  withdrawFromYield: (...args: ExtractArgs<Contract['mutations']['withdrawFromYield']>) => Promise<Address>
  claimRewards: (...args: ExtractArgs<Contract['mutations']['claimRewards']>) => Promise<Address>
  claimIncentives: (...args: ExtractArgs<Contract['mutations']['claimIncentives']>) => Promise<Address>
  swapTokens: (...args: ExtractArgs<Contract['mutations']['swapTokens']>) => Promise<Address>
  mintOrRedeemAsset: (...args: ExtractArgs<Contract['mutations']['mintOrRedeemAsset']>) => Promise<Address>
  confirmMintOrRedeemAsset: (
    ...args: ExtractArgs<Contract['mutations']['confirmMintOrRedeemAsset']>
  ) => Promise<Address>
  addCollateral: (...args: ExtractArgs<Contract['mutations']['addCollateral']>) => Promise<Address>
  removeCollateral: (...args: ExtractArgs<Contract['mutations']['removeCollateral']>) => Promise<Address>
  borrow: (...args: ExtractArgs<Contract['mutations']['borrow']>) => Promise<Address>
  repayDebt: (...args: ExtractArgs<Contract['mutations']['repayDebt']>) => Promise<Address>
  addLiquidity: (...args: ExtractArgs<Contract['mutations']['addLiquidity']>) => Promise<Address>
  removeLiquidity: (...args: ExtractArgs<Contract['mutations']['removeLiquidity']>) => Promise<Address>
  addLiquidityConcentrated: (
    ...args: ExtractArgs<Contract['mutations']['addLiquidityConcentrated']>
  ) => Promise<Address>
  removeLiquidityConcentrated: (
    ...args: ExtractArgs<Contract['mutations']['removeLiquidityConcentrated']>
  ) => Promise<Address>
}

export function toSdk(
  publicClient?: PublicClient,
  walletClient?: WalletClient,
  addressResolver?: AddressResolverFunction,
): SDK {
  return {
    deployAddress,
    abi,

    events: {
      ExtraFiDeposit: {
        topic: getEventTopic('ExtraFiDeposit'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ExtraFiDeposit', events),
      },
      ExtraFiWithdrawal: {
        topic: getEventTopic('ExtraFiWithdrawal'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('ExtraFiWithdrawal', events),
      },
      AssetOpportunityAdded: {
        topic: getEventTopic('AssetOpportunityAdded'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AssetOpportunityAdded', events),
      },
      LegoPauseModified: {
        topic: getEventTopic('LegoPauseModified'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('LegoPauseModified', events),
      },
      LegoFundsRecovered: {
        topic: getEventTopic('LegoFundsRecovered'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('LegoFundsRecovered', events),
      },
      SnapShotPriceConfigSet: {
        topic: getEventTopic('SnapShotPriceConfigSet'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('SnapShotPriceConfigSet', events),
      },
      AssetOpportunityRemoved: {
        topic: getEventTopic('AssetOpportunityRemoved'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('AssetOpportunityRemoved', events),
      },
      PricePerShareSnapShotAdded: {
        topic: getEventTopic('PricePerShareSnapShotAdded'),
        parse: (events: (RpcLog | Log)[]) => parseEvents('PricePerShareSnapShotAdded', events),
      },
    },
    // Queries
    getAddys: (...args: ExtractArgs<Contract['calls']['getAddys']>) =>
      singleQuery(publicClient!, call.getAddys(...args), {}, addressResolver) as Promise<CallReturn<'getAddys'>>,
    getUndyHq: (...args: ExtractArgs<Contract['calls']['getUndyHq']>) =>
      singleQuery(publicClient!, call.getUndyHq(...args), {}, addressResolver) as Promise<CallReturn<'getUndyHq'>>,
    isLegoAsset: (...args: ExtractArgs<Contract['calls']['isLegoAsset']>) =>
      singleQuery(publicClient!, call.isLegoAsset(...args), {}, addressResolver) as Promise<CallReturn<'isLegoAsset'>>,
    getAssetOpportunities: (...args: ExtractArgs<Contract['calls']['getAssetOpportunities']>) =>
      singleQuery(publicClient!, call.getAssetOpportunities(...args), {}, addressResolver) as Promise<
        CallReturn<'getAssetOpportunities'>
      >,
    getAssets: (...args: ExtractArgs<Contract['calls']['getAssets']>) =>
      singleQuery(publicClient!, call.getAssets(...args), {}, addressResolver) as Promise<CallReturn<'getAssets'>>,
    isAssetOpportunity: (...args: ExtractArgs<Contract['calls']['isAssetOpportunity']>) =>
      singleQuery(publicClient!, call.isAssetOpportunity(...args), {}, addressResolver) as Promise<
        CallReturn<'isAssetOpportunity'>
      >,
    getNumLegoAssets: (...args: ExtractArgs<Contract['calls']['getNumLegoAssets']>) =>
      singleQuery(publicClient!, call.getNumLegoAssets(...args), {}, addressResolver) as Promise<
        CallReturn<'getNumLegoAssets'>
      >,
    getWeightedPricePerShare: (...args: ExtractArgs<Contract['calls']['getWeightedPricePerShare']>) =>
      singleQuery(publicClient!, call.getWeightedPricePerShare(...args), {}, addressResolver) as Promise<
        CallReturn<'getWeightedPricePerShare'>
      >,
    getLatestSnapshot: (...args: ExtractArgs<Contract['calls']['getLatestSnapshot']>) =>
      singleQuery(publicClient!, call.getLatestSnapshot(...args), {}, addressResolver) as Promise<
        CallReturn<'getLatestSnapshot'>
      >,
    isValidPriceConfig: (...args: ExtractArgs<Contract['calls']['isValidPriceConfig']>) =>
      singleQuery(publicClient!, call.isValidPriceConfig(...args), {}, addressResolver) as Promise<
        CallReturn<'isValidPriceConfig'>
      >,
    vaultToAsset: (...args: ExtractArgs<Contract['calls']['vaultToAsset']>) =>
      singleQuery(publicClient!, call.vaultToAsset(...args), {}, addressResolver) as Promise<
        CallReturn<'vaultToAsset'>
      >,
    assetOpportunities: (...args: ExtractArgs<Contract['calls']['assetOpportunities']>) =>
      singleQuery(publicClient!, call.assetOpportunities(...args), {}, addressResolver) as Promise<
        CallReturn<'assetOpportunities'>
      >,
    indexOfAssetOpportunity: (...args: ExtractArgs<Contract['calls']['indexOfAssetOpportunity']>) =>
      singleQuery(publicClient!, call.indexOfAssetOpportunity(...args), {}, addressResolver) as Promise<
        CallReturn<'indexOfAssetOpportunity'>
      >,
    numAssetOpportunities: (...args: ExtractArgs<Contract['calls']['numAssetOpportunities']>) =>
      singleQuery(publicClient!, call.numAssetOpportunities(...args), {}, addressResolver) as Promise<
        CallReturn<'numAssetOpportunities'>
      >,
    assets: (...args: ExtractArgs<Contract['calls']['assets']>) =>
      singleQuery(publicClient!, call.assets(...args), {}, addressResolver) as Promise<CallReturn<'assets'>>,
    indexOfAsset: (...args: ExtractArgs<Contract['calls']['indexOfAsset']>) =>
      singleQuery(publicClient!, call.indexOfAsset(...args), {}, addressResolver) as Promise<
        CallReturn<'indexOfAsset'>
      >,
    numAssets: (...args: ExtractArgs<Contract['calls']['numAssets']>) =>
      singleQuery(publicClient!, call.numAssets(...args), {}, addressResolver) as Promise<CallReturn<'numAssets'>>,
    snapShotData: (...args: ExtractArgs<Contract['calls']['snapShotData']>) =>
      singleQuery(publicClient!, call.snapShotData(...args), {}, addressResolver) as Promise<
        CallReturn<'snapShotData'>
      >,
    snapShots: (...args: ExtractArgs<Contract['calls']['snapShots']>) =>
      singleQuery(publicClient!, call.snapShots(...args), {}, addressResolver) as Promise<CallReturn<'snapShots'>>,
    snapShotPriceConfig: (...args: ExtractArgs<Contract['calls']['snapShotPriceConfig']>) =>
      singleQuery(publicClient!, call.snapShotPriceConfig(...args), {}, addressResolver) as Promise<
        CallReturn<'snapShotPriceConfig'>
      >,
    isPaused: (...args: ExtractArgs<Contract['calls']['isPaused']>) =>
      singleQuery(publicClient!, call.isPaused(...args), {}, addressResolver) as Promise<CallReturn<'isPaused'>>,
    hasCapability: (...args: ExtractArgs<Contract['calls']['hasCapability']>) =>
      singleQuery(publicClient!, call.hasCapability(...args), {}, addressResolver) as Promise<
        CallReturn<'hasCapability'>
      >,
    getRegistries: (...args: ExtractArgs<Contract['calls']['getRegistries']>) =>
      singleQuery(publicClient!, call.getRegistries(...args), {}, addressResolver) as Promise<
        CallReturn<'getRegistries'>
      >,
    isYieldLego: (...args: ExtractArgs<Contract['calls']['isYieldLego']>) =>
      singleQuery(publicClient!, call.isYieldLego(...args), {}, addressResolver) as Promise<CallReturn<'isYieldLego'>>,
    isDexLego: (...args: ExtractArgs<Contract['calls']['isDexLego']>) =>
      singleQuery(publicClient!, call.isDexLego(...args), {}, addressResolver) as Promise<CallReturn<'isDexLego'>>,
    getUnderlyingAsset: (...args: ExtractArgs<Contract['calls']['getUnderlyingAsset']>) =>
      singleQuery(publicClient!, call.getUnderlyingAsset(...args), {}, addressResolver) as Promise<
        CallReturn<'getUnderlyingAsset'>
      >,
    getUnderlyingBalances: (...args: ExtractArgs<Contract['calls']['getUnderlyingBalances']>) =>
      singleQuery(publicClient!, call.getUnderlyingBalances(...args), {}, addressResolver) as Promise<
        CallReturn<'getUnderlyingBalances'>
      >,
    getUnderlyingAmount: (...args: ExtractArgs<Contract['calls']['getUnderlyingAmount']>) =>
      singleQuery(publicClient!, call.getUnderlyingAmount(...args), {}, addressResolver) as Promise<
        CallReturn<'getUnderlyingAmount'>
      >,
    getUnderlyingAmountSafe: (...args: ExtractArgs<Contract['calls']['getUnderlyingAmountSafe']>) =>
      singleQuery(publicClient!, call.getUnderlyingAmountSafe(...args), {}, addressResolver) as Promise<
        CallReturn<'getUnderlyingAmountSafe'>
      >,
    getUnderlyingData: (...args: ExtractArgs<Contract['calls']['getUnderlyingData']>) =>
      singleQuery(publicClient!, call.getUnderlyingData(...args), {}, addressResolver) as Promise<
        CallReturn<'getUnderlyingData'>
      >,
    getUsdValueOfVaultToken: (...args: ExtractArgs<Contract['calls']['getUsdValueOfVaultToken']>) =>
      singleQuery(publicClient!, call.getUsdValueOfVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'getUsdValueOfVaultToken'>
      >,
    isRebasing: (...args: ExtractArgs<Contract['calls']['isRebasing']>) =>
      singleQuery(publicClient!, call.isRebasing(...args), {}, addressResolver) as Promise<CallReturn<'isRebasing'>>,
    getPricePerShare: (...args: ExtractArgs<Contract['calls']['getPricePerShare']>) =>
      singleQuery(publicClient!, call.getPricePerShare(...args), {}, addressResolver) as Promise<
        CallReturn<'getPricePerShare'>
      >,
    getVaultTokenAmount: (...args: ExtractArgs<Contract['calls']['getVaultTokenAmount']>) =>
      singleQuery(publicClient!, call.getVaultTokenAmount(...args), {}, addressResolver) as Promise<
        CallReturn<'getVaultTokenAmount'>
      >,
    totalAssets: (...args: ExtractArgs<Contract['calls']['totalAssets']>) =>
      singleQuery(publicClient!, call.totalAssets(...args), {}, addressResolver) as Promise<CallReturn<'totalAssets'>>,
    totalBorrows: (...args: ExtractArgs<Contract['calls']['totalBorrows']>) =>
      singleQuery(publicClient!, call.totalBorrows(...args), {}, addressResolver) as Promise<
        CallReturn<'totalBorrows'>
      >,
    getAvailLiquidity: (...args: ExtractArgs<Contract['calls']['getAvailLiquidity']>) =>
      singleQuery(publicClient!, call.getAvailLiquidity(...args), {}, addressResolver) as Promise<
        CallReturn<'getAvailLiquidity'>
      >,
    getUtilizationRatio: (...args: ExtractArgs<Contract['calls']['getUtilizationRatio']>) =>
      singleQuery(publicClient!, call.getUtilizationRatio(...args), {}, addressResolver) as Promise<
        CallReturn<'getUtilizationRatio'>
      >,
    isEligibleForYieldBonus: (...args: ExtractArgs<Contract['calls']['isEligibleForYieldBonus']>) =>
      singleQuery(publicClient!, call.isEligibleForYieldBonus(...args), {}, addressResolver) as Promise<
        CallReturn<'isEligibleForYieldBonus'>
      >,
    getWithdrawalFees: (...args: ExtractArgs<Contract['calls']['getWithdrawalFees']>) =>
      singleQuery(publicClient!, call.getWithdrawalFees(...args), {}, addressResolver) as Promise<
        CallReturn<'getWithdrawalFees'>
      >,
    canRegisterVaultToken: (...args: ExtractArgs<Contract['calls']['canRegisterVaultToken']>) =>
      singleQuery(publicClient!, call.canRegisterVaultToken(...args), {}, addressResolver) as Promise<
        CallReturn<'canRegisterVaultToken'>
      >,
    getAccessForLego: (...args: ExtractArgs<Contract['calls']['getAccessForLego']>) =>
      singleQuery(publicClient!, call.getAccessForLego(...args), {}, addressResolver) as Promise<
        CallReturn<'getAccessForLego'>
      >,
    hasClaimableRewards: (...args: ExtractArgs<Contract['calls']['hasClaimableRewards']>) =>
      singleQuery(publicClient!, call.hasClaimableRewards(...args), {}, addressResolver) as Promise<
        CallReturn<'hasClaimableRewards'>
      >,
    vaultTokenToReserveId: (...args: ExtractArgs<Contract['calls']['vaultTokenToReserveId']>) =>
      singleQuery(publicClient!, call.vaultTokenToReserveId(...args), {}, addressResolver) as Promise<
        CallReturn<'vaultTokenToReserveId'>
      >,
    EXTRAFI_POOL: (...args: ExtractArgs<Contract['calls']['EXTRAFI_POOL']>) =>
      singleQuery(publicClient!, call.EXTRAFI_POOL(...args), {}, addressResolver) as Promise<
        CallReturn<'EXTRAFI_POOL'>
      >,
    RIPE_REGISTRY: (...args: ExtractArgs<Contract['calls']['RIPE_REGISTRY']>) =>
      singleQuery(publicClient!, call.RIPE_REGISTRY(...args), {}, addressResolver) as Promise<
        CallReturn<'RIPE_REGISTRY'>
      >,

    // Mutations
    pause: (...args: ExtractArgs<Contract['mutations']['pause']>) =>
      mutate(walletClient!, mutation.pause, { addressResolver })(...args),
    recoverFunds: (...args: ExtractArgs<Contract['mutations']['recoverFunds']>) =>
      mutate(walletClient!, mutation.recoverFunds, { addressResolver })(...args),
    recoverFundsMany: (...args: ExtractArgs<Contract['mutations']['recoverFundsMany']>) =>
      mutate(walletClient!, mutation.recoverFundsMany, { addressResolver })(...args),
    setSnapShotPriceConfig: (...args: ExtractArgs<Contract['mutations']['setSnapShotPriceConfig']>) =>
      mutate(walletClient!, mutation.setSnapShotPriceConfig, { addressResolver })(...args),
    registerVaultTokenLocally: (...args: ExtractArgs<Contract['mutations']['registerVaultTokenLocally']>) =>
      mutate(walletClient!, mutation.registerVaultTokenLocally, { addressResolver })(...args),
    deregisterVaultTokenLocally: (...args: ExtractArgs<Contract['mutations']['deregisterVaultTokenLocally']>) =>
      mutate(walletClient!, mutation.deregisterVaultTokenLocally, { addressResolver })(...args),
    registerVaultTokensGlobally: (...args: ExtractArgs<Contract['mutations']['registerVaultTokensGlobally']>) =>
      mutate(walletClient!, mutation.registerVaultTokensGlobally, { addressResolver })(...args),
    addPriceSnapshot: (...args: ExtractArgs<Contract['mutations']['addPriceSnapshot']>) =>
      mutate(walletClient!, mutation.addPriceSnapshot, { addressResolver })(...args),
    depositForYield: (...args: ExtractArgs<Contract['mutations']['depositForYield']>) =>
      mutate(walletClient!, mutation.depositForYield, { addressResolver })(...args),
    withdrawFromYield: (...args: ExtractArgs<Contract['mutations']['withdrawFromYield']>) =>
      mutate(walletClient!, mutation.withdrawFromYield, { addressResolver })(...args),
    claimRewards: (...args: ExtractArgs<Contract['mutations']['claimRewards']>) =>
      mutate(walletClient!, mutation.claimRewards, { addressResolver })(...args),
    claimIncentives: (...args: ExtractArgs<Contract['mutations']['claimIncentives']>) =>
      mutate(walletClient!, mutation.claimIncentives, { addressResolver })(...args),
    swapTokens: (...args: ExtractArgs<Contract['mutations']['swapTokens']>) =>
      mutate(walletClient!, mutation.swapTokens, { addressResolver })(...args),
    mintOrRedeemAsset: (...args: ExtractArgs<Contract['mutations']['mintOrRedeemAsset']>) =>
      mutate(walletClient!, mutation.mintOrRedeemAsset, { addressResolver })(...args),
    confirmMintOrRedeemAsset: (...args: ExtractArgs<Contract['mutations']['confirmMintOrRedeemAsset']>) =>
      mutate(walletClient!, mutation.confirmMintOrRedeemAsset, { addressResolver })(...args),
    addCollateral: (...args: ExtractArgs<Contract['mutations']['addCollateral']>) =>
      mutate(walletClient!, mutation.addCollateral, { addressResolver })(...args),
    removeCollateral: (...args: ExtractArgs<Contract['mutations']['removeCollateral']>) =>
      mutate(walletClient!, mutation.removeCollateral, { addressResolver })(...args),
    borrow: (...args: ExtractArgs<Contract['mutations']['borrow']>) =>
      mutate(walletClient!, mutation.borrow, { addressResolver })(...args),
    repayDebt: (...args: ExtractArgs<Contract['mutations']['repayDebt']>) =>
      mutate(walletClient!, mutation.repayDebt, { addressResolver })(...args),
    addLiquidity: (...args: ExtractArgs<Contract['mutations']['addLiquidity']>) =>
      mutate(walletClient!, mutation.addLiquidity, { addressResolver })(...args),
    removeLiquidity: (...args: ExtractArgs<Contract['mutations']['removeLiquidity']>) =>
      mutate(walletClient!, mutation.removeLiquidity, { addressResolver })(...args),
    addLiquidityConcentrated: (...args: ExtractArgs<Contract['mutations']['addLiquidityConcentrated']>) =>
      mutate(walletClient!, mutation.addLiquidityConcentrated, { addressResolver })(...args),
    removeLiquidityConcentrated: (...args: ExtractArgs<Contract['mutations']['removeLiquidityConcentrated']>) =>
      mutate(walletClient!, mutation.removeLiquidityConcentrated, { addressResolver })(...args),
  }
}
